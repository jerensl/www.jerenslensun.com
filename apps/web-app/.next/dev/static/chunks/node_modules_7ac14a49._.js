(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/outvariant/lib/index.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InvariantError",
    ()=>InvariantError,
    "format",
    ()=>format,
    "invariant",
    ()=>invariant
]);
// src/format.ts
var POSITIONALS_EXP = /(%?)(%([sdijo]))/g;
function serializePositional(positional, flag) {
    switch(flag){
        case "s":
            return positional;
        case "d":
        case "i":
            return Number(positional);
        case "j":
            return JSON.stringify(positional);
        case "o":
            {
                if (typeof positional === "string") {
                    return positional;
                }
                const json = JSON.stringify(positional);
                if (json === "{}" || json === "[]" || /^\[object .+?\]$/.test(json)) {
                    return positional;
                }
                return json;
            }
    }
}
function format(message, ...positionals) {
    if (positionals.length === 0) {
        return message;
    }
    let positionalIndex = 0;
    let formattedMessage = message.replace(POSITIONALS_EXP, (match, isEscaped, _, flag)=>{
        const positional = positionals[positionalIndex];
        const value = serializePositional(positional, flag);
        if (!isEscaped) {
            positionalIndex++;
            return value;
        }
        return match;
    });
    if (positionalIndex < positionals.length) {
        formattedMessage += ` ${positionals.slice(positionalIndex).join(" ")}`;
    }
    formattedMessage = formattedMessage.replace(/%{2,2}/g, "%");
    return formattedMessage;
}
// src/invariant.ts
var STACK_FRAMES_TO_IGNORE = 2;
function cleanErrorStack(error) {
    if (!error.stack) {
        return;
    }
    const nextStack = error.stack.split("\n");
    nextStack.splice(1, STACK_FRAMES_TO_IGNORE);
    error.stack = nextStack.join("\n");
}
var InvariantError = class extends Error {
    constructor(message, ...positionals){
        super(message);
        this.message = message;
        this.name = "Invariant Violation";
        this.message = format(message, ...positionals);
        cleanErrorStack(this);
    }
};
var invariant = (predicate, message, ...positionals)=>{
    if (!predicate) {
        throw new InvariantError(message, ...positionals);
    }
};
invariant.as = (ErrorConstructor, predicate, message, ...positionals)=>{
    if (!predicate) {
        const formatMessage = positionals.length === 0 ? message : format(message, ...positionals);
        let error;
        try {
            error = Reflect.construct(ErrorConstructor, [
                formatMessage
            ]);
        } catch (err) {
            error = ErrorConstructor(formatMessage);
        }
        throw error;
    }
};
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@open-draft/until/lib/index.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "until",
    ()=>until
]);
// src/until.ts
var until = async (promise)=>{
    try {
        const data = await promise().catch((error)=>{
            throw error;
        });
        return {
            error: null,
            data
        };
    } catch (error) {
        return {
            error,
            data: null
        };
    }
};
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/is-node-process/lib/index.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isNodeProcess",
    ()=>isNodeProcess
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
// src/index.ts
function isNodeProcess() {
    if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
        return true;
    }
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== "undefined") {
        const type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].type;
        if (type === "renderer" || type === "worker") {
            return false;
        }
        return !!(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].versions && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].versions.node);
    }
    return false;
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/domain.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>getDomain
]);
/**
 * Check if `vhost` is a valid suffix of `hostname` (top-domain)
 *
 * It means that `vhost` needs to be a suffix of `hostname` and we then need to
 * make sure that: either they are equal, or the character preceding `vhost` in
 * `hostname` is a '.' (it should not be a partial label).
 *
 * * hostname = 'not.evil.com' and vhost = 'vil.com'      => not ok
 * * hostname = 'not.evil.com' and vhost = 'evil.com'     => ok
 * * hostname = 'not.evil.com' and vhost = 'not.evil.com' => ok
 */ function shareSameDomainSuffix(hostname, vhost) {
    if (hostname.endsWith(vhost)) {
        return hostname.length === vhost.length || hostname[hostname.length - vhost.length - 1] === '.';
    }
    return false;
}
/**
 * Given a hostname and its public suffix, extract the general domain.
 */ function extractDomainWithSuffix(hostname, publicSuffix) {
    // Locate the index of the last '.' in the part of the `hostname` preceding
    // the public suffix.
    //
    // examples:
    //   1. not.evil.co.uk  => evil.co.uk
    //         ^    ^
    //         |    | start of public suffix
    //         | index of the last dot
    //
    //   2. example.co.uk   => example.co.uk
    //     ^       ^
    //     |       | start of public suffix
    //     |
    //     | (-1) no dot found before the public suffix
    const publicSuffixIndex = hostname.length - publicSuffix.length - 2;
    const lastDotBeforeSuffixIndex = hostname.lastIndexOf('.', publicSuffixIndex);
    // No '.' found, then `hostname` is the general domain (no sub-domain)
    if (lastDotBeforeSuffixIndex === -1) {
        return hostname;
    }
    // Extract the part between the last '.'
    return hostname.slice(lastDotBeforeSuffixIndex + 1);
}
function getDomain(suffix, hostname, options) {
    // Check if `hostname` ends with a member of `validHosts`.
    if (options.validHosts !== null) {
        const validHosts = options.validHosts;
        for (const vhost of validHosts){
            if (/*@__INLINE__*/ shareSameDomainSuffix(hostname, vhost)) {
                return vhost;
            }
        }
    }
    let numberOfLeadingDots = 0;
    if (hostname.startsWith('.')) {
        while(numberOfLeadingDots < hostname.length && hostname[numberOfLeadingDots] === '.'){
            numberOfLeadingDots += 1;
        }
    }
    // If `hostname` is a valid public suffix, then there is no domain to return.
    // Since we already know that `getPublicSuffix` returns a suffix of `hostname`
    // there is no need to perform a string comparison and we only compare the
    // size.
    if (suffix.length === hostname.length - numberOfLeadingDots) {
        return null;
    }
    // To extract the general domain, we start by identifying the public suffix
    // (if any), then consider the domain to be the public suffix with one added
    // level of depth. (e.g.: if hostname is `not.evil.co.uk` and public suffix:
    // `co.uk`, then we take one more level: `evil`, giving the final result:
    // `evil.co.uk`).
    return /*@__INLINE__*/ extractDomainWithSuffix(hostname, suffix);
} //# sourceMappingURL=domain.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/domain-without-suffix.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Return the part of domain without suffix.
 *
 * Example: for domain 'foo.com', the result would be 'foo'.
 */ __turbopack_context__.s([
    "default",
    ()=>getDomainWithoutSuffix
]);
function getDomainWithoutSuffix(domain, suffix) {
    // Note: here `domain` and `suffix` cannot have the same length because in
    // this case we set `domain` to `null` instead. It is thus safe to assume
    // that `suffix` is shorter than `domain`.
    return domain.slice(0, -suffix.length - 1);
} //# sourceMappingURL=domain-without-suffix.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/extract-hostname.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @param url - URL we want to extract a hostname from.
 * @param urlIsValidHostname - hint from caller; true if `url` is already a valid hostname.
 */ __turbopack_context__.s([
    "default",
    ()=>extractHostname
]);
function extractHostname(url, urlIsValidHostname) {
    let start = 0;
    let end = url.length;
    let hasUpper = false;
    // If url is not already a valid hostname, then try to extract hostname.
    if (!urlIsValidHostname) {
        // Special handling of data URLs
        if (url.startsWith('data:')) {
            return null;
        }
        // Trim leading spaces
        while(start < url.length && url.charCodeAt(start) <= 32){
            start += 1;
        }
        // Trim trailing spaces
        while(end > start + 1 && url.charCodeAt(end - 1) <= 32){
            end -= 1;
        }
        // Skip scheme.
        if (url.charCodeAt(start) === 47 /* '/' */  && url.charCodeAt(start + 1) === 47 /* '/' */ ) {
            start += 2;
        } else {
            const indexOfProtocol = url.indexOf(':/', start);
            if (indexOfProtocol !== -1) {
                // Implement fast-path for common protocols. We expect most protocols
                // should be one of these 4 and thus we will not need to perform the
                // more expansive validity check most of the time.
                const protocolSize = indexOfProtocol - start;
                const c0 = url.charCodeAt(start);
                const c1 = url.charCodeAt(start + 1);
                const c2 = url.charCodeAt(start + 2);
                const c3 = url.charCodeAt(start + 3);
                const c4 = url.charCodeAt(start + 4);
                if (protocolSize === 5 && c0 === 104 /* 'h' */  && c1 === 116 /* 't' */  && c2 === 116 /* 't' */  && c3 === 112 /* 'p' */  && c4 === 115 /* 's' */ ) {
                // https
                } else if (protocolSize === 4 && c0 === 104 /* 'h' */  && c1 === 116 /* 't' */  && c2 === 116 /* 't' */  && c3 === 112 /* 'p' */ ) {
                // http
                } else if (protocolSize === 3 && c0 === 119 /* 'w' */  && c1 === 115 /* 's' */  && c2 === 115 /* 's' */ ) {
                // wss
                } else if (protocolSize === 2 && c0 === 119 /* 'w' */  && c1 === 115 /* 's' */ ) {
                // ws
                } else {
                    // Check that scheme is valid
                    for(let i = start; i < indexOfProtocol; i += 1){
                        const lowerCaseCode = url.charCodeAt(i) | 32;
                        if (!(lowerCaseCode >= 97 && lowerCaseCode <= 122 || lowerCaseCode >= 48 && lowerCaseCode <= 57 || // [0, 9]
                        lowerCaseCode === 46 || // '.'
                        lowerCaseCode === 45 || // '-'
                        lowerCaseCode === 43) // '+'
                        ) {
                            return null;
                        }
                    }
                }
                // Skip 0, 1 or more '/' after ':/'
                start = indexOfProtocol + 2;
                while(url.charCodeAt(start) === 47 /* '/' */ ){
                    start += 1;
                }
            }
        }
        // Detect first occurrence of '/', '?' or '#'. We also keep track of the
        // last occurrence of '@', ']' or ':' to speed-up subsequent parsing of
        // (respectively), identifier, ipv6 or port.
        let indexOfIdentifier = -1;
        let indexOfClosingBracket = -1;
        let indexOfPort = -1;
        for(let i = start; i < end; i += 1){
            const code = url.charCodeAt(i);
            if (code === 35 || // '#'
            code === 47 || // '/'
            code === 63 // '?'
            ) {
                end = i;
                break;
            } else if (code === 64) {
                // '@'
                indexOfIdentifier = i;
            } else if (code === 93) {
                // ']'
                indexOfClosingBracket = i;
            } else if (code === 58) {
                // ':'
                indexOfPort = i;
            } else if (code >= 65 && code <= 90) {
                hasUpper = true;
            }
        }
        // Detect identifier: '@'
        if (indexOfIdentifier !== -1 && indexOfIdentifier > start && indexOfIdentifier < end) {
            start = indexOfIdentifier + 1;
        }
        // Handle ipv6 addresses
        if (url.charCodeAt(start) === 91 /* '[' */ ) {
            if (indexOfClosingBracket !== -1) {
                return url.slice(start + 1, indexOfClosingBracket).toLowerCase();
            }
            return null;
        } else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {
            // Detect port: ':'
            end = indexOfPort;
        }
    }
    // Trim trailing dots
    while(end > start + 1 && url.charCodeAt(end - 1) === 46 /* '.' */ ){
        end -= 1;
    }
    const hostname = start !== 0 || end !== url.length ? url.slice(start, end) : url;
    if (hasUpper) {
        return hostname.toLowerCase();
    }
    return hostname;
} //# sourceMappingURL=extract-hostname.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/is-ip.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>isIp
]);
/**
 * Check if a hostname is an IP. You should be aware that this only works
 * because `hostname` is already garanteed to be a valid hostname!
 */ function isProbablyIpv4(hostname) {
    // Cannot be shorted than 1.1.1.1
    if (hostname.length < 7) {
        return false;
    }
    // Cannot be longer than: 255.255.255.255
    if (hostname.length > 15) {
        return false;
    }
    let numberOfDots = 0;
    for(let i = 0; i < hostname.length; i += 1){
        const code = hostname.charCodeAt(i);
        if (code === 46 /* '.' */ ) {
            numberOfDots += 1;
        } else if (code < 48 /* '0' */  || code > 57 /* '9' */ ) {
            return false;
        }
    }
    return numberOfDots === 3 && hostname.charCodeAt(0) !== 46 /* '.' */  && hostname.charCodeAt(hostname.length - 1) !== 46 /* '.' */ ;
}
/**
 * Similar to isProbablyIpv4.
 */ function isProbablyIpv6(hostname) {
    if (hostname.length < 3) {
        return false;
    }
    let start = hostname.startsWith('[') ? 1 : 0;
    let end = hostname.length;
    if (hostname[end - 1] === ']') {
        end -= 1;
    }
    // We only consider the maximum size of a normal IPV6. Note that this will
    // fail on so-called "IPv4 mapped IPv6 addresses" but this is a corner-case
    // and a proper validation library should be used for these.
    if (end - start > 39) {
        return false;
    }
    let hasColon = false;
    for(; start < end; start += 1){
        const code = hostname.charCodeAt(start);
        if (code === 58 /* ':' */ ) {
            hasColon = true;
        } else if (!(code >= 48 && code <= 57 || code >= 97 && code <= 102 || code >= 65 && code <= 90) // A-F
        ) {
            return false;
        }
    }
    return hasColon;
}
function isIp(hostname) {
    return isProbablyIpv6(hostname) || isProbablyIpv4(hostname);
} //# sourceMappingURL=is-ip.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/is-valid.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
/**
 * Implements fast shallow verification of hostnames. This does not perform a
 * struct check on the content of labels (classes of Unicode characters, etc.)
 * but instead check that the structure is valid (number of labels, length of
 * labels, etc.).
 *
 * If you need stricter validation, consider using an external library.
 */ function isValidAscii(code) {
    return code >= 97 && code <= 122 || code >= 48 && code <= 57 || code > 127;
}
function __TURBOPACK__default__export__(hostname) {
    if (hostname.length > 255) {
        return false;
    }
    if (hostname.length === 0) {
        return false;
    }
    if (/*@__INLINE__*/ !isValidAscii(hostname.charCodeAt(0)) && hostname.charCodeAt(0) !== 46 && // '.' (dot)
    hostname.charCodeAt(0) !== 95 // '_' (underscore)
    ) {
        return false;
    }
    // Validate hostname according to RFC
    let lastDotIndex = -1;
    let lastCharCode = -1;
    const len = hostname.length;
    for(let i = 0; i < len; i += 1){
        const code = hostname.charCodeAt(i);
        if (code === 46 /* '.' */ ) {
            if (// Check that previous label is < 63 bytes long (64 = 63 + '.')
            i - lastDotIndex > 64 || // Check that previous character was not already a '.'
            lastCharCode === 46 || // Check that the previous label does not end with a '-' (dash)
            lastCharCode === 45 || // Check that the previous label does not end with a '_' (underscore)
            lastCharCode === 95) {
                return false;
            }
            lastDotIndex = i;
        } else if (!/*@__INLINE__*/ (isValidAscii(code) || code === 45 || code === 95)) {
            // Check if there is a forbidden character in the label
            return false;
        }
        lastCharCode = code;
    }
    return(// Check that last label is shorter than 63 chars
    len - lastDotIndex - 1 <= 63 && // Check that the last character is an allowed trailing label character.
    // Since we already checked that the char is a valid hostname character,
    // we only need to check that it's different from '-'.
    lastCharCode !== 45);
} //# sourceMappingURL=is-valid.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/options.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "setDefaults",
    ()=>setDefaults
]);
function setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname = true, mixedInputs = true, validHosts = null, validateHostname = true }) {
    return {
        allowIcannDomains,
        allowPrivateDomains,
        detectIp,
        extractHostname,
        mixedInputs,
        validHosts,
        validateHostname
    };
}
const DEFAULT_OPTIONS = /*@__INLINE__*/ setDefaultsImpl({});
function setDefaults(options) {
    if (options === undefined) {
        return DEFAULT_OPTIONS;
    }
    return /*@__INLINE__*/ setDefaultsImpl(options);
} //# sourceMappingURL=options.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/subdomain.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Returns the subdomain of a hostname string
 */ __turbopack_context__.s([
    "default",
    ()=>getSubdomain
]);
function getSubdomain(hostname, domain) {
    // If `hostname` and `domain` are the same, then there is no sub-domain
    if (domain.length === hostname.length) {
        return '';
    }
    return hostname.slice(0, -domain.length - 1);
} //# sourceMappingURL=subdomain.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/factory.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getEmptyResult",
    ()=>getEmptyResult,
    "parseImpl",
    ()=>parseImpl,
    "resetResult",
    ()=>resetResult
]);
/**
 * Implement a factory allowing to plug different implementations of suffix
 * lookup (e.g.: using a trie or the packed hashes datastructures). This is used
 * and exposed in `tldts.ts` and `tldts-experimental.ts` bundle entrypoints.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$domain$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/domain.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$domain$2d$without$2d$suffix$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/domain-without-suffix.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$extract$2d$hostname$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/extract-hostname.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/is-ip.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$is$2d$valid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/is-valid.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$options$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/options.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$subdomain$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/subdomain.js [client] (ecmascript)");
;
;
;
;
;
;
;
function getEmptyResult() {
    return {
        domain: null,
        domainWithoutSuffix: null,
        hostname: null,
        isIcann: null,
        isIp: null,
        isPrivate: null,
        publicSuffix: null,
        subdomain: null
    };
}
function resetResult(result) {
    result.domain = null;
    result.domainWithoutSuffix = null;
    result.hostname = null;
    result.isIcann = null;
    result.isIp = null;
    result.isPrivate = null;
    result.publicSuffix = null;
    result.subdomain = null;
}
function parseImpl(url, step, suffixLookup, partialOptions, result) {
    const options = /*@__INLINE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$options$2e$js__$5b$client$5d$__$28$ecmascript$29$__["setDefaults"])(partialOptions);
    // Very fast approximate check to make sure `url` is a string. This is needed
    // because the library will not necessarily be used in a typed setup and
    // values of arbitrary types might be given as argument.
    if (typeof url !== 'string') {
        return result;
    }
    // Extract hostname from `url` only if needed. This can be made optional
    // using `options.extractHostname`. This option will typically be used
    // whenever we are sure the inputs to `parse` are already hostnames and not
    // arbitrary URLs.
    //
    // `mixedInput` allows to specify if we expect a mix of URLs and hostnames
    // as input. If only hostnames are expected then `extractHostname` can be
    // set to `false` to speed-up parsing. If only URLs are expected then
    // `mixedInputs` can be set to `false`. The `mixedInputs` is only a hint
    // and will not change the behavior of the library.
    if (!options.extractHostname) {
        result.hostname = url;
    } else if (options.mixedInputs) {
        result.hostname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$extract$2d$hostname$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(url, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$is$2d$valid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(url));
    } else {
        result.hostname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$extract$2d$hostname$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(url, false);
    }
    // Check if `hostname` is a valid ip address
    if (options.detectIp && result.hostname !== null) {
        result.isIp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(result.hostname);
        if (result.isIp) {
            return result;
        }
    }
    // Perform hostname validation if enabled. If hostname is not valid, no need to
    // go further as there will be no valid domain or sub-domain. This validation
    // is applied before any early returns to ensure consistent behavior across
    // all API methods including getHostname().
    if (options.validateHostname && options.extractHostname && result.hostname !== null && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$is$2d$valid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(result.hostname)) {
        result.hostname = null;
        return result;
    }
    if (step === 0 /* FLAG.HOSTNAME */  || result.hostname === null) {
        return result;
    }
    // Extract public suffix
    suffixLookup(result.hostname, options, result);
    if (step === 2 /* FLAG.PUBLIC_SUFFIX */  || result.publicSuffix === null) {
        return result;
    }
    // Extract domain
    result.domain = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$domain$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(result.publicSuffix, result.hostname, options);
    if (step === 3 /* FLAG.DOMAIN */  || result.domain === null) {
        return result;
    }
    // Extract subdomain
    result.subdomain = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$subdomain$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(result.hostname, result.domain);
    if (step === 4 /* FLAG.SUB_DOMAIN */ ) {
        return result;
    }
    // Extract domain without suffix
    result.domainWithoutSuffix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$domain$2d$without$2d$suffix$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(result.domain, result.publicSuffix);
    return result;
} //# sourceMappingURL=factory.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/lookup/fast-path.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
function __TURBOPACK__default__export__(hostname, options, out) {
    // Fast path for very popular suffixes; this allows to by-pass lookup
    // completely as well as any extra allocation or string manipulation.
    if (!options.allowPrivateDomains && hostname.length > 3) {
        const last = hostname.length - 1;
        const c3 = hostname.charCodeAt(last);
        const c2 = hostname.charCodeAt(last - 1);
        const c1 = hostname.charCodeAt(last - 2);
        const c0 = hostname.charCodeAt(last - 3);
        if (c3 === 109 /* 'm' */  && c2 === 111 /* 'o' */  && c1 === 99 /* 'c' */  && c0 === 46 /* '.' */ ) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'com';
            return true;
        } else if (c3 === 103 /* 'g' */  && c2 === 114 /* 'r' */  && c1 === 111 /* 'o' */  && c0 === 46 /* '.' */ ) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'org';
            return true;
        } else if (c3 === 117 /* 'u' */  && c2 === 100 /* 'd' */  && c1 === 101 /* 'e' */  && c0 === 46 /* '.' */ ) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'edu';
            return true;
        } else if (c3 === 118 /* 'v' */  && c2 === 111 /* 'o' */  && c1 === 103 /* 'g' */  && c0 === 46 /* '.' */ ) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'gov';
            return true;
        } else if (c3 === 116 /* 't' */  && c2 === 101 /* 'e' */  && c1 === 110 /* 'n' */  && c0 === 46 /* '.' */ ) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'net';
            return true;
        } else if (c3 === 101 /* 'e' */  && c2 === 100 /* 'd' */  && c1 === 46 /* '.' */ ) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'de';
            return true;
        }
    }
    return false;
} //# sourceMappingURL=fast-path.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/index.js [client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$factory$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/factory.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$lookup$2f$fast$2d$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/lookup/fast-path.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$options$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/options.js [client] (ecmascript)"); //# sourceMappingURL=index.js.map
;
;
;
}),
"[project]/node_modules/tldts-core/dist/es6/src/lookup/fast-path.js [client] (ecmascript) <export default as fastPathLookup>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fastPathLookup",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$lookup$2f$fast$2d$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$lookup$2f$fast$2d$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/lookup/fast-path.js [client] (ecmascript)");
}),
"[project]/node_modules/msw/node_modules/tough-cookie/dist/index.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Cookie",
    ()=>Cookie,
    "CookieJar",
    ()=>CookieJar,
    "MemoryCookieStore",
    ()=>MemoryCookieStore,
    "ParameterError",
    ()=>ParameterError,
    "PrefixSecurityEnum",
    ()=>PrefixSecurityEnum,
    "Store",
    ()=>Store,
    "canonicalDomain",
    ()=>canonicalDomain,
    "cookieCompare",
    ()=>cookieCompare,
    "defaultPath",
    ()=>defaultPath,
    "domainMatch",
    ()=>domainMatch,
    "formatDate",
    ()=>formatDate,
    "fromJSON",
    ()=>fromJSON2,
    "getPublicSuffix",
    ()=>getPublicSuffix,
    "parse",
    ()=>parse2,
    "parseDate",
    ()=>parseDate,
    "pathMatch",
    ()=>pathMatch,
    "permuteDomain",
    ()=>permuteDomain,
    "permutePath",
    ()=>permutePath,
    "version",
    ()=>version
]);
// lib/getPublicSuffix.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2f$dist$2f$es6$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts/dist/es6/index.js [client] (ecmascript)");
// lib/pathMatch.ts
function pathMatch(reqPath, cookiePath) {
    if (cookiePath === reqPath) {
        return true;
    }
    const idx = reqPath.indexOf(cookiePath);
    if (idx === 0) {
        if (cookiePath[cookiePath.length - 1] === "/") {
            return true;
        }
        if (reqPath.startsWith(cookiePath) && reqPath[cookiePath.length] === "/") {
            return true;
        }
    }
    return false;
}
;
var SPECIAL_USE_DOMAINS = [
    "local",
    "example",
    "invalid",
    "localhost",
    "test"
];
var SPECIAL_TREATMENT_DOMAINS = [
    "localhost",
    "invalid"
];
var defaultGetPublicSuffixOptions = {
    allowSpecialUseDomain: false,
    ignoreError: false
};
function getPublicSuffix(domain, options = {}) {
    options = {
        ...defaultGetPublicSuffixOptions,
        ...options
    };
    const domainParts = domain.split(".");
    const topLevelDomain = domainParts[domainParts.length - 1];
    const allowSpecialUseDomain = !!options.allowSpecialUseDomain;
    const ignoreError = !!options.ignoreError;
    if (allowSpecialUseDomain && topLevelDomain !== void 0 && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
        if (domainParts.length > 1) {
            const secondLevelDomain = domainParts[domainParts.length - 2];
            return `${secondLevelDomain}.${topLevelDomain}`;
        } else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {
            return topLevelDomain;
        }
    }
    if (!ignoreError && topLevelDomain !== void 0 && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
        throw new Error(`Cookie has domain set to the public suffix "${topLevelDomain}" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain: true, rejectPublicSuffixes: false}.`);
    }
    const publicSuffix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2f$dist$2f$es6$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getDomain"])(domain, {
        allowIcannDomains: true,
        allowPrivateDomains: true
    });
    if (publicSuffix) return publicSuffix;
}
// lib/permuteDomain.ts
function permuteDomain(domain, allowSpecialUseDomain) {
    const pubSuf = getPublicSuffix(domain, {
        allowSpecialUseDomain
    });
    if (!pubSuf) {
        return void 0;
    }
    if (pubSuf == domain) {
        return [
            domain
        ];
    }
    if (domain.slice(-1) == ".") {
        domain = domain.slice(0, -1);
    }
    const prefix = domain.slice(0, -(pubSuf.length + 1));
    const parts = prefix.split(".").reverse();
    let cur = pubSuf;
    const permutations = [
        cur
    ];
    while(parts.length){
        const part = parts.shift();
        cur = `${part}.${cur}`;
        permutations.push(cur);
    }
    return permutations;
}
// lib/store.ts
var Store = class {
    constructor(){
        this.synchronous = false;
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ findCookie(_domain, _path, _key, _callback) {
        throw new Error("findCookie is not implemented");
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ findCookies(_domain, _path, _allowSpecialUseDomain = false, _callback) {
        throw new Error("findCookies is not implemented");
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ putCookie(_cookie, _callback) {
        throw new Error("putCookie is not implemented");
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ updateCookie(_oldCookie, _newCookie, _callback) {
        throw new Error("updateCookie is not implemented");
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ removeCookie(_domain, _path, _key, _callback) {
        throw new Error("removeCookie is not implemented");
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ removeCookies(_domain, _path, _callback) {
        throw new Error("removeCookies is not implemented");
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ removeAllCookies(_callback) {
        throw new Error("removeAllCookies is not implemented");
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ getAllCookies(_callback) {
        throw new Error("getAllCookies is not implemented (therefore jar cannot be serialized)");
    }
};
// lib/utils.ts
var objectToString = (obj)=>Object.prototype.toString.call(obj);
var safeArrayToString = (arr, seenArrays)=>{
    if (typeof arr.join !== "function") return objectToString(arr);
    seenArrays.add(arr);
    const mapped = arr.map((val)=>val === null || val === void 0 || seenArrays.has(val) ? "" : safeToStringImpl(val, seenArrays));
    return mapped.join();
};
var safeToStringImpl = (val, seenArrays = /* @__PURE__ */ new WeakSet())=>{
    if (typeof val !== "object" || val === null) {
        return String(val);
    } else if (typeof val.toString === "function") {
        return Array.isArray(val) ? // Arrays have a weird custom toString that we need to replicate
        safeArrayToString(val, seenArrays) : // eslint-disable-next-line @typescript-eslint/no-base-to-string
        String(val);
    } else {
        return objectToString(val);
    }
};
var safeToString = (val)=>safeToStringImpl(val);
function createPromiseCallback(cb) {
    let callback;
    let resolve;
    let reject;
    const promise = new Promise((_resolve, _reject)=>{
        resolve = _resolve;
        reject = _reject;
    });
    if (typeof cb === "function") {
        callback = (err, result)=>{
            try {
                if (err) cb(err);
                else cb(null, result);
            } catch (e) {
                reject(e instanceof Error ? e : new Error());
            }
        };
    } else {
        callback = (err, result)=>{
            try {
                if (err) reject(err);
                else resolve(result);
            } catch (e) {
                reject(e instanceof Error ? e : new Error());
            }
        };
    }
    return {
        promise,
        callback,
        resolve: (value)=>{
            callback(null, value);
            return promise;
        },
        reject: (error)=>{
            callback(error);
            return promise;
        }
    };
}
function inOperator(k, o) {
    return k in o;
}
// lib/memstore.ts
var MemoryCookieStore = class extends Store {
    /**
   * Create a new {@link MemoryCookieStore}.
   */ constructor(){
        super();
        this.synchronous = true;
        this.idx = /* @__PURE__ */ Object.create(null);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ findCookie(domain, path, key, callback) {
        const promiseCallback = createPromiseCallback(callback);
        if (domain == null || path == null || key == null) {
            return promiseCallback.resolve(void 0);
        }
        const result = this.idx[domain]?.[path]?.[key];
        return promiseCallback.resolve(result);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ findCookies(domain, path, allowSpecialUseDomain = false, callback) {
        if (typeof allowSpecialUseDomain === "function") {
            callback = allowSpecialUseDomain;
            allowSpecialUseDomain = true;
        }
        const results = [];
        const promiseCallback = createPromiseCallback(callback);
        if (!domain) {
            return promiseCallback.resolve([]);
        }
        let pathMatcher;
        if (!path) {
            pathMatcher = function matchAll(domainIndex) {
                for(const curPath in domainIndex){
                    const pathIndex = domainIndex[curPath];
                    for(const key in pathIndex){
                        const value = pathIndex[key];
                        if (value) {
                            results.push(value);
                        }
                    }
                }
            };
        } else {
            pathMatcher = function matchRFC(domainIndex) {
                for(const cookiePath in domainIndex){
                    if (pathMatch(path, cookiePath)) {
                        const pathIndex = domainIndex[cookiePath];
                        for(const key in pathIndex){
                            const value = pathIndex[key];
                            if (value) {
                                results.push(value);
                            }
                        }
                    }
                }
            };
        }
        const domains = permuteDomain(domain, allowSpecialUseDomain) || [
            domain
        ];
        const idx = this.idx;
        domains.forEach((curDomain)=>{
            const domainIndex = idx[curDomain];
            if (!domainIndex) {
                return;
            }
            pathMatcher(domainIndex);
        });
        return promiseCallback.resolve(results);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ putCookie(cookie, callback) {
        const promiseCallback = createPromiseCallback(callback);
        const { domain, path, key } = cookie;
        if (domain == null || path == null || key == null) {
            return promiseCallback.resolve(void 0);
        }
        const domainEntry = this.idx[domain] ?? /* @__PURE__ */ Object.create(null);
        this.idx[domain] = domainEntry;
        const pathEntry = domainEntry[path] ?? /* @__PURE__ */ Object.create(null);
        domainEntry[path] = pathEntry;
        pathEntry[key] = cookie;
        return promiseCallback.resolve(void 0);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ updateCookie(_oldCookie, newCookie, callback) {
        if (callback) this.putCookie(newCookie, callback);
        else return this.putCookie(newCookie);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ removeCookie(domain, path, key, callback) {
        const promiseCallback = createPromiseCallback(callback);
        delete this.idx[domain]?.[path]?.[key];
        return promiseCallback.resolve(void 0);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ removeCookies(domain, path, callback) {
        const promiseCallback = createPromiseCallback(callback);
        const domainEntry = this.idx[domain];
        if (domainEntry) {
            if (path) {
                delete domainEntry[path];
            } else {
                delete this.idx[domain];
            }
        }
        return promiseCallback.resolve(void 0);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ removeAllCookies(callback) {
        const promiseCallback = createPromiseCallback(callback);
        this.idx = /* @__PURE__ */ Object.create(null);
        return promiseCallback.resolve(void 0);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ getAllCookies(callback) {
        const promiseCallback = createPromiseCallback(callback);
        const cookies = [];
        const idx = this.idx;
        const domains = Object.keys(idx);
        domains.forEach((domain)=>{
            const domainEntry = idx[domain] ?? {};
            const paths = Object.keys(domainEntry);
            paths.forEach((path)=>{
                const pathEntry = domainEntry[path] ?? {};
                const keys = Object.keys(pathEntry);
                keys.forEach((key)=>{
                    const keyEntry = pathEntry[key];
                    if (keyEntry != null) {
                        cookies.push(keyEntry);
                    }
                });
            });
        });
        cookies.sort((a, b)=>{
            return (a.creationIndex || 0) - (b.creationIndex || 0);
        });
        return promiseCallback.resolve(cookies);
    }
};
// lib/validators.ts
function isNonEmptyString(data) {
    return isString(data) && data !== "";
}
function isEmptyString(data) {
    return data === "" || data instanceof String && data.toString() === "";
}
function isString(data) {
    return typeof data === "string" || data instanceof String;
}
function isObject(data) {
    return objectToString(data) === "[object Object]";
}
function validate(bool, cbOrMessage, message) {
    if (bool) return;
    const cb = typeof cbOrMessage === "function" ? cbOrMessage : void 0;
    let options = typeof cbOrMessage === "function" ? message : cbOrMessage;
    if (!isObject(options)) options = "[object Object]";
    const err = new ParameterError(safeToString(options));
    if (cb) cb(err);
    else throw err;
}
var ParameterError = class extends Error {
};
// lib/version.ts
var version = "6.0.0";
// lib/cookie/constants.ts
var PrefixSecurityEnum = {
    SILENT: "silent",
    STRICT: "strict",
    DISABLED: "unsafe-disabled"
};
Object.freeze(PrefixSecurityEnum);
var IP_V6_REGEX = `
\\[?(?:
(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|
(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|
(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|
(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|
(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:))
)(?:%[0-9a-zA-Z]{1,})?\\]?
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
var IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);
var IP_V4_REGEX = `(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])`;
var IP_V4_REGEX_OBJECT = new RegExp(`^${IP_V4_REGEX}$`);
// lib/cookie/canonicalDomain.ts
function domainToASCII(domain) {
    return new URL(`http://${domain}`).hostname;
}
function canonicalDomain(domainName) {
    if (domainName == null) {
        return void 0;
    }
    let str = domainName.trim().replace(/^\./, "");
    if (IP_V6_REGEX_OBJECT.test(str)) {
        if (!str.startsWith("[")) {
            str = "[" + str;
        }
        if (!str.endsWith("]")) {
            str = str + "]";
        }
        return domainToASCII(str).slice(1, -1);
    }
    if (/[^\u0001-\u007f]/.test(str)) {
        return domainToASCII(str);
    }
    return str.toLowerCase();
}
// lib/cookie/formatDate.ts
function formatDate(date) {
    return date.toUTCString();
}
// lib/cookie/parseDate.ts
var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
var MONTH_TO_NUM = {
    jan: 0,
    feb: 1,
    mar: 2,
    apr: 3,
    may: 4,
    jun: 5,
    jul: 6,
    aug: 7,
    sep: 8,
    oct: 9,
    nov: 10,
    dec: 11
};
function parseDigits(token, minDigits, maxDigits, trailingOK) {
    let count = 0;
    while(count < token.length){
        const c = token.charCodeAt(count);
        if (c <= 47 || c >= 58) {
            break;
        }
        count++;
    }
    if (count < minDigits || count > maxDigits) {
        return;
    }
    if (!trailingOK && count != token.length) {
        return;
    }
    return parseInt(token.slice(0, count), 10);
}
function parseTime(token) {
    const parts = token.split(":");
    const result = [
        0,
        0,
        0
    ];
    if (parts.length !== 3) {
        return;
    }
    for(let i = 0; i < 3; i++){
        const trailingOK = i == 2;
        const numPart = parts[i];
        if (numPart === void 0) {
            return;
        }
        const num = parseDigits(numPart, 1, 2, trailingOK);
        if (num === void 0) {
            return;
        }
        result[i] = num;
    }
    return result;
}
function parseMonth(token) {
    token = String(token).slice(0, 3).toLowerCase();
    switch(token){
        case "jan":
            return MONTH_TO_NUM.jan;
        case "feb":
            return MONTH_TO_NUM.feb;
        case "mar":
            return MONTH_TO_NUM.mar;
        case "apr":
            return MONTH_TO_NUM.apr;
        case "may":
            return MONTH_TO_NUM.may;
        case "jun":
            return MONTH_TO_NUM.jun;
        case "jul":
            return MONTH_TO_NUM.jul;
        case "aug":
            return MONTH_TO_NUM.aug;
        case "sep":
            return MONTH_TO_NUM.sep;
        case "oct":
            return MONTH_TO_NUM.oct;
        case "nov":
            return MONTH_TO_NUM.nov;
        case "dec":
            return MONTH_TO_NUM.dec;
        default:
            return;
    }
}
function parseDate(cookieDate) {
    if (!cookieDate) {
        return;
    }
    const tokens = cookieDate.split(DATE_DELIM);
    let hour;
    let minute;
    let second;
    let dayOfMonth;
    let month;
    let year;
    for(let i = 0; i < tokens.length; i++){
        const token = (tokens[i] ?? "").trim();
        if (!token.length) {
            continue;
        }
        if (second === void 0) {
            const result = parseTime(token);
            if (result) {
                hour = result[0];
                minute = result[1];
                second = result[2];
                continue;
            }
        }
        if (dayOfMonth === void 0) {
            const result = parseDigits(token, 1, 2, true);
            if (result !== void 0) {
                dayOfMonth = result;
                continue;
            }
        }
        if (month === void 0) {
            const result = parseMonth(token);
            if (result !== void 0) {
                month = result;
                continue;
            }
        }
        if (year === void 0) {
            const result = parseDigits(token, 2, 4, true);
            if (result !== void 0) {
                year = result;
                if (year >= 70 && year <= 99) {
                    year += 1900;
                } else if (year >= 0 && year <= 69) {
                    year += 2e3;
                }
            }
        }
    }
    if (dayOfMonth === void 0 || month === void 0 || year === void 0 || hour === void 0 || minute === void 0 || second === void 0 || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
        return;
    }
    return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
}
// lib/cookie/cookie.ts
var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
var CONTROL_CHARS = /[\x00-\x1F]/;
var TERMINATORS = [
    "\n",
    "\r",
    "\0"
];
function trimTerminator(str) {
    if (isEmptyString(str)) return str;
    for(let t = 0; t < TERMINATORS.length; t++){
        const terminator = TERMINATORS[t];
        const terminatorIdx = terminator ? str.indexOf(terminator) : -1;
        if (terminatorIdx !== -1) {
            str = str.slice(0, terminatorIdx);
        }
    }
    return str;
}
function parseCookiePair(cookiePair, looseMode) {
    cookiePair = trimTerminator(cookiePair);
    let firstEq = cookiePair.indexOf("=");
    if (looseMode) {
        if (firstEq === 0) {
            cookiePair = cookiePair.substring(1);
            firstEq = cookiePair.indexOf("=");
        }
    } else {
        if (firstEq <= 0) {
            return void 0;
        }
    }
    let cookieName, cookieValue;
    if (firstEq <= 0) {
        cookieName = "";
        cookieValue = cookiePair.trim();
    } else {
        cookieName = cookiePair.slice(0, firstEq).trim();
        cookieValue = cookiePair.slice(firstEq + 1).trim();
    }
    if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
        return void 0;
    }
    const c = new Cookie();
    c.key = cookieName;
    c.value = cookieValue;
    return c;
}
function parse(str, options) {
    if (isEmptyString(str) || !isString(str)) {
        return void 0;
    }
    str = str.trim();
    const firstSemi = str.indexOf(";");
    const cookiePair = firstSemi === -1 ? str : str.slice(0, firstSemi);
    const c = parseCookiePair(cookiePair, options?.loose ?? false);
    if (!c) {
        return void 0;
    }
    if (firstSemi === -1) {
        return c;
    }
    const unparsed = str.slice(firstSemi + 1).trim();
    if (unparsed.length === 0) {
        return c;
    }
    const cookie_avs = unparsed.split(";");
    while(cookie_avs.length){
        const av = (cookie_avs.shift() ?? "").trim();
        if (av.length === 0) {
            continue;
        }
        const av_sep = av.indexOf("=");
        let av_key, av_value;
        if (av_sep === -1) {
            av_key = av;
            av_value = null;
        } else {
            av_key = av.slice(0, av_sep);
            av_value = av.slice(av_sep + 1);
        }
        av_key = av_key.trim().toLowerCase();
        if (av_value) {
            av_value = av_value.trim();
        }
        switch(av_key){
            case "expires":
                if (av_value) {
                    const exp = parseDate(av_value);
                    if (exp) {
                        c.expires = exp;
                    }
                }
                break;
            case "max-age":
                if (av_value) {
                    if (/^-?[0-9]+$/.test(av_value)) {
                        const delta = parseInt(av_value, 10);
                        c.setMaxAge(delta);
                    }
                }
                break;
            case "domain":
                if (av_value) {
                    const domain = av_value.trim().replace(/^\./, "");
                    if (domain) {
                        c.domain = domain.toLowerCase();
                    }
                }
                break;
            case "path":
                c.path = av_value && av_value[0] === "/" ? av_value : null;
                break;
            case "secure":
                c.secure = true;
                break;
            case "httponly":
                c.httpOnly = true;
                break;
            case "samesite":
                switch(av_value ? av_value.toLowerCase() : ""){
                    case "strict":
                        c.sameSite = "strict";
                        break;
                    case "lax":
                        c.sameSite = "lax";
                        break;
                    case "none":
                        c.sameSite = "none";
                        break;
                    default:
                        c.sameSite = void 0;
                        break;
                }
                break;
            default:
                c.extensions = c.extensions || [];
                c.extensions.push(av);
                break;
        }
    }
    return c;
}
function fromJSON(str) {
    if (!str || isEmptyString(str)) {
        return void 0;
    }
    let obj;
    if (typeof str === "string") {
        try {
            obj = JSON.parse(str);
        } catch  {
            return void 0;
        }
    } else {
        obj = str;
    }
    const c = new Cookie();
    Cookie.serializableProperties.forEach((prop)=>{
        if (obj && typeof obj === "object" && inOperator(prop, obj)) {
            const val = obj[prop];
            if (val === void 0) {
                return;
            }
            if (inOperator(prop, cookieDefaults) && val === cookieDefaults[prop]) {
                return;
            }
            switch(prop){
                case "key":
                case "value":
                case "sameSite":
                    if (typeof val === "string") {
                        c[prop] = val;
                    }
                    break;
                case "expires":
                case "creation":
                case "lastAccessed":
                    if (typeof val === "number" || typeof val === "string" || val instanceof Date) {
                        c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(val);
                    } else if (val === null) {
                        c[prop] = null;
                    }
                    break;
                case "maxAge":
                    if (typeof val === "number" || val === "Infinity" || val === "-Infinity") {
                        c[prop] = val;
                    }
                    break;
                case "domain":
                case "path":
                    if (typeof val === "string" || val === null) {
                        c[prop] = val;
                    }
                    break;
                case "secure":
                case "httpOnly":
                    if (typeof val === "boolean") {
                        c[prop] = val;
                    }
                    break;
                case "extensions":
                    if (Array.isArray(val) && val.every((item)=>typeof item === "string")) {
                        c[prop] = val;
                    }
                    break;
                case "hostOnly":
                case "pathIsDefault":
                    if (typeof val === "boolean" || val === null) {
                        c[prop] = val;
                    }
                    break;
            }
        }
    });
    return c;
}
var cookieDefaults = {
    // the order in which the RFC has them:
    key: "",
    value: "",
    expires: "Infinity",
    maxAge: null,
    domain: null,
    path: null,
    secure: false,
    httpOnly: false,
    extensions: null,
    // set by the CookieJar:
    hostOnly: null,
    pathIsDefault: null,
    creation: null,
    lastAccessed: null,
    sameSite: void 0
};
var _Cookie = class _Cookie {
    /**
   * Create a new Cookie instance.
   * @public
   * @param options - The attributes to set on the cookie
   */ constructor(options = {}){
        this.key = options.key ?? cookieDefaults.key;
        this.value = options.value ?? cookieDefaults.value;
        this.expires = options.expires ?? cookieDefaults.expires;
        this.maxAge = options.maxAge ?? cookieDefaults.maxAge;
        this.domain = options.domain ?? cookieDefaults.domain;
        this.path = options.path ?? cookieDefaults.path;
        this.secure = options.secure ?? cookieDefaults.secure;
        this.httpOnly = options.httpOnly ?? cookieDefaults.httpOnly;
        this.extensions = options.extensions ?? cookieDefaults.extensions;
        this.creation = options.creation ?? cookieDefaults.creation;
        this.hostOnly = options.hostOnly ?? cookieDefaults.hostOnly;
        this.pathIsDefault = options.pathIsDefault ?? cookieDefaults.pathIsDefault;
        this.lastAccessed = options.lastAccessed ?? cookieDefaults.lastAccessed;
        this.sameSite = options.sameSite ?? cookieDefaults.sameSite;
        this.creation = options.creation ?? /* @__PURE__ */ new Date();
        Object.defineProperty(this, "creationIndex", {
            configurable: false,
            enumerable: false,
            // important for assert.deepEqual checks
            writable: true,
            value: ++_Cookie.cookiesCreated
        });
        this.creationIndex = _Cookie.cookiesCreated;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        const now = Date.now();
        const hostOnly = this.hostOnly != null ? this.hostOnly.toString() : "?";
        const createAge = this.creation && this.creation !== "Infinity" ? `${String(now - this.creation.getTime())}ms` : "?";
        const accessAge = this.lastAccessed && this.lastAccessed !== "Infinity" ? `${String(now - this.lastAccessed.getTime())}ms` : "?";
        return `Cookie="${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}"`;
    }
    /**
   * For convenience in using `JSON.stringify(cookie)`. Returns a plain-old Object that can be JSON-serialized.
   *
   * @remarks
   * - Any `Date` properties (such as {@link Cookie.expires}, {@link Cookie.creation}, and {@link Cookie.lastAccessed}) are exported in ISO format (`Date.toISOString()`).
   *
   *  - Custom Cookie properties are discarded. In tough-cookie 1.x, since there was no {@link Cookie.toJSON} method explicitly defined, all enumerable properties were captured.
   *      If you want a property to be serialized, add the property name to {@link Cookie.serializableProperties}.
   */ toJSON() {
        const obj = {};
        for (const prop of _Cookie.serializableProperties){
            const val = this[prop];
            if (val === cookieDefaults[prop]) {
                continue;
            }
            switch(prop){
                case "key":
                case "value":
                case "sameSite":
                    if (typeof val === "string") {
                        obj[prop] = val;
                    }
                    break;
                case "expires":
                case "creation":
                case "lastAccessed":
                    if (typeof val === "number" || typeof val === "string" || val instanceof Date) {
                        obj[prop] = val == "Infinity" ? "Infinity" : new Date(val).toISOString();
                    } else if (val === null) {
                        obj[prop] = null;
                    }
                    break;
                case "maxAge":
                    if (typeof val === "number" || val === "Infinity" || val === "-Infinity") {
                        obj[prop] = val;
                    }
                    break;
                case "domain":
                case "path":
                    if (typeof val === "string" || val === null) {
                        obj[prop] = val;
                    }
                    break;
                case "secure":
                case "httpOnly":
                    if (typeof val === "boolean") {
                        obj[prop] = val;
                    }
                    break;
                case "extensions":
                    if (Array.isArray(val)) {
                        obj[prop] = val;
                    }
                    break;
                case "hostOnly":
                case "pathIsDefault":
                    if (typeof val === "boolean" || val === null) {
                        obj[prop] = val;
                    }
                    break;
            }
        }
        return obj;
    }
    /**
   * Does a deep clone of this cookie, implemented exactly as `Cookie.fromJSON(cookie.toJSON())`.
   * @public
   */ clone() {
        return fromJSON(this.toJSON());
    }
    /**
   * Validates cookie attributes for semantic correctness. Useful for "lint" checking any `Set-Cookie` headers you generate.
   * For now, it returns a boolean, but eventually could return a reason string.
   *
   * @remarks
   * Works for a few things, but is by no means comprehensive.
   *
   * @beta
   */ validate() {
        if (!this.value || !COOKIE_OCTETS.test(this.value)) {
            return false;
        }
        if (this.expires != "Infinity" && !(this.expires instanceof Date) && !parseDate(this.expires)) {
            return false;
        }
        if (this.maxAge != null && this.maxAge !== "Infinity" && (this.maxAge === "-Infinity" || this.maxAge <= 0)) {
            return false;
        }
        if (this.path != null && !PATH_VALUE.test(this.path)) {
            return false;
        }
        const cdomain = this.cdomain();
        if (cdomain) {
            if (cdomain.match(/\.$/)) {
                return false;
            }
            const suffix = getPublicSuffix(cdomain);
            if (suffix == null) {
                return false;
            }
        }
        return true;
    }
    /**
   * Sets the 'Expires' attribute on a cookie.
   *
   * @remarks
   * When given a `string` value it will be parsed with {@link parseDate}. If the value can't be parsed as a cookie date
   * then the 'Expires' attribute will be set to `"Infinity"`.
   *
   * @param exp - the new value for the 'Expires' attribute of the cookie.
   */ setExpires(exp) {
        if (exp instanceof Date) {
            this.expires = exp;
        } else {
            this.expires = parseDate(exp) || "Infinity";
        }
    }
    /**
   * Sets the 'Max-Age' attribute (in seconds) on a cookie.
   *
   * @remarks
   * Coerces `-Infinity` to `"-Infinity"` and `Infinity` to `"Infinity"` so it can be serialized to JSON.
   *
   * @param age - the new value for the 'Max-Age' attribute (in seconds).
   */ setMaxAge(age) {
        if (age === Infinity) {
            this.maxAge = "Infinity";
        } else if (age === -Infinity) {
            this.maxAge = "-Infinity";
        } else {
            this.maxAge = age;
        }
    }
    /**
   * Encodes to a `Cookie` header value (specifically, the {@link Cookie.key} and {@link Cookie.value} properties joined with "=").
   * @public
   */ cookieString() {
        const val = this.value || "";
        if (this.key) {
            return `${this.key}=${val}`;
        }
        return val;
    }
    /**
   * Encodes to a `Set-Cookie header` value.
   * @public
   */ toString() {
        let str = this.cookieString();
        if (this.expires != "Infinity") {
            if (this.expires instanceof Date) {
                str += `; Expires=${formatDate(this.expires)}`;
            }
        }
        if (this.maxAge != null && this.maxAge != Infinity) {
            str += `; Max-Age=${String(this.maxAge)}`;
        }
        if (this.domain && !this.hostOnly) {
            str += `; Domain=${this.domain}`;
        }
        if (this.path) {
            str += `; Path=${this.path}`;
        }
        if (this.secure) {
            str += "; Secure";
        }
        if (this.httpOnly) {
            str += "; HttpOnly";
        }
        if (this.sameSite && this.sameSite !== "none") {
            if (this.sameSite.toLowerCase() === _Cookie.sameSiteCanonical.lax.toLowerCase()) {
                str += `; SameSite=${_Cookie.sameSiteCanonical.lax}`;
            } else if (this.sameSite.toLowerCase() === _Cookie.sameSiteCanonical.strict.toLowerCase()) {
                str += `; SameSite=${_Cookie.sameSiteCanonical.strict}`;
            } else {
                str += `; SameSite=${this.sameSite}`;
            }
        }
        if (this.extensions) {
            this.extensions.forEach((ext)=>{
                str += `; ${ext}`;
            });
        }
        return str;
    }
    /**
   * Computes the TTL relative to now (milliseconds).
   *
   * @remarks
   * - `Infinity` is returned for cookies without an explicit expiry
   *
   * - `0` is returned if the cookie is expired.
   *
   * - Otherwise a time-to-live in milliseconds is returned.
   *
   * @param now - passing an explicit value is mostly used for testing purposes since this defaults to the `Date.now()`
   * @public
   */ TTL(now = Date.now()) {
        if (this.maxAge != null && typeof this.maxAge === "number") {
            return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;
        }
        const expires = this.expires;
        if (expires === "Infinity") {
            return Infinity;
        }
        return (expires?.getTime() ?? now) - (now || Date.now());
    }
    /**
   * Computes the absolute unix-epoch milliseconds that this cookie expires.
   *
   * The "Max-Age" attribute takes precedence over "Expires" (as per the RFC). The {@link Cookie.lastAccessed} attribute
   * (or the `now` parameter if given) is used to offset the {@link Cookie.maxAge} attribute.
   *
   * If Expires ({@link Cookie.expires}) is set, that's returned.
   *
   * @param now - can be used to provide a time offset (instead of {@link Cookie.lastAccessed}) to use when calculating the "Max-Age" value
   */ expiryTime(now) {
        if (this.maxAge != null) {
            const relativeTo = now || this.lastAccessed || /* @__PURE__ */ new Date();
            const maxAge = typeof this.maxAge === "number" ? this.maxAge : -Infinity;
            const age = maxAge <= 0 ? -Infinity : maxAge * 1e3;
            if (relativeTo === "Infinity") {
                return Infinity;
            }
            return relativeTo.getTime() + age;
        }
        if (this.expires == "Infinity") {
            return Infinity;
        }
        return this.expires ? this.expires.getTime() : void 0;
    }
    /**
   * Similar to {@link Cookie.expiryTime}, computes the absolute unix-epoch milliseconds that this cookie expires and returns it as a Date.
   *
   * The "Max-Age" attribute takes precedence over "Expires" (as per the RFC). The {@link Cookie.lastAccessed} attribute
   * (or the `now` parameter if given) is used to offset the {@link Cookie.maxAge} attribute.
   *
   * If Expires ({@link Cookie.expires}) is set, that's returned.
   *
   * @param now - can be used to provide a time offset (instead of {@link Cookie.lastAccessed}) to use when calculating the "Max-Age" value
   */ expiryDate(now) {
        const millisec = this.expiryTime(now);
        if (millisec == Infinity) {
            return /* @__PURE__ */ new Date(2147483647e3);
        } else if (millisec == -Infinity) {
            return /* @__PURE__ */ new Date(0);
        } else {
            return millisec == void 0 ? void 0 : new Date(millisec);
        }
    }
    /**
   * Indicates if the cookie has been persisted to a store or not.
   * @public
   */ isPersistent() {
        return this.maxAge != null || this.expires != "Infinity";
    }
    /**
   * Calls {@link canonicalDomain} with the {@link Cookie.domain} property.
   * @public
   */ canonicalizedDomain() {
        return canonicalDomain(this.domain);
    }
    /**
   * Alias for {@link Cookie.canonicalizedDomain}
   * @public
   */ cdomain() {
        return canonicalDomain(this.domain);
    }
    /**
   * Parses a string into a Cookie object.
   *
   * @remarks
   * Note: when parsing a `Cookie` header it must be split by ';' before each Cookie string can be parsed.
   *
   * @example
   * ```
   * // parse a `Set-Cookie` header
   * const setCookieHeader = 'a=bcd; Expires=Tue, 18 Oct 2011 07:05:03 GMT'
   * const cookie = Cookie.parse(setCookieHeader)
   * cookie.key === 'a'
   * cookie.value === 'bcd'
   * cookie.expires === new Date(Date.parse('Tue, 18 Oct 2011 07:05:03 GMT'))
   * ```
   *
   * @example
   * ```
   * // parse a `Cookie` header
   * const cookieHeader = 'name=value; name2=value2; name3=value3'
   * const cookies = cookieHeader.split(';').map(Cookie.parse)
   * cookies[0].name === 'name'
   * cookies[0].value === 'value'
   * cookies[1].name === 'name2'
   * cookies[1].value === 'value2'
   * cookies[2].name === 'name3'
   * cookies[2].value === 'value3'
   * ```
   *
   * @param str - The `Set-Cookie` header or a Cookie string to parse.
   * @param options - Configures `strict` or `loose` mode for cookie parsing
   */ static parse(str, options) {
        return parse(str, options);
    }
    /**
   * Does the reverse of {@link Cookie.toJSON}.
   *
   * @remarks
   * Any Date properties (such as .expires, .creation, and .lastAccessed) are parsed via Date.parse, not tough-cookie's parseDate, since ISO timestamps are being handled at this layer.
   *
   * @example
   * ```
   * const json = JSON.stringify({
   *   key: 'alpha',
   *   value: 'beta',
   *   domain: 'example.com',
   *   path: '/foo',
   *   expires: '2038-01-19T03:14:07.000Z',
   * })
   * const cookie = Cookie.fromJSON(json)
   * cookie.key === 'alpha'
   * cookie.value === 'beta'
   * cookie.domain === 'example.com'
   * cookie.path === '/foo'
   * cookie.expires === new Date(Date.parse('2038-01-19T03:14:07.000Z'))
   * ```
   *
   * @param str - An unparsed JSON string or a value that has already been parsed as JSON
   */ static fromJSON(str) {
        return fromJSON(str);
    }
};
_Cookie.cookiesCreated = 0;
/**
 * @internal
 */ _Cookie.sameSiteLevel = {
    strict: 3,
    lax: 2,
    none: 1
};
/**
 * @internal
 */ _Cookie.sameSiteCanonical = {
    strict: "Strict",
    lax: "Lax"
};
/**
 * Cookie properties that will be serialized when using {@link Cookie.fromJSON} and {@link Cookie.toJSON}.
 * @public
 */ _Cookie.serializableProperties = [
    "key",
    "value",
    "expires",
    "maxAge",
    "domain",
    "path",
    "secure",
    "httpOnly",
    "extensions",
    "hostOnly",
    "pathIsDefault",
    "creation",
    "lastAccessed",
    "sameSite"
];
var Cookie = _Cookie;
// lib/cookie/cookieCompare.ts
var MAX_TIME = 2147483647e3;
function cookieCompare(a, b) {
    let cmp;
    const aPathLen = a.path ? a.path.length : 0;
    const bPathLen = b.path ? b.path.length : 0;
    cmp = bPathLen - aPathLen;
    if (cmp !== 0) {
        return cmp;
    }
    const aTime = a.creation && a.creation instanceof Date ? a.creation.getTime() : MAX_TIME;
    const bTime = b.creation && b.creation instanceof Date ? b.creation.getTime() : MAX_TIME;
    cmp = aTime - bTime;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = (a.creationIndex || 0) - (b.creationIndex || 0);
    return cmp;
}
// lib/cookie/defaultPath.ts
function defaultPath(path) {
    if (!path || path.slice(0, 1) !== "/") {
        return "/";
    }
    if (path === "/") {
        return path;
    }
    const rightSlash = path.lastIndexOf("/");
    if (rightSlash === 0) {
        return "/";
    }
    return path.slice(0, rightSlash);
}
// lib/cookie/domainMatch.ts
var IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-f\d]{1,4}:){7}(?:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,2}|:)|(?:[a-f\d]{1,4}:){4}(?:(?::[a-f\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,3}|:)|(?:[a-f\d]{1,4}:){3}(?:(?::[a-f\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,4}|:)|(?:[a-f\d]{1,4}:){2}(?:(?::[a-f\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,5}|:)|(?:[a-f\d]{1,4}:){1}(?:(?::[a-f\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,7}|:)))$)/;
function domainMatch(domain, cookieDomain, canonicalize) {
    if (domain == null || cookieDomain == null) {
        return void 0;
    }
    let _str;
    let _domStr;
    if (canonicalize !== false) {
        _str = canonicalDomain(domain);
        _domStr = canonicalDomain(cookieDomain);
    } else {
        _str = domain;
        _domStr = cookieDomain;
    }
    if (_str == null || _domStr == null) {
        return void 0;
    }
    if (_str == _domStr) {
        return true;
    }
    const idx = _str.lastIndexOf(_domStr);
    if (idx <= 0) {
        return false;
    }
    if (_str.length !== _domStr.length + idx) {
        return false;
    }
    if (_str.substring(idx - 1, idx) !== ".") {
        return false;
    }
    return !IP_REGEX_LOWERCASE.test(_str);
}
// lib/cookie/secureContext.ts
function isLoopbackV4(address) {
    const octets = address.split(".");
    return octets.length === 4 && octets[0] !== void 0 && parseInt(octets[0], 10) === 127;
}
function isLoopbackV6(address) {
    return address === "::1";
}
function isNormalizedLocalhostTLD(lowerHost) {
    return lowerHost.endsWith(".localhost");
}
function isLocalHostname(host) {
    const lowerHost = host.toLowerCase();
    return lowerHost === "localhost" || isNormalizedLocalhostTLD(lowerHost);
}
function hostNoBrackets(host) {
    if (host.length >= 2 && host.startsWith("[") && host.endsWith("]")) {
        return host.substring(1, host.length - 1);
    }
    return host;
}
function isPotentiallyTrustworthy(inputUrl, allowSecureOnLocal = true) {
    let url;
    if (typeof inputUrl === "string") {
        try {
            url = new URL(inputUrl);
        } catch  {
            return false;
        }
    } else {
        url = inputUrl;
    }
    const scheme = url.protocol.replace(":", "").toLowerCase();
    const hostname = hostNoBrackets(url.hostname).replace(/\.+$/, "");
    if (scheme === "https" || scheme === "wss") {
        return true;
    }
    if (!allowSecureOnLocal) {
        return false;
    }
    if (IP_V4_REGEX_OBJECT.test(hostname)) {
        return isLoopbackV4(hostname);
    }
    if (IP_V6_REGEX_OBJECT.test(hostname)) {
        return isLoopbackV6(hostname);
    }
    return isLocalHostname(hostname);
}
// lib/cookie/cookieJar.ts
var defaultSetCookieOptions = {
    loose: false,
    sameSiteContext: void 0,
    ignoreError: false,
    http: true
};
var defaultGetCookieOptions = {
    http: true,
    expire: true,
    allPaths: false,
    sameSiteContext: void 0,
    sort: void 0
};
var SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of "strict", "lax", or "none"';
function getCookieContext(url) {
    if (url && typeof url === "object" && "hostname" in url && typeof url.hostname === "string" && "pathname" in url && typeof url.pathname === "string" && "protocol" in url && typeof url.protocol === "string") {
        return {
            hostname: url.hostname,
            pathname: url.pathname,
            protocol: url.protocol
        };
    } else if (typeof url === "string") {
        try {
            return new URL(decodeURI(url));
        } catch  {
            return new URL(url);
        }
    } else {
        throw new ParameterError("`url` argument is not a string or URL.");
    }
}
function checkSameSiteContext(value) {
    const context = String(value).toLowerCase();
    if (context === "none" || context === "lax" || context === "strict") {
        return context;
    } else {
        return void 0;
    }
}
function isSecurePrefixConditionMet(cookie) {
    const startsWithSecurePrefix = typeof cookie.key === "string" && cookie.key.startsWith("__Secure-");
    return !startsWithSecurePrefix || cookie.secure;
}
function isHostPrefixConditionMet(cookie) {
    const startsWithHostPrefix = typeof cookie.key === "string" && cookie.key.startsWith("__Host-");
    return !startsWithHostPrefix || Boolean(cookie.secure && cookie.hostOnly && cookie.path != null && cookie.path === "/");
}
function getNormalizedPrefixSecurity(prefixSecurity) {
    const normalizedPrefixSecurity = prefixSecurity.toLowerCase();
    switch(normalizedPrefixSecurity){
        case PrefixSecurityEnum.STRICT:
        case PrefixSecurityEnum.SILENT:
        case PrefixSecurityEnum.DISABLED:
            return normalizedPrefixSecurity;
        default:
            return PrefixSecurityEnum.SILENT;
    }
}
var CookieJar = class _CookieJar {
    /**
   * Creates a new `CookieJar` instance.
   *
   * @remarks
   * - If a custom store is not passed to the constructor, an in-memory store ({@link MemoryCookieStore} will be created and used.
   * - If a boolean value is passed as the `options` parameter, this is equivalent to passing `{ rejectPublicSuffixes: <value> }`
   *
   * @param store - a custom {@link Store} implementation (defaults to {@link MemoryCookieStore})
   * @param options - configures how cookies are processed by the cookie jar
   */ constructor(store, options){
        if (typeof options === "boolean") {
            options = {
                rejectPublicSuffixes: options
            };
        }
        this.rejectPublicSuffixes = options?.rejectPublicSuffixes ?? true;
        this.enableLooseMode = options?.looseMode ?? false;
        this.allowSpecialUseDomain = options?.allowSpecialUseDomain ?? true;
        this.allowSecureOnLocal = options?.allowSecureOnLocal ?? true;
        this.prefixSecurity = getNormalizedPrefixSecurity(options?.prefixSecurity ?? "silent");
        this.store = store ?? new MemoryCookieStore();
    }
    callSync(fn) {
        if (!this.store.synchronous) {
            throw new Error("CookieJar store is not synchronous; use async API instead.");
        }
        let syncErr = null;
        let syncResult = void 0;
        try {
            fn.call(this, (error, result)=>{
                syncErr = error;
                syncResult = result;
            });
        } catch (err) {
            syncErr = err;
        }
        if (syncErr) throw syncErr;
        return syncResult;
    }
    /**
   * @internal No doc because this is the overload implementation
   */ setCookie(cookie, url, options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = void 0;
        }
        const promiseCallback = createPromiseCallback(callback);
        const cb = promiseCallback.callback;
        let context;
        try {
            if (typeof url === "string") {
                validate(isNonEmptyString(url), callback, safeToString(options));
            }
            context = getCookieContext(url);
            if (typeof url === "function") {
                return promiseCallback.reject(new Error("No URL was specified"));
            }
            if (typeof options === "function") {
                options = defaultSetCookieOptions;
            }
            validate(typeof cb === "function", cb);
            if (!isNonEmptyString(cookie) && !isObject(cookie) && cookie instanceof String && cookie.length == 0) {
                return promiseCallback.resolve(void 0);
            }
        } catch (err) {
            return promiseCallback.reject(err);
        }
        const host = canonicalDomain(context.hostname) ?? null;
        const loose = options?.loose || this.enableLooseMode;
        let sameSiteContext = null;
        if (options?.sameSiteContext) {
            sameSiteContext = checkSameSiteContext(options.sameSiteContext);
            if (!sameSiteContext) {
                return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));
            }
        }
        if (typeof cookie === "string" || cookie instanceof String) {
            const parsedCookie = Cookie.parse(cookie.toString(), {
                loose
            });
            if (!parsedCookie) {
                const err = new Error("Cookie failed to parse");
                return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
            }
            cookie = parsedCookie;
        } else if (!(cookie instanceof Cookie)) {
            const err = new Error("First argument to setCookie must be a Cookie object or string");
            return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
        }
        const now = options?.now || /* @__PURE__ */ new Date();
        if (this.rejectPublicSuffixes && cookie.domain) {
            try {
                const cdomain = cookie.cdomain();
                const suffix = typeof cdomain === "string" ? getPublicSuffix(cdomain, {
                    allowSpecialUseDomain: this.allowSpecialUseDomain,
                    ignoreError: options?.ignoreError
                }) : null;
                if (suffix == null && !IP_V6_REGEX_OBJECT.test(cookie.domain)) {
                    const err = new Error("Cookie has domain set to a public suffix");
                    return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
                }
            } catch (err) {
                return options?.ignoreError ? promiseCallback.resolve(void 0) : // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                promiseCallback.reject(err);
            }
        }
        if (cookie.domain) {
            if (!domainMatch(host ?? void 0, cookie.cdomain() ?? void 0, false)) {
                const err = new Error(`Cookie not in this host's domain. Cookie:${cookie.cdomain() ?? "null"} Request:${host ?? "null"}`);
                return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
            }
            if (cookie.hostOnly == null) {
                cookie.hostOnly = false;
            }
        } else {
            cookie.hostOnly = true;
            cookie.domain = host;
        }
        if (!cookie.path || cookie.path[0] !== "/") {
            cookie.path = defaultPath(context.pathname);
            cookie.pathIsDefault = true;
        }
        if (options?.http === false && cookie.httpOnly) {
            const err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
            return options.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
        }
        if (cookie.sameSite !== "none" && cookie.sameSite !== void 0 && sameSiteContext) {
            if (sameSiteContext === "none") {
                const err = new Error("Cookie is SameSite but this is a cross-origin request");
                return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
            }
        }
        const ignoreErrorForPrefixSecurity = this.prefixSecurity === PrefixSecurityEnum.SILENT;
        const prefixSecurityDisabled = this.prefixSecurity === PrefixSecurityEnum.DISABLED;
        if (!prefixSecurityDisabled) {
            let errorFound = false;
            let errorMsg;
            if (!isSecurePrefixConditionMet(cookie)) {
                errorFound = true;
                errorMsg = "Cookie has __Secure prefix but Secure attribute is not set";
            } else if (!isHostPrefixConditionMet(cookie)) {
                errorFound = true;
                errorMsg = "Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'";
            }
            if (errorFound) {
                return options?.ignoreError || ignoreErrorForPrefixSecurity ? promiseCallback.resolve(void 0) : promiseCallback.reject(new Error(errorMsg));
            }
        }
        const store = this.store;
        if (!store.updateCookie) {
            store.updateCookie = async function(_oldCookie, newCookie, cb2) {
                return this.putCookie(newCookie).then(()=>cb2?.(null), (error)=>cb2?.(error));
            };
        }
        const withCookie = function withCookie2(err, oldCookie) {
            if (err) {
                cb(err);
                return;
            }
            const next = function(err2) {
                if (err2) {
                    cb(err2);
                } else if (typeof cookie === "string") {
                    cb(null, void 0);
                } else {
                    cb(null, cookie);
                }
            };
            if (oldCookie) {
                if (options && "http" in options && options.http === false && oldCookie.httpOnly) {
                    err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
                    if (options.ignoreError) cb(null, void 0);
                    else cb(err);
                    return;
                }
                if (cookie instanceof Cookie) {
                    cookie.creation = oldCookie.creation;
                    cookie.creationIndex = oldCookie.creationIndex;
                    cookie.lastAccessed = now;
                    store.updateCookie(oldCookie, cookie, next);
                }
            } else {
                if (cookie instanceof Cookie) {
                    cookie.creation = cookie.lastAccessed = now;
                    store.putCookie(cookie, next);
                }
            }
        };
        store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
        return promiseCallback.promise;
    }
    /**
   * Synchronously attempt to set the {@link Cookie} in the {@link CookieJar}.
   *
   * <strong>Note:</strong> Only works if the configured {@link Store} is also synchronous.
   *
   * @remarks
   * - If successfully persisted, the {@link Cookie} will have updated
   *     {@link Cookie.creation}, {@link Cookie.lastAccessed} and {@link Cookie.hostOnly}
   *     properties.
   *
   * - As per the RFC, the {@link Cookie.hostOnly} flag is set if there was no `Domain={value}`
   *     attribute on the cookie string. The {@link Cookie.domain} property is set to the
   *     fully-qualified hostname of `currentUrl` in this case. Matching this cookie requires an
   *     exact hostname match (not a {@link domainMatch} as per usual)
   *
   * @param cookie - The cookie object or cookie string to store. A string value will be parsed into a cookie using {@link Cookie.parse}.
   * @param url - The domain to store the cookie with.
   * @param options - Configuration settings to use when storing the cookie.
   * @public
   */ setCookieSync(cookie, url, options) {
        const setCookieFn = options ? this.setCookie.bind(this, cookie, url, options) : this.setCookie.bind(this, cookie, url);
        return this.callSync(setCookieFn);
    }
    /**
   * @internal No doc because this is the overload implementation
   */ getCookies(url, options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = defaultGetCookieOptions;
        } else if (options === void 0) {
            options = defaultGetCookieOptions;
        }
        const promiseCallback = createPromiseCallback(callback);
        const cb = promiseCallback.callback;
        let context;
        try {
            if (typeof url === "string") {
                validate(isNonEmptyString(url), cb, url);
            }
            context = getCookieContext(url);
            validate(isObject(options), cb, safeToString(options));
            validate(typeof cb === "function", cb);
        } catch (parameterError) {
            return promiseCallback.reject(parameterError);
        }
        const host = canonicalDomain(context.hostname);
        const path = context.pathname || "/";
        const potentiallyTrustworthy = isPotentiallyTrustworthy(url, this.allowSecureOnLocal);
        let sameSiteLevel = 0;
        if (options.sameSiteContext) {
            const sameSiteContext = checkSameSiteContext(options.sameSiteContext);
            if (sameSiteContext == null) {
                return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));
            }
            sameSiteLevel = Cookie.sameSiteLevel[sameSiteContext];
            if (!sameSiteLevel) {
                return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));
            }
        }
        const http = options.http ?? true;
        const now = Date.now();
        const expireCheck = options.expire ?? true;
        const allPaths = options.allPaths ?? false;
        const store = this.store;
        function matchingCookie(c) {
            if (c.hostOnly) {
                if (c.domain != host) {
                    return false;
                }
            } else {
                if (!domainMatch(host ?? void 0, c.domain ?? void 0, false)) {
                    return false;
                }
            }
            if (!allPaths && typeof c.path === "string" && !pathMatch(path, c.path)) {
                return false;
            }
            if (c.secure && !potentiallyTrustworthy) {
                return false;
            }
            if (c.httpOnly && !http) {
                return false;
            }
            if (sameSiteLevel) {
                let cookieLevel;
                if (c.sameSite === "lax") {
                    cookieLevel = Cookie.sameSiteLevel.lax;
                } else if (c.sameSite === "strict") {
                    cookieLevel = Cookie.sameSiteLevel.strict;
                } else {
                    cookieLevel = Cookie.sameSiteLevel.none;
                }
                if (cookieLevel > sameSiteLevel) {
                    return false;
                }
            }
            const expiryTime = c.expiryTime();
            if (expireCheck && expiryTime != void 0 && expiryTime <= now) {
                store.removeCookie(c.domain, c.path, c.key, ()=>{});
                return false;
            }
            return true;
        }
        store.findCookies(host, allPaths ? null : path, this.allowSpecialUseDomain, (err, cookies)=>{
            if (err) {
                cb(err);
                return;
            }
            if (cookies == null) {
                cb(null, []);
                return;
            }
            cookies = cookies.filter(matchingCookie);
            if ("sort" in options && options.sort !== false) {
                cookies = cookies.sort(cookieCompare);
            }
            const now2 = /* @__PURE__ */ new Date();
            for (const cookie of cookies){
                cookie.lastAccessed = now2;
            }
            cb(null, cookies);
        });
        return promiseCallback.promise;
    }
    /**
   * Synchronously retrieve the list of cookies that can be sent in a Cookie header for the
   * current URL.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   *
   * @remarks
   * - The array of cookies returned will be sorted according to {@link cookieCompare}.
   *
   * - The {@link Cookie.lastAccessed} property will be updated on all returned cookies.
   *
   * @param url - The domain to store the cookie with.
   * @param options - Configuration settings to use when retrieving the cookies.
   */ getCookiesSync(url, options) {
        return this.callSync(this.getCookies.bind(this, url, options)) ?? [];
    }
    /**
   * @internal No doc because this is the overload implementation
   */ getCookieString(url, options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = void 0;
        }
        const promiseCallback = createPromiseCallback(callback);
        const next = function(err, cookies) {
            if (err) {
                promiseCallback.callback(err);
            } else {
                promiseCallback.callback(null, cookies?.sort(cookieCompare).map((c)=>c.cookieString()).join("; "));
            }
        };
        this.getCookies(url, options, next);
        return promiseCallback.promise;
    }
    /**
   * Synchronous version of `.getCookieString()`. Accepts the same options as `.getCookies()` but returns a string suitable for a
   * `Cookie` header rather than an Array.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   *
   * @param url - The domain to store the cookie with.
   * @param options - Configuration settings to use when retrieving the cookies.
   */ getCookieStringSync(url, options) {
        return this.callSync(options ? this.getCookieString.bind(this, url, options) : this.getCookieString.bind(this, url)) ?? "";
    }
    /**
   * @internal No doc because this is the overload implementation
   */ getSetCookieStrings(url, options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = void 0;
        }
        const promiseCallback = createPromiseCallback(callback);
        const next = function(err, cookies) {
            if (err) {
                promiseCallback.callback(err);
            } else {
                promiseCallback.callback(null, cookies?.map((c)=>{
                    return c.toString();
                }));
            }
        };
        this.getCookies(url, options, next);
        return promiseCallback.promise;
    }
    /**
   * Synchronous version of `.getSetCookieStrings()`. Returns an array of strings suitable for `Set-Cookie` headers.
   * Accepts the same options as `.getCookies()`.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   *
   * @param url - The domain to store the cookie with.
   * @param options - Configuration settings to use when retrieving the cookies.
   */ getSetCookieStringsSync(url, options = {}) {
        return this.callSync(this.getSetCookieStrings.bind(this, url, options)) ?? [];
    }
    /**
   * @internal No doc because this is the overload implementation
   */ serialize(callback) {
        const promiseCallback = createPromiseCallback(callback);
        let type = this.store.constructor.name;
        if (isObject(type)) {
            type = null;
        }
        const serialized = {
            // The version of tough-cookie that serialized this jar. Generally a good
            // practice since future versions can make data import decisions based on
            // known past behavior. When/if this matters, use `semver`.
            version: `tough-cookie@${version}`,
            // add the store type, to make humans happy:
            storeType: type,
            // CookieJar configuration:
            rejectPublicSuffixes: this.rejectPublicSuffixes,
            enableLooseMode: this.enableLooseMode,
            allowSpecialUseDomain: this.allowSpecialUseDomain,
            prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),
            // this gets filled from getAllCookies:
            cookies: []
        };
        if (typeof this.store.getAllCookies !== "function") {
            return promiseCallback.reject(new Error("store does not support getAllCookies and cannot be serialized"));
        }
        this.store.getAllCookies((err, cookies)=>{
            if (err) {
                promiseCallback.callback(err);
                return;
            }
            if (cookies == null) {
                promiseCallback.callback(null, serialized);
                return;
            }
            serialized.cookies = cookies.map((cookie)=>{
                const serializedCookie = cookie.toJSON();
                delete serializedCookie.creationIndex;
                return serializedCookie;
            });
            promiseCallback.callback(null, serialized);
        });
        return promiseCallback.promise;
    }
    /**
   * Serialize the CookieJar if the underlying store supports `.getAllCookies`.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   */ serializeSync() {
        return this.callSync((callback)=>{
            this.serialize(callback);
        });
    }
    /**
   * Alias of {@link CookieJar.serializeSync}. Allows the cookie to be serialized
   * with `JSON.stringify(cookieJar)`.
   */ toJSON() {
        return this.serializeSync();
    }
    /**
   * Use the class method CookieJar.deserialize instead of calling this directly
   * @internal
   */ _importCookies(serialized, callback) {
        let cookies = void 0;
        if (serialized && typeof serialized === "object" && inOperator("cookies", serialized) && Array.isArray(serialized.cookies)) {
            cookies = serialized.cookies;
        }
        if (!cookies) {
            callback(new Error("serialized jar has no cookies array"), void 0);
            return;
        }
        cookies = cookies.slice();
        const putNext = (err)=>{
            if (err) {
                callback(err, void 0);
                return;
            }
            if (Array.isArray(cookies)) {
                if (!cookies.length) {
                    callback(err, this);
                    return;
                }
                let cookie;
                try {
                    cookie = Cookie.fromJSON(cookies.shift());
                } catch (e) {
                    callback(e instanceof Error ? e : new Error(), void 0);
                    return;
                }
                if (cookie === void 0) {
                    putNext(null);
                    return;
                }
                this.store.putCookie(cookie, putNext);
            }
        };
        putNext(null);
    }
    /**
   * @internal
   */ _importCookiesSync(serialized) {
        this.callSync(this._importCookies.bind(this, serialized));
    }
    /**
   * @internal No doc because this is the overload implementation
   */ clone(newStore, callback) {
        if (typeof newStore === "function") {
            callback = newStore;
            newStore = void 0;
        }
        const promiseCallback = createPromiseCallback(callback);
        const cb = promiseCallback.callback;
        this.serialize((err, serialized)=>{
            if (err) {
                return promiseCallback.reject(err);
            }
            return _CookieJar.deserialize(serialized ?? "", newStore, cb);
        });
        return promiseCallback.promise;
    }
    /**
   * @internal
   */ _cloneSync(newStore) {
        const cloneFn = newStore && typeof newStore !== "function" ? this.clone.bind(this, newStore) : this.clone.bind(this);
        return this.callSync((callback)=>{
            cloneFn(callback);
        });
    }
    /**
   * Produces a deep clone of this CookieJar. Modifications to the original do
   * not affect the clone, and vice versa.
   *
   * <strong>Note</strong>: Only works if both the configured Store and destination
   * Store are synchronous.
   *
   * @remarks
   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.
   *
   * - Transferring between store types is supported so long as the source
   *     implements `.getAllCookies()` and the destination implements `.putCookie()`.
   *
   * @param newStore - The target {@link Store} to clone cookies into.
   */ cloneSync(newStore) {
        if (!newStore) {
            return this._cloneSync();
        }
        if (!newStore.synchronous) {
            throw new Error("CookieJar clone destination store is not synchronous; use async API instead.");
        }
        return this._cloneSync(newStore);
    }
    /**
   * @internal No doc because this is the overload implementation
   */ removeAllCookies(callback) {
        const promiseCallback = createPromiseCallback(callback);
        const cb = promiseCallback.callback;
        const store = this.store;
        if (typeof store.removeAllCookies === "function" && store.removeAllCookies !== Store.prototype.removeAllCookies) {
            store.removeAllCookies(cb);
            return promiseCallback.promise;
        }
        store.getAllCookies((err, cookies)=>{
            if (err) {
                cb(err);
                return;
            }
            if (!cookies) {
                cookies = [];
            }
            if (cookies.length === 0) {
                cb(null, void 0);
                return;
            }
            let completedCount = 0;
            const removeErrors = [];
            const removeCookieCb = function removeCookieCb2(removeErr) {
                if (removeErr) {
                    removeErrors.push(removeErr);
                }
                completedCount++;
                if (completedCount === cookies.length) {
                    if (removeErrors[0]) cb(removeErrors[0]);
                    else cb(null, void 0);
                    return;
                }
            };
            cookies.forEach((cookie)=>{
                store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);
            });
        });
        return promiseCallback.promise;
    }
    /**
   * Removes all cookies from the CookieJar.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   *
   * @remarks
   * - This is a new backwards-compatible feature of tough-cookie version 2.5,
   *     so not all Stores will implement it efficiently. For Stores that do not
   *     implement `removeAllCookies`, the fallback is to call `removeCookie` after
   *     `getAllCookies`.
   *
   * - If `getAllCookies` fails or isn't implemented in the Store, an error is returned.
   *
   * - If one or more of the `removeCookie` calls fail, only the first error is returned.
   */ removeAllCookiesSync() {
        this.callSync((callback)=>{
            this.removeAllCookies(callback);
        });
    }
    /**
   * @internal No doc because this is the overload implementation
   */ static deserialize(strOrObj, store, callback) {
        if (typeof store === "function") {
            callback = store;
            store = void 0;
        }
        const promiseCallback = createPromiseCallback(callback);
        let serialized;
        if (typeof strOrObj === "string") {
            try {
                serialized = JSON.parse(strOrObj);
            } catch (e) {
                return promiseCallback.reject(e instanceof Error ? e : new Error());
            }
        } else {
            serialized = strOrObj;
        }
        const readSerializedProperty = (property)=>{
            return serialized && typeof serialized === "object" && inOperator(property, serialized) ? serialized[property] : void 0;
        };
        const readSerializedBoolean = (property)=>{
            const value = readSerializedProperty(property);
            return typeof value === "boolean" ? value : void 0;
        };
        const readSerializedString = (property)=>{
            const value = readSerializedProperty(property);
            return typeof value === "string" ? value : void 0;
        };
        const jar = new _CookieJar(store, {
            rejectPublicSuffixes: readSerializedBoolean("rejectPublicSuffixes"),
            looseMode: readSerializedBoolean("enableLooseMode"),
            allowSpecialUseDomain: readSerializedBoolean("allowSpecialUseDomain"),
            prefixSecurity: getNormalizedPrefixSecurity(readSerializedString("prefixSecurity") ?? "silent")
        });
        jar._importCookies(serialized, (err)=>{
            if (err) {
                promiseCallback.callback(err);
                return;
            }
            promiseCallback.callback(null, jar);
        });
        return promiseCallback.promise;
    }
    /**
   * A new CookieJar is created and the serialized {@link Cookie} values are added to
   * the underlying store. Each {@link Cookie} is added via `store.putCookie(...)` in
   * the order in which they appear in the serialization.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   *
   * @remarks
   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.
   *
   * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.
   *
   * @param strOrObj - A JSON string or object representing the deserialized cookies.
   * @param store - The underlying store to persist the deserialized cookies into.
   */ static deserializeSync(strOrObj, store) {
        const serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
        const readSerializedProperty = (property)=>{
            return serialized && typeof serialized === "object" && inOperator(property, serialized) ? serialized[property] : void 0;
        };
        const readSerializedBoolean = (property)=>{
            const value = readSerializedProperty(property);
            return typeof value === "boolean" ? value : void 0;
        };
        const readSerializedString = (property)=>{
            const value = readSerializedProperty(property);
            return typeof value === "string" ? value : void 0;
        };
        const jar = new _CookieJar(store, {
            rejectPublicSuffixes: readSerializedBoolean("rejectPublicSuffixes"),
            looseMode: readSerializedBoolean("enableLooseMode"),
            allowSpecialUseDomain: readSerializedBoolean("allowSpecialUseDomain"),
            prefixSecurity: getNormalizedPrefixSecurity(readSerializedString("prefixSecurity") ?? "silent")
        });
        if (!jar.store.synchronous) {
            throw new Error("CookieJar store is not synchronous; use async API instead.");
        }
        jar._importCookiesSync(serialized);
        return jar;
    }
    /**
   * Alias of {@link CookieJar.deserializeSync}.
   *
   * @remarks
   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.
   *
   * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.
   *
   * @param jsonString - A JSON string or object representing the deserialized cookies.
   * @param store - The underlying store to persist the deserialized cookies into.
   */ static fromJSON(jsonString, store) {
        return _CookieJar.deserializeSync(jsonString, store);
    }
};
// lib/cookie/permutePath.ts
function permutePath(path) {
    if (path === "/") {
        return [
            "/"
        ];
    }
    const permutations = [
        path
    ];
    while(path.length > 1){
        const lindex = path.lastIndexOf("/");
        if (lindex === 0) {
            break;
        }
        path = path.slice(0, lindex);
        permutations.push(path);
    }
    permutations.push("/");
    return permutations;
}
// lib/cookie/index.ts
function parse2(str, options) {
    return Cookie.parse(str, options);
}
function fromJSON2(str) {
    return Cookie.fromJSON(str);
}
;
 /*!
 * Copyright (c) 2015-2020, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */  //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@bundled-es-modules/statuses/index-esm.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>source_default
]);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod)=>function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
// node_modules/statuses/codes.json
var require_codes = __commonJS({
    "node_modules/statuses/codes.json" (exports, module) {
        module.exports = {
            "100": "Continue",
            "101": "Switching Protocols",
            "102": "Processing",
            "103": "Early Hints",
            "200": "OK",
            "201": "Created",
            "202": "Accepted",
            "203": "Non-Authoritative Information",
            "204": "No Content",
            "205": "Reset Content",
            "206": "Partial Content",
            "207": "Multi-Status",
            "208": "Already Reported",
            "226": "IM Used",
            "300": "Multiple Choices",
            "301": "Moved Permanently",
            "302": "Found",
            "303": "See Other",
            "304": "Not Modified",
            "305": "Use Proxy",
            "307": "Temporary Redirect",
            "308": "Permanent Redirect",
            "400": "Bad Request",
            "401": "Unauthorized",
            "402": "Payment Required",
            "403": "Forbidden",
            "404": "Not Found",
            "405": "Method Not Allowed",
            "406": "Not Acceptable",
            "407": "Proxy Authentication Required",
            "408": "Request Timeout",
            "409": "Conflict",
            "410": "Gone",
            "411": "Length Required",
            "412": "Precondition Failed",
            "413": "Payload Too Large",
            "414": "URI Too Long",
            "415": "Unsupported Media Type",
            "416": "Range Not Satisfiable",
            "417": "Expectation Failed",
            "418": "I'm a Teapot",
            "421": "Misdirected Request",
            "422": "Unprocessable Entity",
            "423": "Locked",
            "424": "Failed Dependency",
            "425": "Too Early",
            "426": "Upgrade Required",
            "428": "Precondition Required",
            "429": "Too Many Requests",
            "431": "Request Header Fields Too Large",
            "451": "Unavailable For Legal Reasons",
            "500": "Internal Server Error",
            "501": "Not Implemented",
            "502": "Bad Gateway",
            "503": "Service Unavailable",
            "504": "Gateway Timeout",
            "505": "HTTP Version Not Supported",
            "506": "Variant Also Negotiates",
            "507": "Insufficient Storage",
            "508": "Loop Detected",
            "509": "Bandwidth Limit Exceeded",
            "510": "Not Extended",
            "511": "Network Authentication Required"
        };
    }
});
// node_modules/statuses/index.js
var require_statuses = __commonJS({
    "node_modules/statuses/index.js" (exports, module) {
        "use strict";
        var codes = require_codes();
        module.exports = status2;
        status2.message = codes;
        status2.code = createMessageToStatusCodeMap(codes);
        status2.codes = createStatusCodeList(codes);
        status2.redirect = {
            300: true,
            301: true,
            302: true,
            303: true,
            305: true,
            307: true,
            308: true
        };
        status2.empty = {
            204: true,
            205: true,
            304: true
        };
        status2.retry = {
            502: true,
            503: true,
            504: true
        };
        function createMessageToStatusCodeMap(codes2) {
            var map = {};
            Object.keys(codes2).forEach(function forEachCode(code) {
                var message = codes2[code];
                var status3 = Number(code);
                map[message.toLowerCase()] = status3;
            });
            return map;
        }
        function createStatusCodeList(codes2) {
            return Object.keys(codes2).map(function mapCode(code) {
                return Number(code);
            });
        }
        function getStatusCode(message) {
            var msg = message.toLowerCase();
            if (!Object.prototype.hasOwnProperty.call(status2.code, msg)) {
                throw new Error('invalid status message: "' + message + '"');
            }
            return status2.code[msg];
        }
        function getStatusMessage(code) {
            if (!Object.prototype.hasOwnProperty.call(status2.message, code)) {
                throw new Error("invalid status code: " + code);
            }
            return status2.message[code];
        }
        function status2(code) {
            if (typeof code === "number") {
                return getStatusMessage(code);
            }
            if (typeof code !== "string") {
                throw new TypeError("code must be a number or string");
            }
            var n = parseInt(code, 10);
            if (!isNaN(n)) {
                return getStatusMessage(n);
            }
            return getStatusCode(code);
        }
    }
});
// source.js
var import_statuses = __toESM(require_statuses(), 1);
var source_default = import_statuses.default;
;
 /*! Bundled license information:

statuses/index.js:
  (*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/ }),
"[project]/node_modules/headers-polyfill/lib/index.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Headers",
    ()=>Headers,
    "flattenHeadersList",
    ()=>flattenHeadersList,
    "flattenHeadersObject",
    ()=>flattenHeadersObject,
    "getRawHeaders",
    ()=>getRawHeaders,
    "headersToList",
    ()=>headersToList,
    "headersToObject",
    ()=>headersToObject,
    "headersToString",
    ()=>headersToString,
    "listToHeaders",
    ()=>listToHeaders,
    "objectToHeaders",
    ()=>objectToHeaders,
    "reduceHeadersObject",
    ()=>reduceHeadersObject,
    "stringToHeaders",
    ()=>stringToHeaders
]);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod)=>function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
    "node_modules/set-cookie-parser/lib/set-cookie.js" (exports, module) {
        "use strict";
        var defaultParseOptions = {
            decodeValues: true,
            map: false,
            silent: false
        };
        function isNonEmptyString(str) {
            return typeof str === "string" && !!str.trim();
        }
        function parseString(setCookieValue, options) {
            var parts = setCookieValue.split(";").filter(isNonEmptyString);
            var nameValuePairStr = parts.shift();
            var parsed = parseNameValuePair(nameValuePairStr);
            var name = parsed.name;
            var value = parsed.value;
            options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
            try {
                value = options.decodeValues ? decodeURIComponent(value) : value;
            } catch (e) {
                console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
            }
            var cookie = {
                name,
                value
            };
            parts.forEach(function(part) {
                var sides = part.split("=");
                var key = sides.shift().trimLeft().toLowerCase();
                var value2 = sides.join("=");
                if (key === "expires") {
                    cookie.expires = new Date(value2);
                } else if (key === "max-age") {
                    cookie.maxAge = parseInt(value2, 10);
                } else if (key === "secure") {
                    cookie.secure = true;
                } else if (key === "httponly") {
                    cookie.httpOnly = true;
                } else if (key === "samesite") {
                    cookie.sameSite = value2;
                } else {
                    cookie[key] = value2;
                }
            });
            return cookie;
        }
        function parseNameValuePair(nameValuePairStr) {
            var name = "";
            var value = "";
            var nameValueArr = nameValuePairStr.split("=");
            if (nameValueArr.length > 1) {
                name = nameValueArr.shift();
                value = nameValueArr.join("=");
            } else {
                value = nameValuePairStr;
            }
            return {
                name,
                value
            };
        }
        function parse(input, options) {
            options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
            if (!input) {
                if (!options.map) {
                    return [];
                } else {
                    return {};
                }
            }
            if (input.headers) {
                if (typeof input.headers.getSetCookie === "function") {
                    input = input.headers.getSetCookie();
                } else if (input.headers["set-cookie"]) {
                    input = input.headers["set-cookie"];
                } else {
                    var sch = input.headers[Object.keys(input.headers).find(function(key) {
                        return key.toLowerCase() === "set-cookie";
                    })];
                    if (!sch && input.headers.cookie && !options.silent) {
                        console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
                    }
                    input = sch;
                }
            }
            if (!Array.isArray(input)) {
                input = [
                    input
                ];
            }
            options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
            if (!options.map) {
                return input.filter(isNonEmptyString).map(function(str) {
                    return parseString(str, options);
                });
            } else {
                var cookies = {};
                return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
                    var cookie = parseString(str, options);
                    cookies2[cookie.name] = cookie;
                    return cookies2;
                }, cookies);
            }
        }
        function splitCookiesString2(cookiesString) {
            if (Array.isArray(cookiesString)) {
                return cookiesString;
            }
            if (typeof cookiesString !== "string") {
                return [];
            }
            var cookiesStrings = [];
            var pos = 0;
            var start;
            var ch;
            var lastComma;
            var nextStart;
            var cookiesSeparatorFound;
            function skipWhitespace() {
                while(pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))){
                    pos += 1;
                }
                return pos < cookiesString.length;
            }
            function notSpecialChar() {
                ch = cookiesString.charAt(pos);
                return ch !== "=" && ch !== ";" && ch !== ",";
            }
            while(pos < cookiesString.length){
                start = pos;
                cookiesSeparatorFound = false;
                while(skipWhitespace()){
                    ch = cookiesString.charAt(pos);
                    if (ch === ",") {
                        lastComma = pos;
                        pos += 1;
                        skipWhitespace();
                        nextStart = pos;
                        while(pos < cookiesString.length && notSpecialChar()){
                            pos += 1;
                        }
                        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
                            cookiesSeparatorFound = true;
                            pos = nextStart;
                            cookiesStrings.push(cookiesString.substring(start, lastComma));
                            start = pos;
                        } else {
                            pos = lastComma + 1;
                        }
                    } else {
                        pos += 1;
                    }
                }
                if (!cookiesSeparatorFound || pos >= cookiesString.length) {
                    cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
                }
            }
            return cookiesStrings;
        }
        module.exports = parse;
        module.exports.parse = parse;
        module.exports.parseString = parseString;
        module.exports.splitCookiesString = splitCookiesString2;
    }
});
// src/Headers.ts
var import_set_cookie_parser = __toESM(require_set_cookie());
// src/utils/normalizeHeaderName.ts
var HEADERS_INVALID_CHARACTERS = /[^a-z0-9\-#$%&'*+.^_`|~]/i;
function normalizeHeaderName(name) {
    if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === "") {
        throw new TypeError("Invalid character in header field name");
    }
    return name.trim().toLowerCase();
}
// src/utils/normalizeHeaderValue.ts
var charCodesToRemove = [
    String.fromCharCode(10),
    String.fromCharCode(13),
    String.fromCharCode(9),
    String.fromCharCode(32)
];
var HEADER_VALUE_REMOVE_REGEXP = new RegExp(`(^[${charCodesToRemove.join("")}]|$[${charCodesToRemove.join("")}])`, "g");
function normalizeHeaderValue(value) {
    const nextValue = value.replace(HEADER_VALUE_REMOVE_REGEXP, "");
    return nextValue;
}
// src/utils/isValidHeaderName.ts
function isValidHeaderName(value) {
    if (typeof value !== "string") {
        return false;
    }
    if (value.length === 0) {
        return false;
    }
    for(let i = 0; i < value.length; i++){
        const character = value.charCodeAt(i);
        if (character > 127 || !isToken(character)) {
            return false;
        }
    }
    return true;
}
function isToken(value) {
    return ![
        127,
        32,
        "(",
        ")",
        "<",
        ">",
        "@",
        ",",
        ";",
        ":",
        "\\",
        '"',
        "/",
        "[",
        "]",
        "?",
        "=",
        "{",
        "}"
    ].includes(value);
}
// src/utils/isValidHeaderValue.ts
function isValidHeaderValue(value) {
    if (typeof value !== "string") {
        return false;
    }
    if (value.trim() !== value) {
        return false;
    }
    for(let i = 0; i < value.length; i++){
        const character = value.charCodeAt(i);
        if (// NUL.
        character === 0 || // HTTP newline bytes.
        character === 10 || character === 13) {
            return false;
        }
    }
    return true;
}
// src/Headers.ts
var NORMALIZED_HEADERS = Symbol("normalizedHeaders");
var RAW_HEADER_NAMES = Symbol("rawHeaderNames");
var HEADER_VALUE_DELIMITER = ", ";
var _a, _b, _c;
var Headers = class _Headers {
    constructor(init){
        // Normalized header {"name":"a, b"} storage.
        this[_a] = {};
        // Keeps the mapping between the raw header name
        // and the normalized header name to ease the lookup.
        this[_b] = /* @__PURE__ */ new Map();
        this[_c] = "Headers";
        if ([
            "Headers",
            "HeadersPolyfill"
        ].includes(init?.constructor.name) || init instanceof _Headers || typeof globalThis.Headers !== "undefined" && init instanceof globalThis.Headers) {
            const initialHeaders = init;
            initialHeaders.forEach((value, name)=>{
                this.append(name, value);
            }, this);
        } else if (Array.isArray(init)) {
            init.forEach(([name, value])=>{
                this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);
            });
        } else if (init) {
            Object.getOwnPropertyNames(init).forEach((name)=>{
                const value = init[name];
                this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);
            });
        }
    }
    [(_a = NORMALIZED_HEADERS, _b = RAW_HEADER_NAMES, _c = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
    }
    *keys() {
        for (const [name] of this.entries()){
            yield name;
        }
    }
    *values() {
        for (const [, value] of this.entries()){
            yield value;
        }
    }
    *entries() {
        let sortedKeys = Object.keys(this[NORMALIZED_HEADERS]).sort((a, b)=>a.localeCompare(b));
        for (const name of sortedKeys){
            if (name === "set-cookie") {
                for (const value of this.getSetCookie()){
                    yield [
                        name,
                        value
                    ];
                }
            } else {
                yield [
                    name,
                    this.get(name)
                ];
            }
        }
    }
    /**
   * Returns a boolean stating whether a `Headers` object contains a certain header.
   */ has(name) {
        if (!isValidHeaderName(name)) {
            throw new TypeError(`Invalid header name "${name}"`);
        }
        return this[NORMALIZED_HEADERS].hasOwnProperty(normalizeHeaderName(name));
    }
    /**
   * Returns a `ByteString` sequence of all the values of a header with a given name.
   */ get(name) {
        if (!isValidHeaderName(name)) {
            throw TypeError(`Invalid header name "${name}"`);
        }
        return this[NORMALIZED_HEADERS][normalizeHeaderName(name)] ?? null;
    }
    /**
   * Sets a new value for an existing header inside a `Headers` object, or adds the header if it does not already exist.
   */ set(name, value) {
        if (!isValidHeaderName(name) || !isValidHeaderValue(value)) {
            return;
        }
        const normalizedName = normalizeHeaderName(name);
        const normalizedValue = normalizeHeaderValue(value);
        this[NORMALIZED_HEADERS][normalizedName] = normalizeHeaderValue(normalizedValue);
        this[RAW_HEADER_NAMES].set(normalizedName, name);
    }
    /**
   * Appends a new value onto an existing header inside a `Headers` object, or adds the header if it does not already exist.
   */ append(name, value) {
        if (!isValidHeaderName(name) || !isValidHeaderValue(value)) {
            return;
        }
        const normalizedName = normalizeHeaderName(name);
        const normalizedValue = normalizeHeaderValue(value);
        let resolvedValue = this.has(normalizedName) ? `${this.get(normalizedName)}, ${normalizedValue}` : normalizedValue;
        this.set(name, resolvedValue);
    }
    /**
   * Deletes a header from the `Headers` object.
   */ delete(name) {
        if (!isValidHeaderName(name)) {
            return;
        }
        if (!this.has(name)) {
            return;
        }
        const normalizedName = normalizeHeaderName(name);
        delete this[NORMALIZED_HEADERS][normalizedName];
        this[RAW_HEADER_NAMES].delete(normalizedName);
    }
    /**
   * Traverses the `Headers` object,
   * calling the given callback for each header.
   */ forEach(callback, thisArg) {
        for (const [name, value] of this.entries()){
            callback.call(thisArg, value, name, this);
        }
    }
    /**
   * Returns an array containing the values
   * of all Set-Cookie headers associated
   * with a response
   */ getSetCookie() {
        const setCookieHeader = this.get("set-cookie");
        if (setCookieHeader === null) {
            return [];
        }
        if (setCookieHeader === "") {
            return [
                ""
            ];
        }
        return (0, import_set_cookie_parser.splitCookiesString)(setCookieHeader);
    }
};
// src/getRawHeaders.ts
function getRawHeaders(headers) {
    const rawHeaders = {};
    for (const [name, value] of headers.entries()){
        rawHeaders[headers[RAW_HEADER_NAMES].get(name)] = value;
    }
    return rawHeaders;
}
// src/transformers/headersToList.ts
function headersToList(headers) {
    const headersList = [];
    headers.forEach((value, name)=>{
        const resolvedValue = value.includes(",") ? value.split(",").map((value2)=>value2.trim()) : value;
        headersList.push([
            name,
            resolvedValue
        ]);
    });
    return headersList;
}
// src/transformers/headersToString.ts
function headersToString(headers) {
    const list = headersToList(headers);
    const lines = list.map(([name, value])=>{
        const values = [].concat(value);
        return `${name}: ${values.join(", ")}`;
    });
    return lines.join("\r\n");
}
// src/transformers/headersToObject.ts
var singleValueHeaders = [
    "user-agent"
];
function headersToObject(headers) {
    const headersObject = {};
    headers.forEach((value, name)=>{
        const isMultiValue = !singleValueHeaders.includes(name.toLowerCase()) && value.includes(",");
        headersObject[name] = isMultiValue ? value.split(",").map((s)=>s.trim()) : value;
    });
    return headersObject;
}
// src/transformers/stringToHeaders.ts
function stringToHeaders(str) {
    const lines = str.trim().split(/[\r\n]+/);
    return lines.reduce((headers, line)=>{
        if (line.trim() === "") {
            return headers;
        }
        const parts = line.split(": ");
        const name = parts.shift();
        const value = parts.join(": ");
        headers.append(name, value);
        return headers;
    }, new Headers());
}
// src/transformers/listToHeaders.ts
function listToHeaders(list) {
    const headers = new Headers();
    list.forEach(([name, value])=>{
        const values = [].concat(value);
        values.forEach((value2)=>{
            headers.append(name, value2);
        });
    });
    return headers;
}
// src/transformers/reduceHeadersObject.ts
function reduceHeadersObject(headers, reducer, initialState) {
    return Object.keys(headers).reduce((nextHeaders, name)=>{
        return reducer(nextHeaders, name, headers[name]);
    }, initialState);
}
// src/transformers/objectToHeaders.ts
function objectToHeaders(headersObject) {
    return reduceHeadersObject(headersObject, (headers, name, value)=>{
        const values = [].concat(value).filter(Boolean);
        values.forEach((value2)=>{
            headers.append(name, value2);
        });
        return headers;
    }, new Headers());
}
// src/transformers/flattenHeadersList.ts
function flattenHeadersList(list) {
    return list.map(([name, values])=>{
        return [
            name,
            [].concat(values).join(", ")
        ];
    });
}
// src/transformers/flattenHeadersObject.ts
function flattenHeadersObject(headersObject) {
    return reduceHeadersObject(headersObject, (headers, name, value)=>{
        headers[name] = [].concat(value).join(", ");
        return headers;
    }, {});
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/strict-event-emitter/lib/index.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Emitter",
    ()=>Emitter,
    "MemoryLeakError",
    ()=>MemoryLeakError
]);
// src/MemoryLeakError.ts
var MemoryLeakError = class extends Error {
    constructor(emitter, type, count){
        super(`Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`);
        this.emitter = emitter;
        this.type = type;
        this.count = count;
        this.name = "MaxListenersExceededWarning";
    }
};
// src/Emitter.ts
var _Emitter = class {
    static listenerCount(emitter, eventName) {
        return emitter.listenerCount(eventName);
    }
    constructor(){
        this.events = /* @__PURE__ */ new Map();
        this.maxListeners = _Emitter.defaultMaxListeners;
        this.hasWarnedAboutPotentialMemoryLeak = false;
    }
    _emitInternalEvent(internalEventName, eventName, listener) {
        this.emit(internalEventName, ...[
            eventName,
            listener
        ]);
    }
    _getListeners(eventName) {
        return Array.prototype.concat.apply([], this.events.get(eventName)) || [];
    }
    _removeListener(listeners, listener) {
        const index = listeners.indexOf(listener);
        if (index > -1) {
            listeners.splice(index, 1);
        }
        return [];
    }
    _wrapOnceListener(eventName, listener) {
        const onceListener = (...data)=>{
            this.removeListener(eventName, onceListener);
            return listener.apply(this, data);
        };
        Object.defineProperty(onceListener, "name", {
            value: listener.name
        });
        return onceListener;
    }
    setMaxListeners(maxListeners) {
        this.maxListeners = maxListeners;
        return this;
    }
    /**
   * Returns the current max listener value for the `Emitter` which is
   * either set by `emitter.setMaxListeners(n)` or defaults to
   * `Emitter.defaultMaxListeners`.
   */ getMaxListeners() {
        return this.maxListeners;
    }
    /**
   * Returns an array listing the events for which the emitter has registered listeners.
   * The values in the array will be strings or Symbols.
   */ eventNames() {
        return Array.from(this.events.keys());
    }
    /**
   * Synchronously calls each of the listeners registered for the event named `eventName`,
   * in the order they were registered, passing the supplied arguments to each.
   * Returns `true` if the event has listeners, `false` otherwise.
   *
   * @example
   * const emitter = new Emitter<{ hello: [string] }>()
   * emitter.emit('hello', 'John')
   */ emit(eventName, ...data) {
        const listeners = this._getListeners(eventName);
        listeners.forEach((listener)=>{
            listener.apply(this, data);
        });
        return listeners.length > 0;
    }
    addListener(eventName, listener) {
        this._emitInternalEvent("newListener", eventName, listener);
        const nextListeners = this._getListeners(eventName).concat(listener);
        this.events.set(eventName, nextListeners);
        if (this.maxListeners > 0 && this.listenerCount(eventName) > this.maxListeners && !this.hasWarnedAboutPotentialMemoryLeak) {
            this.hasWarnedAboutPotentialMemoryLeak = true;
            const memoryLeakWarning = new MemoryLeakError(this, eventName, this.listenerCount(eventName));
            console.warn(memoryLeakWarning);
        }
        return this;
    }
    on(eventName, listener) {
        return this.addListener(eventName, listener);
    }
    once(eventName, listener) {
        return this.addListener(eventName, this._wrapOnceListener(eventName, listener));
    }
    prependListener(eventName, listener) {
        const listeners = this._getListeners(eventName);
        if (listeners.length > 0) {
            const nextListeners = [
                listener
            ].concat(listeners);
            this.events.set(eventName, nextListeners);
        } else {
            this.events.set(eventName, listeners.concat(listener));
        }
        return this;
    }
    prependOnceListener(eventName, listener) {
        return this.prependListener(eventName, this._wrapOnceListener(eventName, listener));
    }
    removeListener(eventName, listener) {
        const listeners = this._getListeners(eventName);
        if (listeners.length > 0) {
            this._removeListener(listeners, listener);
            this.events.set(eventName, listeners);
            this._emitInternalEvent("removeListener", eventName, listener);
        }
        return this;
    }
    /**
   * Alias for `emitter.removeListener()`.
   *
   * @example
   * emitter.off('hello', listener)
   */ off(eventName, listener) {
        return this.removeListener(eventName, listener);
    }
    removeAllListeners(eventName) {
        if (eventName) {
            this.events.delete(eventName);
        } else {
            this.events.clear();
        }
        return this;
    }
    /**
   * Returns a copy of the array of listeners for the event named `eventName`.
   */ listeners(eventName) {
        return Array.from(this._getListeners(eventName));
    }
    /**
   * Returns the number of listeners listening to the event named `eventName`.
   */ listenerCount(eventName) {
        return this._getListeners(eventName).length;
    }
    rawListeners(eventName) {
        return this.listeners(eventName);
    }
};
var Emitter = _Emitter;
Emitter.defaultMaxListeners = 10;
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@mswjs/interceptors/lib/browser/chunk-TX5GBTFY.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "hasConfigurableGlobal",
    ()=>hasConfigurableGlobal
]);
// src/utils/hasConfigurableGlobal.ts
function hasConfigurableGlobal(propertyName) {
    const descriptor = Object.getOwnPropertyDescriptor(globalThis, propertyName);
    if (typeof descriptor === "undefined") {
        return false;
    }
    if (typeof descriptor.get === "function" && typeof descriptor.get() === "undefined") {
        return false;
    }
    if (typeof descriptor.get === "undefined" && descriptor.value == null) {
        return false;
    }
    if (typeof descriptor.set === "undefined" && !descriptor.configurable) {
        console.error(`[MSW] Failed to apply interceptor: the global \`${propertyName}\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`);
        return false;
    }
    return true;
}
;
 //# sourceMappingURL=chunk-TX5GBTFY.mjs.map
}),
"[project]/node_modules/@mswjs/interceptors/lib/browser/chunk-QED3Q6Z2.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "INTERNAL_REQUEST_ID_HEADER_NAME",
    ()=>INTERNAL_REQUEST_ID_HEADER_NAME,
    "Interceptor",
    ()=>Interceptor,
    "InterceptorReadyState",
    ()=>InterceptorReadyState,
    "createRequestId",
    ()=>createRequestId,
    "deleteGlobalSymbol",
    ()=>deleteGlobalSymbol,
    "getGlobalSymbol",
    ()=>getGlobalSymbol
]);
// src/Interceptor.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$open$2d$draft$2f$logger$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@open-draft/logger/lib/index.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strict$2d$event$2d$emitter$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/strict-event-emitter/lib/index.mjs [client] (ecmascript)");
;
;
var INTERNAL_REQUEST_ID_HEADER_NAME = "x-interceptors-internal-request-id";
function getGlobalSymbol(symbol) {
    return(// @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587
    globalThis[symbol] || void 0);
}
function setGlobalSymbol(symbol, value) {
    globalThis[symbol] = value;
}
function deleteGlobalSymbol(symbol) {
    delete globalThis[symbol];
}
var InterceptorReadyState = /* @__PURE__ */ ((InterceptorReadyState2)=>{
    InterceptorReadyState2["INACTIVE"] = "INACTIVE";
    InterceptorReadyState2["APPLYING"] = "APPLYING";
    InterceptorReadyState2["APPLIED"] = "APPLIED";
    InterceptorReadyState2["DISPOSING"] = "DISPOSING";
    InterceptorReadyState2["DISPOSED"] = "DISPOSED";
    return InterceptorReadyState2;
})(InterceptorReadyState || {});
var Interceptor = class {
    constructor(symbol){
        this.symbol = symbol;
        this.readyState = "INACTIVE" /* INACTIVE */ ;
        this.emitter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strict$2d$event$2d$emitter$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["Emitter"]();
        this.subscriptions = [];
        this.logger = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$open$2d$draft$2f$logger$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["Logger"](symbol.description);
        this.emitter.setMaxListeners(0);
        this.logger.info("constructing the interceptor...");
    }
    /**
   * Determine if this interceptor can be applied
   * in the current environment.
   */ checkEnvironment() {
        return true;
    }
    /**
   * Apply this interceptor to the current process.
   * Returns an already running interceptor instance if it's present.
   */ apply() {
        const logger = this.logger.extend("apply");
        logger.info("applying the interceptor...");
        if (this.readyState === "APPLIED" /* APPLIED */ ) {
            logger.info("intercepted already applied!");
            return;
        }
        const shouldApply = this.checkEnvironment();
        if (!shouldApply) {
            logger.info("the interceptor cannot be applied in this environment!");
            return;
        }
        this.readyState = "APPLYING" /* APPLYING */ ;
        const runningInstance = this.getInstance();
        if (runningInstance) {
            logger.info("found a running instance, reusing...");
            this.on = (event, listener)=>{
                logger.info('proxying the "%s" listener', event);
                runningInstance.emitter.addListener(event, listener);
                this.subscriptions.push(()=>{
                    runningInstance.emitter.removeListener(event, listener);
                    logger.info('removed proxied "%s" listener!', event);
                });
                return this;
            };
            this.readyState = "APPLIED" /* APPLIED */ ;
            return;
        }
        logger.info("no running instance found, setting up a new instance...");
        this.setup();
        this.setInstance();
        this.readyState = "APPLIED" /* APPLIED */ ;
    }
    /**
   * Setup the module augments and stubs necessary for this interceptor.
   * This method is not run if there's a running interceptor instance
   * to prevent instantiating an interceptor multiple times.
   */ setup() {}
    /**
   * Listen to the interceptor's public events.
   */ on(event, listener) {
        const logger = this.logger.extend("on");
        if (this.readyState === "DISPOSING" /* DISPOSING */  || this.readyState === "DISPOSED" /* DISPOSED */ ) {
            logger.info("cannot listen to events, already disposed!");
            return this;
        }
        logger.info('adding "%s" event listener:', event, listener);
        this.emitter.on(event, listener);
        return this;
    }
    once(event, listener) {
        this.emitter.once(event, listener);
        return this;
    }
    off(event, listener) {
        this.emitter.off(event, listener);
        return this;
    }
    removeAllListeners(event) {
        this.emitter.removeAllListeners(event);
        return this;
    }
    /**
   * Disposes of any side-effects this interceptor has introduced.
   */ dispose() {
        const logger = this.logger.extend("dispose");
        if (this.readyState === "DISPOSED" /* DISPOSED */ ) {
            logger.info("cannot dispose, already disposed!");
            return;
        }
        logger.info("disposing the interceptor...");
        this.readyState = "DISPOSING" /* DISPOSING */ ;
        if (!this.getInstance()) {
            logger.info("no interceptors running, skipping dispose...");
            return;
        }
        this.clearInstance();
        logger.info("global symbol deleted:", getGlobalSymbol(this.symbol));
        if (this.subscriptions.length > 0) {
            logger.info("disposing of %d subscriptions...", this.subscriptions.length);
            for (const dispose of this.subscriptions){
                dispose();
            }
            this.subscriptions = [];
            logger.info("disposed of all subscriptions!", this.subscriptions.length);
        }
        this.emitter.removeAllListeners();
        logger.info("destroyed the listener!");
        this.readyState = "DISPOSED" /* DISPOSED */ ;
    }
    getInstance() {
        var _a;
        const instance = getGlobalSymbol(this.symbol);
        this.logger.info("retrieved global instance:", (_a = instance == null ? void 0 : instance.constructor) == null ? void 0 : _a.name);
        return instance;
    }
    setInstance() {
        setGlobalSymbol(this.symbol, this);
        this.logger.info("set global instance!", this.symbol.description);
    }
    clearInstance() {
        deleteGlobalSymbol(this.symbol);
        this.logger.info("cleared global instance!", this.symbol.description);
    }
};
// src/createRequestId.ts
function createRequestId() {
    return Math.random().toString(16).slice(2);
}
;
 //# sourceMappingURL=chunk-QED3Q6Z2.mjs.map
}),
"[project]/node_modules/@mswjs/interceptors/lib/browser/interceptors/WebSocket/index.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CancelableCloseEvent",
    ()=>CancelableCloseEvent,
    "CancelableMessageEvent",
    ()=>CancelableMessageEvent,
    "CloseEvent",
    ()=>CloseEvent,
    "WebSocketClientConnection",
    ()=>WebSocketClientConnection,
    "WebSocketClientConnectionProtocol",
    ()=>WebSocketClientConnectionProtocol,
    "WebSocketInterceptor",
    ()=>WebSocketInterceptor,
    "WebSocketServerConnection",
    ()=>WebSocketServerConnection,
    "WebSocketServerConnectionProtocol",
    ()=>WebSocketServerConnectionProtocol
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mswjs$2f$interceptors$2f$lib$2f$browser$2f$chunk$2d$TX5GBTFY$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mswjs/interceptors/lib/browser/chunk-TX5GBTFY.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mswjs$2f$interceptors$2f$lib$2f$browser$2f$chunk$2d$QED3Q6Z2$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mswjs/interceptors/lib/browser/chunk-QED3Q6Z2.mjs [client] (ecmascript)");
// src/interceptors/WebSocket/WebSocketServerConnection.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/outvariant/lib/index.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$open$2d$draft$2f$deferred$2d$promise$2f$build$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@open-draft/deferred-promise/build/index.mjs [client] (ecmascript)");
;
;
// src/interceptors/WebSocket/utils/bindEvent.ts
function bindEvent(target, event) {
    Object.defineProperties(event, {
        target: {
            value: target,
            enumerable: true,
            writable: true
        },
        currentTarget: {
            value: target,
            enumerable: true,
            writable: true
        }
    });
    return event;
}
// src/interceptors/WebSocket/utils/events.ts
var kCancelable = Symbol("kCancelable");
var kDefaultPrevented = Symbol("kDefaultPrevented");
var CancelableMessageEvent = class extends MessageEvent {
    constructor(type, init){
        super(type, init);
        this[kCancelable] = !!init.cancelable;
        this[kDefaultPrevented] = false;
    }
    get cancelable() {
        return this[kCancelable];
    }
    set cancelable(nextCancelable) {
        this[kCancelable] = nextCancelable;
    }
    get defaultPrevented() {
        return this[kDefaultPrevented];
    }
    set defaultPrevented(nextDefaultPrevented) {
        this[kDefaultPrevented] = nextDefaultPrevented;
    }
    preventDefault() {
        if (this.cancelable && !this[kDefaultPrevented]) {
            this[kDefaultPrevented] = true;
        }
    }
};
kCancelable, kDefaultPrevented;
var CloseEvent = class extends Event {
    constructor(type, init = {}){
        super(type, init);
        this.code = init.code === void 0 ? 0 : init.code;
        this.reason = init.reason === void 0 ? "" : init.reason;
        this.wasClean = init.wasClean === void 0 ? false : init.wasClean;
    }
};
var CancelableCloseEvent = class extends CloseEvent {
    constructor(type, init = {}){
        super(type, init);
        this[kCancelable] = !!init.cancelable;
        this[kDefaultPrevented] = false;
    }
    get cancelable() {
        return this[kCancelable];
    }
    set cancelable(nextCancelable) {
        this[kCancelable] = nextCancelable;
    }
    get defaultPrevented() {
        return this[kDefaultPrevented];
    }
    set defaultPrevented(nextDefaultPrevented) {
        this[kDefaultPrevented] = nextDefaultPrevented;
    }
    preventDefault() {
        if (this.cancelable && !this[kDefaultPrevented]) {
            this[kDefaultPrevented] = true;
        }
    }
};
kCancelable, kDefaultPrevented;
// src/interceptors/WebSocket/WebSocketClientConnection.ts
var kEmitter = Symbol("kEmitter");
var kBoundListener = Symbol("kBoundListener");
var WebSocketClientConnectionProtocol = class {
};
var WebSocketClientConnection = class {
    constructor(socket, transport){
        this.socket = socket;
        this.transport = transport;
        this.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mswjs$2f$interceptors$2f$lib$2f$browser$2f$chunk$2d$QED3Q6Z2$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["createRequestId"])();
        this.url = new URL(socket.url);
        this[kEmitter] = new EventTarget();
        this.transport.addEventListener("outgoing", (event)=>{
            const message = bindEvent(this.socket, new CancelableMessageEvent("message", {
                data: event.data,
                origin: event.origin,
                cancelable: true
            }));
            this[kEmitter].dispatchEvent(message);
            if (message.defaultPrevented) {
                event.preventDefault();
            }
        });
        this.transport.addEventListener("close", (event)=>{
            this[kEmitter].dispatchEvent(bindEvent(this.socket, new CloseEvent("close", event)));
        });
    }
    /**
   * Listen for the outgoing events from the connected WebSocket client.
   */ addEventListener(type, listener, options) {
        if (!Reflect.has(listener, kBoundListener)) {
            const boundListener = listener.bind(this.socket);
            Object.defineProperty(listener, kBoundListener, {
                value: boundListener,
                enumerable: false,
                configurable: false
            });
        }
        this[kEmitter].addEventListener(type, Reflect.get(listener, kBoundListener), options);
    }
    /**
   * Removes the listener for the given event.
   */ removeEventListener(event, listener, options) {
        this[kEmitter].removeEventListener(event, Reflect.get(listener, kBoundListener), options);
    }
    /**
   * Send data to the connected client.
   */ send(data) {
        this.transport.send(data);
    }
    /**
   * Close the WebSocket connection.
   * @param {number} code A status code (see https://www.rfc-editor.org/rfc/rfc6455#section-7.4.1).
   * @param {string} reason A custom connection close reason.
   */ close(code, reason) {
        this.transport.close(code, reason);
    }
};
kEmitter;
;
;
;
var WEBSOCKET_CLOSE_CODE_RANGE_ERROR = "InvalidAccessError: close code out of user configurable range";
var kPassthroughPromise = Symbol("kPassthroughPromise");
var kOnSend = Symbol("kOnSend");
var kClose = Symbol("kClose");
var WebSocketOverride = class extends EventTarget {
    constructor(url, protocols){
        super();
        this.CONNECTING = 0;
        this.OPEN = 1;
        this.CLOSING = 2;
        this.CLOSED = 3;
        this._onopen = null;
        this._onmessage = null;
        this._onerror = null;
        this._onclose = null;
        this.url = url.toString();
        this.protocol = "";
        this.extensions = "";
        this.binaryType = "blob";
        this.readyState = this.CONNECTING;
        this.bufferedAmount = 0;
        this[kPassthroughPromise] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$open$2d$draft$2f$deferred$2d$promise$2f$build$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["DeferredPromise"]();
        queueMicrotask(async ()=>{
            if (await this[kPassthroughPromise]) {
                return;
            }
            this.protocol = typeof protocols === "string" ? protocols : Array.isArray(protocols) && protocols.length > 0 ? protocols[0] : "";
            if (this.readyState === this.CONNECTING) {
                this.readyState = this.OPEN;
                this.dispatchEvent(bindEvent(this, new Event("open")));
            }
        });
    }
    set onopen(listener) {
        this.removeEventListener("open", this._onopen);
        this._onopen = listener;
        if (listener !== null) {
            this.addEventListener("open", listener);
        }
    }
    get onopen() {
        return this._onopen;
    }
    set onmessage(listener) {
        this.removeEventListener("message", this._onmessage);
        this._onmessage = listener;
        if (listener !== null) {
            this.addEventListener("message", listener);
        }
    }
    get onmessage() {
        return this._onmessage;
    }
    set onerror(listener) {
        this.removeEventListener("error", this._onerror);
        this._onerror = listener;
        if (listener !== null) {
            this.addEventListener("error", listener);
        }
    }
    get onerror() {
        return this._onerror;
    }
    set onclose(listener) {
        this.removeEventListener("close", this._onclose);
        this._onclose = listener;
        if (listener !== null) {
            this.addEventListener("close", listener);
        }
    }
    get onclose() {
        return this._onclose;
    }
    /**
   * @see https://websockets.spec.whatwg.org/#ref-for-dom-websocket-send%E2%91%A0
   */ send(data) {
        if (this.readyState === this.CONNECTING) {
            this.close();
            throw new DOMException("InvalidStateError");
        }
        if (this.readyState === this.CLOSING || this.readyState === this.CLOSED) {
            return;
        }
        this.bufferedAmount += getDataSize(data);
        queueMicrotask(()=>{
            var _a;
            this.bufferedAmount = 0;
            (_a = this[kOnSend]) == null ? void 0 : _a.call(this, data);
        });
    }
    close(code = 1e3, reason) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"])(code, WEBSOCKET_CLOSE_CODE_RANGE_ERROR);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"])(code === 1e3 || code >= 3e3 && code <= 4999, WEBSOCKET_CLOSE_CODE_RANGE_ERROR);
        this[kClose](code, reason);
    }
    [(kPassthroughPromise, kOnSend, kClose)](code = 1e3, reason, wasClean = true) {
        if (this.readyState === this.CLOSING || this.readyState === this.CLOSED) {
            return;
        }
        this.readyState = this.CLOSING;
        queueMicrotask(()=>{
            this.readyState = this.CLOSED;
            this.dispatchEvent(bindEvent(this, new CloseEvent("close", {
                code,
                reason,
                wasClean
            })));
            this._onopen = null;
            this._onmessage = null;
            this._onerror = null;
            this._onclose = null;
        });
    }
    addEventListener(type, listener, options) {
        return super.addEventListener(type, listener, options);
    }
    removeEventListener(type, callback, options) {
        return super.removeEventListener(type, callback, options);
    }
};
WebSocketOverride.CONNECTING = 0;
WebSocketOverride.OPEN = 1;
WebSocketOverride.CLOSING = 2;
WebSocketOverride.CLOSED = 3;
function getDataSize(data) {
    if (typeof data === "string") {
        return data.length;
    }
    if (data instanceof Blob) {
        return data.size;
    }
    return data.byteLength;
}
// src/interceptors/WebSocket/WebSocketServerConnection.ts
var kEmitter2 = Symbol("kEmitter");
var kBoundListener2 = Symbol("kBoundListener");
var kSend = Symbol("kSend");
var WebSocketServerConnectionProtocol = class {
};
var WebSocketServerConnection = class {
    constructor(client, transport, createConnection){
        this.client = client;
        this.transport = transport;
        this.createConnection = createConnection;
        this[kEmitter2] = new EventTarget();
        this.mockCloseController = new AbortController();
        this.realCloseController = new AbortController();
        this.transport.addEventListener("outgoing", (event)=>{
            if (typeof this.realWebSocket === "undefined") {
                return;
            }
            queueMicrotask(()=>{
                if (!event.defaultPrevented) {
                    this[kSend](event.data);
                }
            });
        });
        this.transport.addEventListener("incoming", this.handleIncomingMessage.bind(this));
    }
    /**
   * The `WebSocket` instance connected to the original server.
   * Accessing this before calling `server.connect()` will throw.
   */ get socket() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"])(this.realWebSocket, 'Cannot access "socket" on the original WebSocket server object: the connection is not open. Did you forget to call `server.connect()`?');
        return this.realWebSocket;
    }
    /**
   * Open connection to the original WebSocket server.
   */ connect() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"])(!this.realWebSocket || this.realWebSocket.readyState !== WebSocket.OPEN, 'Failed to call "connect()" on the original WebSocket instance: the connection already open');
        const realWebSocket = this.createConnection();
        realWebSocket.binaryType = this.client.binaryType;
        realWebSocket.addEventListener("open", (event)=>{
            this[kEmitter2].dispatchEvent(bindEvent(this.realWebSocket, new Event("open", event)));
        }, {
            once: true
        });
        realWebSocket.addEventListener("message", (event)=>{
            this.transport.dispatchEvent(bindEvent(this.realWebSocket, new MessageEvent("incoming", {
                data: event.data,
                origin: event.origin
            })));
        });
        this.client.addEventListener("close", (event)=>{
            this.handleMockClose(event);
        }, {
            signal: this.mockCloseController.signal
        });
        realWebSocket.addEventListener("close", (event)=>{
            this.handleRealClose(event);
        }, {
            signal: this.realCloseController.signal
        });
        realWebSocket.addEventListener("error", ()=>{
            const errorEvent = bindEvent(realWebSocket, new Event("error", {
                cancelable: true
            }));
            this[kEmitter2].dispatchEvent(errorEvent);
            if (!errorEvent.defaultPrevented) {
                this.client.dispatchEvent(bindEvent(this.client, new Event("error")));
            }
        });
        this.realWebSocket = realWebSocket;
    }
    /**
   * Listen for the incoming events from the original WebSocket server.
   */ addEventListener(event, listener, options) {
        if (!Reflect.has(listener, kBoundListener2)) {
            const boundListener = listener.bind(this.client);
            Object.defineProperty(listener, kBoundListener2, {
                value: boundListener,
                enumerable: false
            });
        }
        this[kEmitter2].addEventListener(event, Reflect.get(listener, kBoundListener2), options);
    }
    /**
   * Remove the listener for the given event.
   */ removeEventListener(event, listener, options) {
        this[kEmitter2].removeEventListener(event, Reflect.get(listener, kBoundListener2), options);
    }
    /**
   * Send data to the original WebSocket server.
   * @example
   * server.send('hello')
   * server.send(new Blob(['hello']))
   * server.send(new TextEncoder().encode('hello'))
   */ send(data) {
        this[kSend](data);
    }
    [(kEmitter2, kSend)](data) {
        const { realWebSocket } = this;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"])(realWebSocket, 'Failed to call "server.send()" for "%s": the connection is not open. Did you forget to call "server.connect()"?', this.client.url);
        if (realWebSocket.readyState === WebSocket.CLOSING || realWebSocket.readyState === WebSocket.CLOSED) {
            return;
        }
        if (realWebSocket.readyState === WebSocket.CONNECTING) {
            realWebSocket.addEventListener("open", ()=>{
                realWebSocket.send(data);
            }, {
                once: true
            });
            return;
        }
        realWebSocket.send(data);
    }
    /**
   * Close the actual server connection.
   */ close() {
        const { realWebSocket } = this;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"])(realWebSocket, 'Failed to close server connection for "%s": the connection is not open. Did you forget to call "server.connect()"?', this.client.url);
        this.realCloseController.abort();
        if (realWebSocket.readyState === WebSocket.CLOSING || realWebSocket.readyState === WebSocket.CLOSED) {
            return;
        }
        realWebSocket.close();
        queueMicrotask(()=>{
            this[kEmitter2].dispatchEvent(bindEvent(this.realWebSocket, new CancelableCloseEvent("close", {
                /**
             * @note `server.close()` in the interceptor
             * always results in clean closures.
             */ code: 1e3,
                cancelable: true
            })));
        });
    }
    handleIncomingMessage(event) {
        const messageEvent = bindEvent(event.target, new CancelableMessageEvent("message", {
            data: event.data,
            origin: event.origin,
            cancelable: true
        }));
        this[kEmitter2].dispatchEvent(messageEvent);
        if (!messageEvent.defaultPrevented) {
            this.client.dispatchEvent(bindEvent(/**
           * @note Bind the forwarded original server events
           * to the mock WebSocket instance so it would
           * dispatch them straight away.
           */ this.client, // Clone the message event again to prevent
            // the "already being dispatched" exception.
            new MessageEvent("message", {
                data: event.data,
                origin: event.origin
            })));
        }
    }
    handleMockClose(_event) {
        if (this.realWebSocket) {
            this.realWebSocket.close();
        }
    }
    handleRealClose(event) {
        this.mockCloseController.abort();
        const closeEvent = bindEvent(this.realWebSocket, new CancelableCloseEvent("close", {
            code: event.code,
            reason: event.reason,
            wasClean: event.wasClean,
            cancelable: true
        }));
        this[kEmitter2].dispatchEvent(closeEvent);
        if (!closeEvent.defaultPrevented) {
            this.client[kClose](event.code, event.reason);
        }
    }
};
// src/interceptors/WebSocket/WebSocketClassTransport.ts
var WebSocketClassTransport = class extends EventTarget {
    constructor(socket){
        super();
        this.socket = socket;
        this.socket.addEventListener("close", (event)=>{
            this.dispatchEvent(bindEvent(this.socket, new CloseEvent("close", event)));
        });
        this.socket[kOnSend] = (data)=>{
            this.dispatchEvent(bindEvent(this.socket, // Dispatch this as cancelable because "client" connection
            // re-creates this message event (cannot dispatch the same event).
            new CancelableMessageEvent("outgoing", {
                data,
                origin: this.socket.url,
                cancelable: true
            })));
        };
    }
    addEventListener(type, callback, options) {
        return super.addEventListener(type, callback, options);
    }
    dispatchEvent(event) {
        return super.dispatchEvent(event);
    }
    send(data) {
        queueMicrotask(()=>{
            if (this.socket.readyState === this.socket.CLOSING || this.socket.readyState === this.socket.CLOSED) {
                return;
            }
            const dispatchEvent = ()=>{
                this.socket.dispatchEvent(bindEvent(/**
             * @note Setting this event's "target" to the
             * WebSocket override instance is important.
             * This way it can tell apart original incoming events
             * (must be forwarded to the transport) from the
             * mocked message events like the one below
             * (must be dispatched on the client instance).
             */ this.socket, new MessageEvent("message", {
                    data,
                    origin: this.socket.url
                })));
            };
            if (this.socket.readyState === this.socket.CONNECTING) {
                this.socket.addEventListener("open", ()=>{
                    dispatchEvent();
                }, {
                    once: true
                });
            } else {
                dispatchEvent();
            }
        });
    }
    close(code, reason) {
        this.socket[kClose](code, reason);
    }
};
// src/interceptors/WebSocket/index.ts
var _WebSocketInterceptor = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mswjs$2f$interceptors$2f$lib$2f$browser$2f$chunk$2d$QED3Q6Z2$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["Interceptor"] {
    constructor(){
        super(_WebSocketInterceptor.symbol);
    }
    checkEnvironment() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mswjs$2f$interceptors$2f$lib$2f$browser$2f$chunk$2d$TX5GBTFY$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["hasConfigurableGlobal"])("WebSocket");
    }
    setup() {
        const originalWebSocketDescriptor = Object.getOwnPropertyDescriptor(globalThis, "WebSocket");
        const WebSocketProxy = new Proxy(globalThis.WebSocket, {
            construct: (target, args, newTarget)=>{
                const [url, protocols] = args;
                const createConnection = ()=>{
                    return Reflect.construct(target, args, newTarget);
                };
                const socket = new WebSocketOverride(url, protocols);
                const transport = new WebSocketClassTransport(socket);
                queueMicrotask(()=>{
                    try {
                        const server = new WebSocketServerConnection(socket, transport, createConnection);
                        const hasConnectionListeners = this.emitter.emit("connection", {
                            client: new WebSocketClientConnection(socket, transport),
                            server,
                            info: {
                                protocols
                            }
                        });
                        if (hasConnectionListeners) {
                            socket[kPassthroughPromise].resolve(false);
                        } else {
                            socket[kPassthroughPromise].resolve(true);
                            server.connect();
                            server.addEventListener("open", ()=>{
                                socket.dispatchEvent(bindEvent(socket, new Event("open")));
                                if (server["realWebSocket"]) {
                                    socket.protocol = server["realWebSocket"].protocol;
                                }
                            });
                        }
                    } catch (error) {
                        if (error instanceof Error) {
                            socket.dispatchEvent(new Event("error"));
                            if (socket.readyState !== WebSocket.CLOSING && socket.readyState !== WebSocket.CLOSED) {
                                socket[kClose](1011, error.message, false);
                            }
                            console.error(error);
                        }
                    }
                });
                return socket;
            }
        });
        Object.defineProperty(globalThis, "WebSocket", {
            value: WebSocketProxy,
            configurable: true
        });
        this.subscriptions.push(()=>{
            Object.defineProperty(globalThis, "WebSocket", originalWebSocketDescriptor);
        });
    }
};
var WebSocketInterceptor = _WebSocketInterceptor;
WebSocketInterceptor.symbol = Symbol("websocket");
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@mswjs/interceptors/lib/browser/chunk-6HYIRFX2.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decodeBuffer",
    ()=>decodeBuffer,
    "encodeBuffer",
    ()=>encodeBuffer,
    "toArrayBuffer",
    ()=>toArrayBuffer
]);
// src/utils/bufferUtils.ts
var encoder = new TextEncoder();
function encodeBuffer(text) {
    return encoder.encode(text);
}
function decodeBuffer(buffer, encoding) {
    const decoder = new TextDecoder(encoding);
    return decoder.decode(buffer);
}
function toArrayBuffer(array) {
    return array.buffer.slice(array.byteOffset, array.byteOffset + array.byteLength);
}
;
 //# sourceMappingURL=chunk-6HYIRFX2.mjs.map
}),
"[project]/node_modules/@mswjs/interceptors/lib/browser/chunk-3RXCRGL2.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FetchResponse",
    ()=>FetchResponse,
    "IS_PATCHED_MODULE",
    ()=>IS_PATCHED_MODULE,
    "canParseUrl",
    ()=>canParseUrl,
    "getRawRequest",
    ()=>getRawRequest,
    "setRawRequest",
    ()=>setRawRequest
]);
// src/glossary.ts
var IS_PATCHED_MODULE = Symbol("isPatchedModule");
// src/utils/canParseUrl.ts
function canParseUrl(url) {
    try {
        new URL(url);
        return true;
    } catch (_error) {
        return false;
    }
}
// src/utils/getValueBySymbol.ts
function getValueBySymbol(symbolName, source) {
    const ownSymbols = Object.getOwnPropertySymbols(source);
    const symbol = ownSymbols.find((symbol2)=>{
        return symbol2.description === symbolName;
    });
    if (symbol) {
        return Reflect.get(source, symbol);
    }
    return;
}
// src/utils/fetchUtils.ts
var _FetchResponse = class extends Response {
    static isConfigurableStatusCode(status) {
        return status >= 200 && status <= 599;
    }
    static isRedirectResponse(status) {
        return _FetchResponse.STATUS_CODES_WITH_REDIRECT.includes(status);
    }
    /**
   * Returns a boolean indicating whether the given response status
   * code represents a response that can have a body.
   */ static isResponseWithBody(status) {
        return !_FetchResponse.STATUS_CODES_WITHOUT_BODY.includes(status);
    }
    static setUrl(url, response) {
        if (!url || url === "about:" || !canParseUrl(url)) {
            return;
        }
        const state = getValueBySymbol("state", response);
        if (state) {
            state.urlList.push(new URL(url));
        } else {
            Object.defineProperty(response, "url", {
                value: url,
                enumerable: true,
                configurable: true,
                writable: false
            });
        }
    }
    /**
   * Parses the given raw HTTP headers into a Fetch API `Headers` instance.
   */ static parseRawHeaders(rawHeaders) {
        const headers = new Headers();
        for(let line = 0; line < rawHeaders.length; line += 2){
            headers.append(rawHeaders[line], rawHeaders[line + 1]);
        }
        return headers;
    }
    constructor(body, init = {}){
        var _a;
        const status = (_a = init.status) != null ? _a : 200;
        const safeStatus = _FetchResponse.isConfigurableStatusCode(status) ? status : 200;
        const finalBody = _FetchResponse.isResponseWithBody(status) ? body : null;
        super(finalBody, {
            status: safeStatus,
            statusText: init.statusText,
            headers: init.headers
        });
        if (status !== safeStatus) {
            const state = getValueBySymbol("state", this);
            if (state) {
                state.status = status;
            } else {
                Object.defineProperty(this, "status", {
                    value: status,
                    enumerable: true,
                    configurable: true,
                    writable: false
                });
            }
        }
        _FetchResponse.setUrl(init.url, this);
    }
};
var FetchResponse = _FetchResponse;
/**
 * Response status codes for responses that cannot have body.
 * @see https://fetch.spec.whatwg.org/#statuses
 */ FetchResponse.STATUS_CODES_WITHOUT_BODY = [
    101,
    103,
    204,
    205,
    304
];
FetchResponse.STATUS_CODES_WITH_REDIRECT = [
    301,
    302,
    303,
    307,
    308
];
// src/getRawRequest.ts
var kRawRequest = Symbol("kRawRequest");
function getRawRequest(request) {
    return Reflect.get(request, kRawRequest);
}
function setRawRequest(request, rawRequest) {
    Reflect.set(request, kRawRequest, rawRequest);
}
;
 //# sourceMappingURL=chunk-3RXCRGL2.mjs.map
}),
"[project]/node_modules/@mswjs/interceptors/lib/browser/index.mjs [client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BatchInterceptor",
    ()=>BatchInterceptor,
    "getCleanUrl",
    ()=>getCleanUrl
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mswjs$2f$interceptors$2f$lib$2f$browser$2f$chunk$2d$6HYIRFX2$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mswjs/interceptors/lib/browser/chunk-6HYIRFX2.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mswjs$2f$interceptors$2f$lib$2f$browser$2f$chunk$2d$3RXCRGL2$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mswjs/interceptors/lib/browser/chunk-3RXCRGL2.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mswjs$2f$interceptors$2f$lib$2f$browser$2f$chunk$2d$QED3Q6Z2$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mswjs/interceptors/lib/browser/chunk-QED3Q6Z2.mjs [client] (ecmascript)");
;
;
;
// src/BatchInterceptor.ts
var BatchInterceptor = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mswjs$2f$interceptors$2f$lib$2f$browser$2f$chunk$2d$QED3Q6Z2$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["Interceptor"] {
    constructor(options){
        BatchInterceptor.symbol = Symbol(options.name);
        super(BatchInterceptor.symbol);
        this.interceptors = options.interceptors;
    }
    setup() {
        const logger = this.logger.extend("setup");
        logger.info("applying all %d interceptors...", this.interceptors.length);
        for (const interceptor of this.interceptors){
            logger.info('applying "%s" interceptor...', interceptor.constructor.name);
            interceptor.apply();
            logger.info("adding interceptor dispose subscription");
            this.subscriptions.push(()=>interceptor.dispose());
        }
    }
    on(event, listener) {
        for (const interceptor of this.interceptors){
            interceptor.on(event, listener);
        }
        return this;
    }
    once(event, listener) {
        for (const interceptor of this.interceptors){
            interceptor.once(event, listener);
        }
        return this;
    }
    off(event, listener) {
        for (const interceptor of this.interceptors){
            interceptor.off(event, listener);
        }
        return this;
    }
    removeAllListeners(event) {
        for (const interceptors of this.interceptors){
            interceptors.removeAllListeners(event);
        }
        return this;
    }
};
// src/utils/getCleanUrl.ts
function getCleanUrl(url, isAbsolute = true) {
    return [
        isAbsolute && url.origin,
        url.pathname
    ].filter(Boolean).join("");
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@open-draft/logger/lib/index.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Logger",
    ()=>Logger
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
// src/index.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$node$2d$process$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-node-process/lib/index.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/outvariant/lib/index.mjs [client] (ecmascript)");
var __defProp = Object.defineProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
;
;
// src/colors.ts
var colors_exports = {};
__export(colors_exports, {
    blue: ()=>blue,
    gray: ()=>gray,
    green: ()=>green,
    red: ()=>red,
    yellow: ()=>yellow
});
function yellow(text) {
    return `\x1B[33m${text}\x1B[0m`;
}
function blue(text) {
    return `\x1B[34m${text}\x1B[0m`;
}
function gray(text) {
    return `\x1B[90m${text}\x1B[0m`;
}
function red(text) {
    return `\x1B[31m${text}\x1B[0m`;
}
function green(text) {
    return `\x1B[32m${text}\x1B[0m`;
}
// src/index.ts
var IS_NODE = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$node$2d$process$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isNodeProcess"])();
var Logger = class {
    constructor(name){
        this.name = name;
        this.prefix = `[${this.name}]`;
        const LOGGER_NAME = getVariable("DEBUG");
        const LOGGER_LEVEL = getVariable("LOG_LEVEL");
        const isLoggingEnabled = LOGGER_NAME === "1" || LOGGER_NAME === "true" || typeof LOGGER_NAME !== "undefined" && this.name.startsWith(LOGGER_NAME);
        if (isLoggingEnabled) {
            this.debug = isDefinedAndNotEquals(LOGGER_LEVEL, "debug") ? noop : this.debug;
            this.info = isDefinedAndNotEquals(LOGGER_LEVEL, "info") ? noop : this.info;
            this.success = isDefinedAndNotEquals(LOGGER_LEVEL, "success") ? noop : this.success;
            this.warning = isDefinedAndNotEquals(LOGGER_LEVEL, "warning") ? noop : this.warning;
            this.error = isDefinedAndNotEquals(LOGGER_LEVEL, "error") ? noop : this.error;
        } else {
            this.info = noop;
            this.success = noop;
            this.warning = noop;
            this.error = noop;
            this.only = noop;
        }
    }
    prefix;
    extend(domain) {
        return new Logger(`${this.name}:${domain}`);
    }
    /**
   * Print a debug message.
   * @example
   * logger.debug('no duplicates found, creating a document...')
   */ debug(message, ...positionals) {
        this.logEntry({
            level: "debug",
            message: gray(message),
            positionals,
            prefix: this.prefix,
            colors: {
                prefix: "gray"
            }
        });
    }
    /**
   * Print an info message.
   * @example
   * logger.info('start parsing...')
   */ info(message, ...positionals) {
        this.logEntry({
            level: "info",
            message,
            positionals,
            prefix: this.prefix,
            colors: {
                prefix: "blue"
            }
        });
        const performance2 = new PerformanceEntry();
        return (message2, ...positionals2)=>{
            performance2.measure();
            this.logEntry({
                level: "info",
                message: `${message2} ${gray(`${performance2.deltaTime}ms`)}`,
                positionals: positionals2,
                prefix: this.prefix,
                colors: {
                    prefix: "blue"
                }
            });
        };
    }
    /**
   * Print a success message.
   * @example
   * logger.success('successfully created document')
   */ success(message, ...positionals) {
        this.logEntry({
            level: "info",
            message,
            positionals,
            prefix: `\u2714 ${this.prefix}`,
            colors: {
                timestamp: "green",
                prefix: "green"
            }
        });
    }
    /**
   * Print a warning.
   * @example
   * logger.warning('found legacy document format')
   */ warning(message, ...positionals) {
        this.logEntry({
            level: "warning",
            message,
            positionals,
            prefix: `\u26A0 ${this.prefix}`,
            colors: {
                timestamp: "yellow",
                prefix: "yellow"
            }
        });
    }
    /**
   * Print an error message.
   * @example
   * logger.error('something went wrong')
   */ error(message, ...positionals) {
        this.logEntry({
            level: "error",
            message,
            positionals,
            prefix: `\u2716 ${this.prefix}`,
            colors: {
                timestamp: "red",
                prefix: "red"
            }
        });
    }
    /**
   * Execute the given callback only when the logging is enabled.
   * This is skipped in its entirety and has no runtime cost otherwise.
   * This executes regardless of the log level.
   * @example
   * logger.only(() => {
   *   logger.info('additional info')
   * })
   */ only(callback) {
        callback();
    }
    createEntry(level, message) {
        return {
            timestamp: /* @__PURE__ */ new Date(),
            level,
            message
        };
    }
    logEntry(args) {
        const { level, message, prefix, colors: customColors, positionals = [] } = args;
        const entry = this.createEntry(level, message);
        const timestampColor = customColors?.timestamp || "gray";
        const prefixColor = customColors?.prefix || "gray";
        const colorize = {
            timestamp: colors_exports[timestampColor],
            prefix: colors_exports[prefixColor]
        };
        const write = this.getWriter(level);
        write([
            colorize.timestamp(this.formatTimestamp(entry.timestamp))
        ].concat(prefix != null ? colorize.prefix(prefix) : []).concat(serializeInput(message)).join(" "), ...positionals.map(serializeInput));
    }
    formatTimestamp(timestamp) {
        return `${timestamp.toLocaleTimeString("en-GB")}:${timestamp.getMilliseconds()}`;
    }
    getWriter(level) {
        switch(level){
            case "debug":
            case "success":
            case "info":
                {
                    return log;
                }
            case "warning":
                {
                    return warn;
                }
            case "error":
                {
                    return error;
                }
        }
    }
};
var PerformanceEntry = class {
    startTime;
    endTime;
    deltaTime;
    constructor(){
        this.startTime = performance.now();
    }
    measure() {
        this.endTime = performance.now();
        const deltaTime = this.endTime - this.startTime;
        this.deltaTime = deltaTime.toFixed(2);
    }
};
var noop = ()=>void 0;
function log(message, ...positionals) {
    if (IS_NODE) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].stdout.write((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["format"])(message, ...positionals) + "\n");
        return;
    }
    console.log(message, ...positionals);
}
function warn(message, ...positionals) {
    if (IS_NODE) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].stderr.write((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["format"])(message, ...positionals) + "\n");
        return;
    }
    console.warn(message, ...positionals);
}
function error(message, ...positionals) {
    if (IS_NODE) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].stderr.write((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["format"])(message, ...positionals) + "\n");
        return;
    }
    console.error(message, ...positionals);
}
function getVariable(variableName) {
    if (IS_NODE) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].env[variableName];
    }
    return globalThis[variableName]?.toString();
}
function isDefinedAndNotEquals(value, expected) {
    return value !== void 0 && value !== expected;
}
function serializeInput(message) {
    if (typeof message === "undefined") {
        return "undefined";
    }
    if (message === null) {
        return "null";
    }
    if (typeof message === "string") {
        return message;
    }
    if (typeof message === "object") {
        return JSON.stringify(message);
    }
    return message.toString();
}
;
}),
"[project]/node_modules/@open-draft/deferred-promise/build/index.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DeferredPromise",
    ()=>DeferredPromise,
    "createDeferredExecutor",
    ()=>createDeferredExecutor
]);
// src/createDeferredExecutor.ts
function createDeferredExecutor() {
    const executor = (resolve, reject)=>{
        executor.state = "pending";
        executor.resolve = (data)=>{
            if (executor.state !== "pending") {
                return;
            }
            executor.result = data;
            const onFulfilled = (value)=>{
                executor.state = "fulfilled";
                return value;
            };
            return resolve(data instanceof Promise ? data : Promise.resolve(data).then(onFulfilled));
        };
        executor.reject = (reason)=>{
            if (executor.state !== "pending") {
                return;
            }
            queueMicrotask(()=>{
                executor.state = "rejected";
            });
            return reject(executor.rejectionReason = reason);
        };
    };
    return executor;
}
// src/DeferredPromise.ts
var DeferredPromise = class extends Promise {
    #executor;
    resolve;
    reject;
    constructor(executor = null){
        const deferredExecutor = createDeferredExecutor();
        super((originalResolve, originalReject)=>{
            deferredExecutor(originalResolve, originalReject);
            executor?.(deferredExecutor.resolve, deferredExecutor.reject);
        });
        this.#executor = deferredExecutor;
        this.resolve = this.#executor.resolve;
        this.reject = this.#executor.reject;
    }
    get state() {
        return this.#executor.state;
    }
    get rejectionReason() {
        return this.#executor.rejectionReason;
    }
    then(onFulfilled, onRejected) {
        return this.#decorate(super.then(onFulfilled, onRejected));
    }
    catch(onRejected) {
        return this.#decorate(super.catch(onRejected));
    }
    finally(onfinally) {
        return this.#decorate(super.finally(onfinally));
    }
    #decorate(promise) {
        return Object.defineProperties(promise, {
            resolve: {
                configurable: true,
                value: this.resolve
            },
            reject: {
                configurable: true,
                value: this.reject
            }
        });
    }
};
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/path-to-regexp/dist.es2015/index.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "compile",
    ()=>compile,
    "match",
    ()=>match,
    "parse",
    ()=>parse,
    "pathToRegexp",
    ()=>pathToRegexp,
    "regexpToFunction",
    ()=>regexpToFunction,
    "tokensToFunction",
    ()=>tokensToFunction,
    "tokensToRegexp",
    ()=>tokensToRegexp
]);
/**
 * Tokenize input string.
 */ function lexer(str) {
    var tokens = [];
    var i = 0;
    while(i < str.length){
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({
                type: "MODIFIER",
                index: i,
                value: str[i++]
            });
            continue;
        }
        if (char === "\\") {
            tokens.push({
                type: "ESCAPED_CHAR",
                index: i++,
                value: str[i++]
            });
            continue;
        }
        if (char === "{") {
            tokens.push({
                type: "OPEN",
                index: i,
                value: str[i++]
            });
            continue;
        }
        if (char === "}") {
            tokens.push({
                type: "CLOSE",
                index: i,
                value: str[i++]
            });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while(j < str.length){
                var code = str.charCodeAt(j);
                if (// `0-9`
                code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || // `_`
                code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name) throw new TypeError("Missing parameter name at ".concat(i));
            tokens.push({
                type: "NAME",
                index: i,
                value: name
            });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at ".concat(j));
            }
            while(j < str.length){
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                } else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at ".concat(j));
                    }
                }
                pattern += str[j++];
            }
            if (count) throw new TypeError("Unbalanced pattern at ".concat(i));
            if (!pattern) throw new TypeError("Missing pattern at ".concat(i));
            tokens.push({
                type: "PATTERN",
                index: i,
                value: pattern
            });
            i = j;
            continue;
        }
        tokens.push({
            type: "CHAR",
            index: i,
            value: str[i++]
        });
    }
    tokens.push({
        type: "END",
        index: i,
        value: ""
    });
    return tokens;
}
function parse(str, options) {
    if (options === void 0) {
        options = {};
    }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a, _b = options.delimiter, delimiter = _b === void 0 ? "/#?" : _b;
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function(type) {
        if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;
    };
    var mustConsume = function(type) {
        var value = tryConsume(type);
        if (value !== undefined) return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));
    };
    var consumeText = function() {
        var result = "";
        var value;
        while(value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")){
            result += value;
        }
        return result;
    };
    var isSafe = function(value) {
        for(var _i = 0, delimiter_1 = delimiter; _i < delimiter_1.length; _i++){
            var char = delimiter_1[_i];
            if (value.indexOf(char) > -1) return true;
        }
        return false;
    };
    var safePattern = function(prefix) {
        var prev = result[result.length - 1];
        var prevText = prefix || (prev && typeof prev === "string" ? prev : "");
        if (prev && !prevText) {
            throw new TypeError("Must have text between two parameters, missing text after \"".concat(prev.name, "\""));
        }
        if (!prevText || isSafe(prevText)) return "[^".concat(escapeString(delimiter), "]+?");
        return "(?:(?!".concat(escapeString(prevText), ")[^").concat(escapeString(delimiter), "])+?");
    };
    while(i < tokens.length){
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || safePattern(prefix),
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? safePattern(prefix) : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
}
function tokensToFunction(tokens, options) {
    if (options === void 0) {
        options = {};
    }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function(x) {
        return x;
    } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function(token) {
        if (typeof token === "object") {
            return new RegExp("^(?:".concat(token.pattern, ")$"), reFlags);
        }
    });
    return function(data) {
        var path = "";
        for(var i = 0; i < tokens.length; i++){
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"".concat(token.name, "\" to not repeat, but got an array"));
                }
                if (value.length === 0) {
                    if (optional) continue;
                    throw new TypeError("Expected \"".concat(token.name, "\" to not be empty"));
                }
                for(var j = 0; j < value.length; j++){
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"".concat(token.name, "\" to match \"").concat(token.pattern, "\", but got \"").concat(segment, "\""));
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"".concat(token.name, "\" to match \"").concat(token.pattern, "\", but got \"").concat(segment, "\""));
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional) continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"".concat(token.name, "\" to be ").concat(typeOfMessage));
        }
        return path;
    };
}
function match(str, options) {
    var keys = [];
    var re = pathToRegexp(str, keys, options);
    return regexpToFunction(re, keys, options);
}
function regexpToFunction(re, keys, options) {
    if (options === void 0) {
        options = {};
    }
    var _a = options.decode, decode = _a === void 0 ? function(x) {
        return x;
    } : _a;
    return function(pathname) {
        var m = re.exec(pathname);
        if (!m) return false;
        var path = m[0], index = m.index;
        var params = Object.create(null);
        var _loop_1 = function(i) {
            if (m[i] === undefined) return "continue";
            var key = keys[i - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i].split(key.prefix + key.suffix).map(function(value) {
                    return decode(value, key);
                });
            } else {
                params[key.name] = decode(m[i], key);
            }
        };
        for(var i = 1; i < m.length; i++){
            _loop_1(i);
        }
        return {
            path: path,
            index: index,
            params: params
        };
    };
}
/**
 * Escape a regular expression string.
 */ function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */ function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */ function regexpToRegexp(path, keys) {
    if (!keys) return path;
    var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
    var index = 0;
    var execResult = groupsRegex.exec(path.source);
    while(execResult){
        keys.push({
            // Use parenthesized substring match if available, index otherwise
            name: execResult[1] || index++,
            prefix: "",
            suffix: "",
            modifier: "",
            pattern: ""
        });
        execResult = groupsRegex.exec(path.source);
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */ function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function(path) {
        return pathToRegexp(path, keys, options).source;
    });
    return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));
}
/**
 * Create a path regexp from string input.
 */ function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) {
        options = {};
    }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function(x) {
        return x;
    } : _d, _e = options.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;
    var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
    var delimiterRe = "[".concat(escapeString(delimiter), "]");
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for(var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++){
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        } else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys) keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);
                    } else {
                        route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
                    }
                } else {
                    if (token.modifier === "+" || token.modifier === "*") {
                        throw new TypeError("Can not repeat \"".concat(token.name, "\" without a prefix and suffix"));
                    }
                    route += "(".concat(token.pattern, ")").concat(token.modifier);
                }
            } else {
                route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
            }
        }
    }
    if (end) {
        if (!strict) route += "".concat(delimiterRe, "?");
        route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
    } else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === undefined;
        if (!strict) {
            route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
        }
        if (!isEndDelimited) {
            route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
        }
    }
    return new RegExp(route, flags(options));
}
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp) return regexpToRegexp(path, keys);
    if (Array.isArray(path)) return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@bundled-es-modules/cookie/index-esm.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>source_default
]);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod)=>function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
// node_modules/cookie/index.js
var require_cookie = __commonJS({
    "node_modules/cookie/index.js" (exports) {
        "use strict";
        exports.parse = parse;
        exports.serialize = serialize;
        var __toString = Object.prototype.toString;
        var __hasOwnProperty = Object.prototype.hasOwnProperty;
        var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
        var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
        var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
        var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
        function parse(str, opt) {
            if (typeof str !== "string") {
                throw new TypeError("argument str must be a string");
            }
            var obj = {};
            var len = str.length;
            if (len < 2) return obj;
            var dec = opt && opt.decode || decode;
            var index = 0;
            var eqIdx = 0;
            var endIdx = 0;
            do {
                eqIdx = str.indexOf("=", index);
                if (eqIdx === -1) break;
                endIdx = str.indexOf(";", index);
                if (endIdx === -1) {
                    endIdx = len;
                } else if (eqIdx > endIdx) {
                    index = str.lastIndexOf(";", eqIdx - 1) + 1;
                    continue;
                }
                var keyStartIdx = startIndex(str, index, eqIdx);
                var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
                var key = str.slice(keyStartIdx, keyEndIdx);
                if (!__hasOwnProperty.call(obj, key)) {
                    var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
                    var valEndIdx = endIndex(str, endIdx, valStartIdx);
                    if (str.charCodeAt(valStartIdx) === 34 && str.charCodeAt(valEndIdx - 1) === 34) {
                        valStartIdx++;
                        valEndIdx--;
                    }
                    var val = str.slice(valStartIdx, valEndIdx);
                    obj[key] = tryDecode(val, dec);
                }
                index = endIdx + 1;
            }while (index < len)
            return obj;
        }
        function startIndex(str, index, max) {
            do {
                var code = str.charCodeAt(index);
                if (code !== 32 && code !== 9) return index;
            }while (++index < max)
            return max;
        }
        function endIndex(str, index, min) {
            while(index > min){
                var code = str.charCodeAt(--index);
                if (code !== 32 && code !== 9) return index + 1;
            }
            return min;
        }
        function serialize(name, val, opt) {
            var enc = opt && opt.encode || encodeURIComponent;
            if (typeof enc !== "function") {
                throw new TypeError("option encode is invalid");
            }
            if (!cookieNameRegExp.test(name)) {
                throw new TypeError("argument name is invalid");
            }
            var value = enc(val);
            if (!cookieValueRegExp.test(value)) {
                throw new TypeError("argument val is invalid");
            }
            var str = name + "=" + value;
            if (!opt) return str;
            if (null != opt.maxAge) {
                var maxAge = Math.floor(opt.maxAge);
                if (!isFinite(maxAge)) {
                    throw new TypeError("option maxAge is invalid");
                }
                str += "; Max-Age=" + maxAge;
            }
            if (opt.domain) {
                if (!domainValueRegExp.test(opt.domain)) {
                    throw new TypeError("option domain is invalid");
                }
                str += "; Domain=" + opt.domain;
            }
            if (opt.path) {
                if (!pathValueRegExp.test(opt.path)) {
                    throw new TypeError("option path is invalid");
                }
                str += "; Path=" + opt.path;
            }
            if (opt.expires) {
                var expires = opt.expires;
                if (!isDate(expires) || isNaN(expires.valueOf())) {
                    throw new TypeError("option expires is invalid");
                }
                str += "; Expires=" + expires.toUTCString();
            }
            if (opt.httpOnly) {
                str += "; HttpOnly";
            }
            if (opt.secure) {
                str += "; Secure";
            }
            if (opt.partitioned) {
                str += "; Partitioned";
            }
            if (opt.priority) {
                var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
                switch(priority){
                    case "low":
                        str += "; Priority=Low";
                        break;
                    case "medium":
                        str += "; Priority=Medium";
                        break;
                    case "high":
                        str += "; Priority=High";
                        break;
                    default:
                        throw new TypeError("option priority is invalid");
                }
            }
            if (opt.sameSite) {
                var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
                switch(sameSite){
                    case true:
                        str += "; SameSite=Strict";
                        break;
                    case "lax":
                        str += "; SameSite=Lax";
                        break;
                    case "strict":
                        str += "; SameSite=Strict";
                        break;
                    case "none":
                        str += "; SameSite=None";
                        break;
                    default:
                        throw new TypeError("option sameSite is invalid");
                }
            }
            return str;
        }
        function decode(str) {
            return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
        }
        function isDate(val) {
            return __toString.call(val) === "[object Date]";
        }
        function tryDecode(str, decode2) {
            try {
                return decode2(str);
            } catch (e) {
                return str;
            }
        }
    }
});
// source.js
var import_cookie = __toESM(require_cookie(), 1);
var source_default = import_cookie.default;
;
 /*! Bundled license information:

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/ }),
"[project]/node_modules/@msw/data/build/logger-C8Rm9JRM.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Logger",
    ()=>Logger
]);
//#region src/logger.ts
var Logger = class Logger {
    constructor(domain){
        this.domain = domain;
    }
    log(...args) {}
    warn(...args) {}
    trace(...args) {}
    extend(subdomain) {
        return new Logger(`${this.domain}] [${subdomain}`);
    }
};
;
}),
"[project]/node_modules/@msw/data/build/hooks-xbgk8a4G.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createHooksEmitter",
    ()=>createHooksEmitter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rettime$2f$build$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rettime/build/index.js [client] (ecmascript)");
;
//#region src/hooks.ts
function createHooksEmitter() {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rettime$2f$build$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Emitter"]();
}
;
}),
"[project]/node_modules/@msw/data/build/errors-CVsx5ebH.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "OperationError",
    ()=>OperationError,
    "OperationErrorCodes",
    ()=>OperationErrorCodes,
    "RelationError",
    ()=>RelationError,
    "RelationErrorCodes",
    ()=>RelationErrorCodes
]);
//#region src/errors.ts
let OperationErrorCodes = /* @__PURE__ */ function(OperationErrorCodes$1) {
    OperationErrorCodes$1["UNEXPECTED_ERROR"] = "UNEXPECTED_ERROR";
    OperationErrorCodes$1["INVALID_INITIAL_VALUES"] = "INVALID_INITIAL_VALUES";
    OperationErrorCodes$1["STRICT_QUERY_WITHOUT_RESULTS"] = "STRICT_QUERY_WITHOUT_RESULTS";
    return OperationErrorCodes$1;
}({});
var OperationError = class OperationError extends Error {
    static for(code) {
        return (message)=>{
            return new OperationError(message, code);
        };
    }
    constructor(message, code, cause){
        super(message);
        this.code = code;
        this.cause = cause;
    }
};
let RelationErrorCodes = /* @__PURE__ */ function(RelationErrorCodes$1) {
    RelationErrorCodes$1["RELATION_NOT_READY"] = "RELATION_NOT_READY";
    RelationErrorCodes$1["UNEXPECTED_SET_EXPRESSION"] = "UNEXPECTED_SET_EXPRESSION";
    RelationErrorCodes$1["INVALID_FOREIGN_RECORD"] = "INVALID_FOREIGN_RECORD";
    RelationErrorCodes$1["FORBIDDEN_UNIQUE_CREATE"] = "FORBIDDEN_UNIQUE_CREATE";
    RelationErrorCodes$1["FORBIDDEN_UNIQUE_UPDATE"] = "FORBIDDEN_UNIQUE_UPDATE";
    return RelationErrorCodes$1;
}({});
var RelationError = class RelationError extends Error {
    static for(code, details) {
        return (message)=>{
            return new RelationError(message, code, details);
        };
    }
    constructor(message, code, details){
        super(message);
        this.code = code;
        this.details = details;
    }
};
;
}),
"[project]/node_modules/@msw/data/build/collection-BJduKbwC.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Collection",
    ()=>Collection,
    "Many",
    ()=>Many,
    "Query",
    ()=>Query,
    "Relation",
    ()=>Relation,
    "cloneWithInternals",
    ()=>cloneWithInternals,
    "createRelationBuilder",
    ()=>createRelationBuilder,
    "definePropertyAtPath",
    ()=>definePropertyAtPath,
    "isObject",
    ()=>isObject,
    "isRecord",
    ()=>isRecord,
    "kCollectionId",
    ()=>kCollectionId,
    "kPrimaryKey",
    ()=>kPrimaryKey,
    "kRelationMap",
    ()=>kRelationMap,
    "sortResults",
    ()=>sortResults,
    "toDeepEntries",
    ()=>toDeepEntries
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$logger$2d$C8Rm9JRM$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msw/data/build/logger-C8Rm9JRM.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$hooks$2d$xbgk8a4G$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msw/data/build/hooks-xbgk8a4G.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msw/data/build/errors-CVsx5ebH.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$object$2f$get$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/object/get.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$object$2f$set$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/object/set.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$object$2f$unset$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/object/unset.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mutative$2f$dist$2f$mutative$2e$esm$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mutative/dist/mutative.esm.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/outvariant/lib/index.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rettime$2f$build$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rettime/build/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$predicate$2f$isEqual$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/predicate/isEqual.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$predicate$2f$isPlainObject$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/predicate/isPlainObject.mjs [client] (ecmascript)");
;
;
;
;
;
;
;
;
//#region src/utils.ts
/**
* Checks if the given value is a plain object.
*/ function isObject(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$predicate$2f$isPlainObject$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value);
}
/**
* Checks if the given value is a record object.
*/ function isRecord(value) {
    /**
	* @note Have a loose object check, allowing arrays, since records
	* might be root-level arrays.
	*/ return typeof value === "object" && value != null && kPrimaryKey in value;
}
function definePropertyAtPath(target, path, descriptor) {
    let deepTarget = target;
    const lastKey = path[path.length - 1];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"])(lastKey != null, "Failed to define a property at path \"%j\": expected the path to have at least one item", path);
    for (const key of path.slice(0, -1)){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"])(typeof deepTarget[key] === "object", "Failed to define property at path \"%j\": part \"%s\" is not an object", path, key);
        deepTarget = deepTarget[key];
    }
    Object.defineProperty(deepTarget, lastKey, descriptor);
}
function toDeepEntries(source, entryPredicate = ()=>true, parentPath = []) {
    return Reflect.ownKeys(source).flatMap((key)=>{
        const value = source[key];
        const path = parentPath.concat(key);
        if (entryPredicate(value, path)) {
            if (isObject(value)) return toDeepEntries(value, entryPredicate, path);
        }
        return [
            [
                path,
                value
            ]
        ];
    });
}
function cloneWithInternals(value, predicate) {
    const clone = structuredClone(value);
    const descriptors = Object.getOwnPropertyDescriptors(value);
    for (const key of Reflect.ownKeys(descriptors)){
        const descriptor = descriptors[key];
        if (predicate({
            key,
            descriptor
        }) ?? true) Object.defineProperty(clone, key, descriptor);
    }
    return clone;
}
//#endregion
//#region src/query.ts
var Query = class Query {
    #predicate;
    constructor(predicate){
        this.#predicate = predicate;
    }
    test(value) {
        return !!this.#predicate?.(value);
    }
    where(condition) {
        return new Query(Query.#and(this.#predicate, Query.#normalize(condition)));
    }
    and(...conditions) {
        return new Query(Query.#and(this.#predicate, ...conditions.map(Query.#normalize)));
    }
    or(...conditions) {
        return new Query(Query.#or(this.#predicate, ...conditions.map(Query.#normalize)));
    }
    static #normalize(condition) {
        if (condition instanceof Query) return condition.#predicate;
        if (typeof condition === "function") return condition;
        if (isObject(condition)) {
            function compileCondition(condition$1) {
                return (record)=>{
                    if (Array.isArray(record)) return record.every((item)=>compileCondition(condition$1)(item));
                    return Object.entries(condition$1).every(([key, selector])=>{
                        const actualValue = record[key];
                        if (typeof actualValue === "undefined") return false;
                        if (Array.isArray(actualValue)) return actualValue.every((value)=>{
                            return compileCondition(selector)(value);
                        });
                        if (isObject(actualValue)) return compileCondition(selector)(actualValue);
                        if (typeof selector === "function") return selector(actualValue);
                        return actualValue === selector;
                    });
                };
            }
            return compileCondition(condition);
        }
        throw new TypeError("Invalid condition type");
    }
    static #and(...predicates) {
        return (value)=>{
            return predicates.filter(Boolean).every((predicate)=>{
                return predicate?.(value);
            });
        };
    }
    static #or(...predicates) {
        return (value)=>{
            return predicates.filter(Boolean).some((predicate)=>{
                return predicate?.(value);
            });
        };
    }
};
//#endregion
//#region src/relation.ts
const createRelationBuilder = (ownerCollection)=>{
    return {
        one (foreignCollection, options) {
            return ()=>new One(ownerCollection, Array.isArray(foreignCollection) ? foreignCollection : [
                    foreignCollection
                ], options);
        },
        many (foreignCollection, options) {
            return ()=>new Many(ownerCollection, Array.isArray(foreignCollection) ? foreignCollection : [
                    foreignCollection
                ], options);
        }
    };
};
var Relation = class {
    #logger;
    #path;
    constructor(ownerCollection, foreignCollections, options = {}){
        this.ownerCollection = ownerCollection;
        this.foreignCollections = foreignCollections;
        this.options = options;
        this.#logger = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$logger$2d$C8Rm9JRM$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"]("Relation");
        this.#logger.log("creating relation:", {
            ownerCollection,
            foreignCollections,
            options
        });
        this.foreignKeys = /* @__PURE__ */ new Set();
    }
    get path() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"])(this.#path != null, "Failed to retrieve path for relation: relation is not initialized");
        return this.#path;
    }
    /**
	* Initializes the relation on the owner record.
	*/ initialize(record, path, initialValues) {
        this.#path = path;
        const serializedPath = path.join(".");
        this.#initializeRelation(path, record, initialValues);
        for (const foreignCollection of this.foreignCollections){
            foreignCollection.hooks.on("create", (event)=>{
                const { record: foreignRecord } = event.data;
                const foreignRelations = this.getRelationsToOwner(foreignRecord);
                for (const foreignRelation of foreignRelations){
                    const ownerRecords = this.ownerCollection.findMany((q)=>q.where((record$1)=>{
                            return foreignRelation.foreignKeys.has(record$1[kPrimaryKey]);
                        }));
                    for (const ownerRecord of ownerRecords)ownerRecord[kRelationMap].get(serializedPath).foreignKeys.add(foreignRecord[kPrimaryKey]);
                }
            });
            foreignCollection.hooks.on("delete", (event)=>{
                const { deletedRecord: deletedForeignRecord } = event.data;
                this.foreignKeys.delete(deletedForeignRecord[kPrimaryKey]);
                if (this.options.onDelete === "cascade") {
                    const foreignRelations = this.getRelationsToOwner(deletedForeignRecord);
                    this.ownerCollection.deleteMany((q)=>{
                        return q.where((record$1)=>{
                            return foreignRelations.some((foreignRelation)=>{
                                return foreignRelation.foreignKeys.has(record$1[kPrimaryKey]);
                            });
                        });
                    });
                }
            });
        }
        /**
		* @note Handle foreign record updates through the owner record in an early hook
		* because if such an update occurs, it must NOT translate to the owner "update" event
		* (the owner had no updates, it just updated a foreign record through itself).
		*
		* @example
		* await users.update(q, { data: { country: { code: 'uk' } } })
		*/ this.ownerCollection.hooks.earlyOn("update", (event)=>{
            const update = event.data;
            if (path.every((key, index)=>key === update.path[index]) && !isRecord(update.nextValue)) {
                event.preventDefault();
                event.stopImmediatePropagation();
                const foreignUpdatePath = update.path.slice(path.length);
                for (const foreignCollection of this.foreignCollections)foreignCollection.updateMany((q)=>{
                    return q.where((record$1)=>{
                        return this.foreignKeys.has(record$1[kPrimaryKey]);
                    });
                }, {
                    data (foreignRecord) {
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$object$2f$set$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["set"])(foreignRecord, foreignUpdatePath, update.nextValue);
                    }
                });
            }
        });
        /**
		* Handle owner updates where the relational property changes to another foreign record.
		*
		* @example
		* await users.update(q, { data: { country: await countries.create({}) } })
		*/ this.ownerCollection.hooks.on("update", (event)=>{
            const update = event.data;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$predicate$2f$isEqual$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isEqual"])(update.path, path) && isRecord(update.nextValue)) {
                event.preventDefault();
                if (this instanceof One) {
                    const foreignRelationsToDisassociate = this.foreignCollections.flatMap((foreignCollection)=>{
                        return foreignCollection.findMany((q)=>{
                            return q.where((record$1)=>{
                                return this.foreignKeys.has(record$1[kPrimaryKey]);
                            });
                        });
                    }).flatMap((record$1)=>this.getRelationsToOwner(record$1));
                    if (this.options.unique) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"].as(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RelationError"].for(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RelationErrorCodes"].FORBIDDEN_UNIQUE_UPDATE, this.#createErrorDetails()), foreignRelationsToDisassociate.length === 0, "Failed to update a unique relation at \"%s\": the foreign record is already associated with another owner", update.path.join("."));
                    for (const foreignRelation of foreignRelationsToDisassociate)foreignRelation.foreignKeys.delete(update.prevRecord[kPrimaryKey]);
                    const otherOwnersAssociatedWithForeignRecord = this.#getOtherOwnerForRecords([
                        update.nextValue
                    ]);
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"].as(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RelationError"].for(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RelationErrorCodes"].FORBIDDEN_UNIQUE_UPDATE, this.#createErrorDetails()), otherOwnersAssociatedWithForeignRecord == null, "Failed to update a unique relation at \"%s\": the foreign record is already associated with another owner", update.path.join("."));
                    this.foreignKeys.clear();
                }
                const foreignRecord = update.nextValue;
                this.foreignKeys.add(foreignRecord[kPrimaryKey]);
                for (const foreignRelation of this.getRelationsToOwner(foreignRecord))foreignRelation.foreignKeys.add(update.prevRecord[kPrimaryKey]);
            }
        });
    }
    #initializeRelation(path, record, initialValues) {
        const logger = this.#logger;
        const serializedPath = path.join(".");
        logger.log("owner record is being created:", {
            record,
            path,
            initialValues,
            ownerCollectionId: this.ownerCollection[kCollectionId],
            foreignCollectionIds: Array.from(this.foreignCollections)
        });
        const relationMap = record[kRelationMap];
        logger.log("owner relation map (before update):", relationMap);
        relationMap.set(serializedPath, this);
        logger.log("owner relation map (after update):", relationMap);
        const initialValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$object$2f$get$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["get"])(record, path);
        if (initialValue != null) {
            logger.log(`found initial value for "${serializedPath}" relation:`, initialValue);
            const initialForeignRecords = Array.prototype.concat([], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$object$2f$get$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["get"])(initialValues, path)).filter(Boolean);
            logger.log("all foreign entries:", initialForeignRecords);
            if (this.options.unique) {
                const isUnique = initialForeignRecords.flatMap((foreignRecord)=>{
                    return this.getRelationsToOwner(foreignRecord);
                }).every((relation)=>relation.foreignKeys.size === 0);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"].as(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RelationError"].for(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RelationErrorCodes"].FORBIDDEN_UNIQUE_CREATE, this.#createErrorDetails()), isUnique, `Failed to create a unique relation at "%s": the foreign record is already associated with another owner`, serializedPath);
                const otherOwnersAssociatedWithForeignRecord = this.#getOtherOwnerForRecords(initialForeignRecords);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"].as(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RelationError"].for(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RelationErrorCodes"].FORBIDDEN_UNIQUE_CREATE, this.#createErrorDetails()), otherOwnersAssociatedWithForeignRecord == null, "Failed to create a unique relation at \"%s\": the foreign record is already associated with another owner", serializedPath);
            }
            for (const foreignRecord of initialForeignRecords){
                const foreignKey = foreignRecord[kPrimaryKey];
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"].as(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RelationError"].for(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RelationErrorCodes"].INVALID_FOREIGN_RECORD, this.#createErrorDetails()), foreignKey != null, "Failed to store foreign record reference for \"%s\" relation: the referenced record (%j) is missing the primary key", serializedPath, foreignRecord);
                if (foreignKey != null) this.foreignKeys.add(foreignKey);
            }
            logger.log("updated foreign keys:", this.foreignKeys);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$object$2f$unset$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["unset"])(record, path);
        }
        definePropertyAtPath(record, path, {
            enumerable: true,
            configurable: true,
            get: ()=>{
                const returnValue = this.resolve(this.foreignKeys);
                logger.log(`resolving "${serializedPath}" for`, record, "result:", returnValue);
                if (typeof returnValue !== "undefined") return returnValue;
                /**
				* @note If the relational key is present in initial values
				* and is null, that means it's a nullable relation. Allow nulls.
				*/ if (initialValue === null) return null;
                return this.getDefaultValue();
            },
            set: ()=>{
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RelationError"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["format"])("Failed to set property \"%s\" on collection (%s): relational properties are read-only and can only be updated via collection updates", serializedPath, this.ownerCollection[kCollectionId]), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RelationErrorCodes"].UNEXPECTED_SET_EXPRESSION, this.#createErrorDetails());
            }
        });
        logger.log(`defined getter over "${serializedPath}"!`);
    }
    /**
	* Returns a list of relations from the given foreign record
	* to the owner collection. Takes `role` into account.
	*/ getRelationsToOwner(foreignRecord) {
        const result = [];
        for (const [, relation] of foreignRecord[kRelationMap])if (relation.foreignCollections.some((foreignCollection)=>{
            return foreignCollection[kCollectionId] === this.ownerCollection[kCollectionId];
        }) && relation.options.role === this.options.role) result.push(relation);
        return result;
    }
    #getOtherOwnerForRecords(foreignRecords) {
        const serializedPath = this.path.join(".");
        return this.ownerCollection.findFirst((q)=>{
            return q.where((otherOwner)=>{
                const otherOwnerRelation = otherOwner[kRelationMap].get(serializedPath);
                return foreignRecords.some((foreignRecord)=>{
                    return otherOwnerRelation.foreignKeys.has(foreignRecord[kPrimaryKey]);
                });
            });
        });
    }
    #createErrorDetails() {
        return {
            path: this.path,
            ownerCollection: this.ownerCollection,
            foreignCollections: this.foreignCollections,
            options: this.options
        };
    }
};
var One = class extends Relation {
    resolve(foreignKeys) {
        if (foreignKeys.size === 0) return;
        for (const foreignCollection of this.foreignCollections){
            const record = foreignCollection.findFirst((q)=>q.where((record$1)=>{
                    return record$1[kPrimaryKey] === foreignKeys.values().next().value;
                }));
            /**
			* @note `null` is a valid value for nullable relations.
			*/ if (typeof record !== "undefined") return record;
        }
    }
    getDefaultValue() {}
};
var Many = class extends Relation {
    resolve(foreignKeys) {
        if (foreignKeys.size === 0) return;
        return this.foreignCollections.flatMap((foreignCollection)=>{
            return foreignCollection.findMany((q)=>q.where((record)=>{
                    return foreignKeys.has(record[kPrimaryKey]);
                }));
        });
    }
    getDefaultValue() {
        return [];
    }
};
//#endregion
//#region src/sort.ts
function sortResults(sortOptions, data) {
    if (sortOptions.orderBy == null) return;
    const criteria = toDeepEntries(sortOptions.orderBy);
    data.sort((left, right)=>{
        for (const [path, sortDirection] of criteria){
            const leftValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$object$2f$get$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["get"])(left, path);
            const rightValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$object$2f$get$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["get"])(right, path);
            if (leftValue > rightValue) return sortDirection === "asc" ? 1 : -1;
            if (leftValue < rightValue) return sortDirection === "asc" ? -1 : 1;
        }
        return 0;
    });
}
//#endregion
//#region src/collection.ts
let collectionsCreated = 0;
const kCollectionId = Symbol("kCollectionId");
const kPrimaryKey = Symbol("kPrimaryKey");
const kRelationMap = Symbol("kRelationMap");
/**
* A collection of data.
* @example
* const users = new Collection({ schema: userSchema })
*/ var Collection = class {
    #records;
    #logger;
    constructor(options){
        this.options = options;
        this[kCollectionId] = this.#generateCollectionId();
        this.#logger = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$logger$2d$C8Rm9JRM$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"]("Collection").extend(this[kCollectionId]);
        this.#records = [];
        this.hooks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$hooks$2d$xbgk8a4G$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createHooksEmitter"])();
        this.options.extensions?.forEach((extension)=>extension.extend(this));
    }
    /**
	* Creates a new record with the given values.
	* @param initialValues Initial values for the new record.
	* @return The created record.
	*
	* @example
	* await users.create({ id: 1, name: 'John' })
	*/ async create(initialValues) {
        let logger = this.#logger.extend("create");
        logger.log("initial values:", initialValues);
        const { sanitizedInitialValues, restoreProperties } = this.#sanitizeInitialValues(initialValues);
        const validationResult = await this.options.schema["~standard"].validate(sanitizedInitialValues);
        if (validationResult.issues) {
            console.error(validationResult.issues);
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationError"]("Failed to create a new record with initial values: does not match the schema. Please see the schema validation errors above.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationErrorCodes"].INVALID_INITIAL_VALUES);
        }
        let record = validationResult.value;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"].as(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationError"].for(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationErrorCodes"].INVALID_INITIAL_VALUES), typeof record === "object", "Failed to create a record with initial values (%j): expected the record to be an object or an array", initialValues);
        restoreProperties(record);
        const primaryKey = isObject(initialValues) && initialValues[kPrimaryKey] || crypto.randomUUID();
        Object.defineProperties(record, {
            [kPrimaryKey]: {
                enumerable: false,
                configurable: false,
                value: primaryKey
            },
            [kRelationMap]: {
                enumerable: false,
                configurable: false,
                value: /* @__PURE__ */ new Map()
            }
        });
        logger = logger.extend(primaryKey);
        logger.log("symbols defined!", record[kRelationMap]);
        if (this.hooks.listenerCount("create") > 0) await this.hooks.emitAsPromise(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rettime$2f$build$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["TypedEvent"]("create", {
            data: {
                record,
                initialValues
            }
        }));
        logger.log("create hooks done!");
        this.#records.push(record);
        logger.log("create done!", record);
        return record;
    }
    /**
	* Creates multiple records using the given initial values factory.
	* @param count Number of records to create.
	* @param initialValuesFactory Factory function to generate initial values for each record.
	* @return Array of created records.
	*
	* @example
	* await users.createMany(5, (index) => ({ id: index + 1}))
	*/ async createMany(count, initialValuesFactory) {
        const pendingPromises = [];
        for(let i = 0; i < count; i++)pendingPromises.push(this.create(initialValuesFactory(i)));
        return await Promise.all(pendingPromises).catch((error)=>{
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationError"]("Failed to execute \"createMany\" on collection: unexpected error", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationErrorCodes"].UNEXPECTED_ERROR, error);
        });
    }
    /**
	* Returns the first record matching the query.
	* If no query is provided, returns the first record in the collection.
	* @example
	* users.findFirst((q) => q.where({ id: 123 }))
	*/ findFirst(predicate, options) {
        if (predicate == null) {
            const firstRecord = this.#records[0];
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"].as(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationError"].for(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationErrorCodes"].STRICT_QUERY_WITHOUT_RESULTS), options?.strict ? firstRecord != null : true, "Failed to execute \"findFirst\" on collection without a query: the collection is empty");
            return firstRecord;
        }
        const result = this.#query(predicate instanceof Query ? predicate : predicate(new Query())).next().value;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"].as(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationError"].for(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationErrorCodes"].STRICT_QUERY_WITHOUT_RESULTS), options?.strict ? result != null : true, "Failed to execute \"findFirst\" on collection: no record found matching the query");
        return result;
    }
    /**
	* Returns all records matching the query.
	* If no query is provided, returns all records in the collection.
	* @example
	* users.findMany((q) => q.where({ subscribed: false }))
	*/ findMany(predicate, options) {
        const query = predicate == null ? new Query(()=>true) : predicate instanceof Query ? predicate : predicate(new Query());
        const results = Array.from(this.#query(query, options)).filter((result)=>!!result);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"].as(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationError"].for(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationErrorCodes"].STRICT_QUERY_WITHOUT_RESULTS), options?.strict ? results.length > 0 : true, "Failed to execute \"findMany\" on collection: no records found matching the query");
        if (options?.orderBy) sortResults(options, results);
        return results;
    }
    /**
	* Updates the first record matching the query.
	* Returns the updated record.
	* @example
	* await users.update(
	*   (q) => q.where({ name: 'John' }),
	*   {
	*     data(user) {
	*       user.name = 'Johnatan'
	*     }
	*   }
	* )
	*/ async update(predicate, options) {
        const prevRecord = this.findFirst(isRecord(predicate) ? new Query((record)=>{
            return record[kPrimaryKey] === predicate[kPrimaryKey];
        }) : predicate);
        if (prevRecord == null) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"].as(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationError"].for(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationErrorCodes"].STRICT_QUERY_WITHOUT_RESULTS), !options.strict, "Failed to execute \"update\" on collection: no record found matching the query");
            return;
        }
        const nextRecord = await this.#produceRecord(prevRecord, options.data);
        this.#replaceRecord(prevRecord, nextRecord);
        return nextRecord;
    }
    /**
	* Updates all records matching the query.
	* Resolves to the list of updated records.
	* @example
	* await users.updateMany(
	*   (q) => q.where({ subscribed: false }),
	*   {
	*     data(user) {
	*       user.subscribed = true
	*     }
	*   }
	* )
	*/ async updateMany(predicate, options) {
        const prevRecords = this.findMany(predicate);
        if (prevRecords.length === 0) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"].as(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationError"].for(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationErrorCodes"].STRICT_QUERY_WITHOUT_RESULTS), !options.strict, "Failed to execute \"updateMany\" on collection: no records found matching the query");
            return [];
        }
        const nextRecords = [];
        for (const prevRecord of prevRecords){
            const nextRecord = await this.#produceRecord(prevRecord, options.data);
            this.#replaceRecord(prevRecord, nextRecord);
            nextRecords.push(nextRecord);
        }
        if (options.orderBy) sortResults(options, nextRecords);
        return nextRecords;
    }
    /**
	* Deletes the first record matching the query.
	* @example
	* users.delete((q) => q.where({ id: 123 }))
	*/ delete(predicate, options) {
        if (isRecord(predicate)) {
            this.#deleteRecord(predicate);
            return predicate;
        }
        const record = this.findFirst(predicate);
        if (record == null) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"].as(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationError"].for(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationErrorCodes"].STRICT_QUERY_WITHOUT_RESULTS), !options?.strict, "Failed to execute \"delete\" on collection: no record found matching the query");
            return;
        }
        this.#deleteRecord(record);
        return record;
    }
    /**
	* Deletes all records matching the query.
	* @example
	* users.deleteMany((q) => q.where({ subscribed: false }))
	*/ deleteMany(predicate, options) {
        /**
		* @note Do NOT forward the sorting options to the querying phase
		* so the results are returned in the order they are present in the store.
		* That way, we can delete them right-to-left correctly.
		*/ const records = this.findMany(predicate);
        for(let i = records.length - 1; i >= 0; i--)this.#deleteRecord(records[i]);
        if (records.length === 0) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"].as(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationError"].for(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OperationErrorCodes"].STRICT_QUERY_WITHOUT_RESULTS), !options?.strict, "Failed to execute \"deleteMany\" on collection: no records found matching the query");
            return [];
        }
        if (options?.orderBy) sortResults(options, records);
        return records;
    }
    /**
	* Returns the total number of records in this collection.
	* @example
	* const users = new Collection({ schema })
	* await users.create({ id: 1, name: 'John' })
	* users.count() // 1
	*/ count() {
        return this.#records.length;
    }
    /**
	* Returns a list of all records from this collection.
	*/ all() {
        /**
		* @note Preserve exact record references so they might be used
		* when querying (must contain primary keys).
		*/ return this.#records;
    }
    /**
	* Deletes all the records in this collection.
	*/ clear() {
        for (const record of this.#records)this.#deleteRecord(record);
        this.#records.length = 0;
    }
    /**
	* Defines relations for the records in this collection.
	* @example
	* users.defineRelations(({ many }) => ({
	*   posts: many(posts),
	* }))
	*/ defineRelations(resolver) {
        let logger = this.#logger.extend("defineRelations");
        logger.log("defining relations...");
        const relations = toDeepEntries(resolver(createRelationBuilder(this)));
        logger.log("relations declaration:", relations);
        const initializeRelations = (record, initialValues = record)=>{
            for (const [path, createRelation] of relations){
                logger.log(`initializing relation for "${path.join(".")}"...`);
                const relation = createRelation();
                relation.initialize(record, path, initialValues);
                logger.log("relation initialized!", relation);
            }
        };
        for (const record of this.#records)initializeRelations(record);
        this.hooks.earlyOn("create", (event)=>{
            initializeRelations(event.data.record, event.data.initialValues);
        });
    }
    /**
	* Sanitizes the given object so it can be accepted as the input to Standard Schema validation.
	* This removes getters to prevent potentially infinite object references in self-referencing
	* relations. This also drops the internal symbols but gives a function to restore them back.
	*/ #sanitizeInitialValues(initialValues) {
        const propertiesToRestore = [];
        const sanitize = (value, path = [])=>{
            if (Array.isArray(value)) return value.map((value$1, index)=>sanitize(value$1, path.concat(index)));
            if (isObject(value)) {
                const relations = isRecord(value) ? value[kRelationMap] : void 0;
                return Object.fromEntries(Reflect.ownKeys(value).map((key)=>{
                    const childValue = value[key];
                    const childPath = path.concat(key);
                    if (typeof key === "symbol") {
                        /**
						* @note Preserve primary keys on sanitized initial values.
						* Otherwise, internal symbols are stripped off and record references are lost.
						* This is curcial when handling relations for records that were created
						* before the relation was defined.
						*/ if (key === kPrimaryKey) propertiesToRestore.push({
                            path: childPath,
                            descriptor: Object.getOwnPropertyDescriptor(value, key)
                        });
                        return [
                            key,
                            childValue
                        ];
                    }
                    const relation = relations?.get(key);
                    if (relation && childValue != null) {
                        propertiesToRestore.push({
                            path: childPath,
                            descriptor: Object.getOwnPropertyDescriptor(value, key)
                        });
                        return [
                            key,
                            relation.getDefaultValue()
                        ];
                    }
                    return [
                        key,
                        sanitize(childValue, childPath)
                    ];
                }));
            }
            return value;
        };
        return {
            sanitizedInitialValues: sanitize(initialValues),
            restoreProperties (record) {
                for (const { path, descriptor } of propertiesToRestore)definePropertyAtPath(record, path, descriptor);
            }
        };
    }
    *#query(query, options = {
        take: Infinity
    }) {
        const { take, cursor, skip } = options;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"])(typeof skip !== "undefined" ? Number.isInteger(skip) && skip >= 0 : true, "Failed to query the collection: expected the \"skip\" pagination option to be a number larger or equal to 0 but got %j", skip);
        let taken = 0;
        let skipped = 0;
        const shouldTake = Math.abs(take ?? Infinity);
        const delta = take && take < 0 ? -1 : 1;
        let start = delta === 1 ? 0 : this.#records.length - 1;
        const end = delta === 1 ? this.#records.length : -1;
        if (cursor != null) {
            const cursorIndex = this.#records.findIndex((record)=>{
                return record[kPrimaryKey] === cursor[kPrimaryKey];
            });
            if (cursorIndex === -1) return;
            start = cursorIndex;
        }
        for(let i = start; i !== end; i += delta){
            const record = this.#records[i];
            if (query.test(record)) {
                if (skip != null) {
                    if (skipped < skip) {
                        skipped++;
                        continue;
                    }
                }
                yield record;
                taken++;
            }
            if (taken >= shouldTake) break;
        }
    }
    /**
	* Returns the index of the given record in this collection.
	* Performs a primary key-based lookup instead of a reference lookup
	* because certain references (like root-level arrays) might become stale
	* after updates, but will retain their primary keys.
	*/ #indexOf(record) {
        return this.#records.findIndex((existingRecord)=>{
            return existingRecord[kPrimaryKey] === record[kPrimaryKey];
        });
    }
    /**
	* Replaces the given record with the next version of it.
	*/ #replaceRecord(prevRecord, nextRecord) {
        const index = this.#indexOf(prevRecord);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"])(index !== -1, "Failed to replace record \"%j\" with \"%j\": previous record not found", prevRecord, nextRecord);
        this.#records[index] = nextRecord;
    }
    /**
	* Deletes the given record from the collection.
	*/ #deleteRecord(record) {
        const index = this.#indexOf(record);
        if (index !== -1) {
            const deleteEvent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rettime$2f$build$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["TypedEvent"]("delete", {
                data: {
                    deletedRecord: record
                }
            });
            this.hooks.emit(deleteEvent);
            if (!deleteEvent.defaultPrevented) this.#records.splice(index, 1);
        }
    }
    /**
	* Produces the next version of the given record by applying the `data` changes to it.
	* Re-applies the schema to the end record to ensure validity and apply user-defined transforms.
	*/ async #produceRecord(prevRecord, updateData) {
        const logger = this.#logger.extend("produceRecord");
        logger.log("updating the record with options:", prevRecord, updateData);
        /**
		* @note Clone the previous record, preserving the symbols (so it's considered a record)
		* but stripping off relational keys (getters) to preserve the values of foreign records
		* at the moment of update.
		*/ const frozenPrevRecord = cloneWithInternals(prevRecord, ({ key, descriptor })=>{
            return typeof key === "symbol" && descriptor.get == null;
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"])(isRecord(frozenPrevRecord), "Failed to update a record (%j): frozen previous record copy is not a record", prevRecord);
        const [maybeNextRecord, patches, inversePatches] = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mutative$2f$dist$2f$mutative$2e$esm$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["create"])(prevRecord, updateData, {
            strict: false,
            enablePatches: true
        });
        Object.defineProperties(maybeNextRecord, {
            [kPrimaryKey]: {
                value: prevRecord[kPrimaryKey],
                enumerable: false,
                configurable: false
            },
            [kRelationMap]: {
                value: prevRecord[kRelationMap],
                enumerable: false,
                configurable: false
            }
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"])(isRecord(maybeNextRecord), "Failed to update a record (%j): a record produced by the draft is not a record", prevRecord);
        const patchesToUndo = [];
        for(let i = 0; i < patches.length; i++){
            const patch = patches[i];
            if (!patch) continue;
            const updateEvent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rettime$2f$build$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["TypedEvent"]("update", {
                data: {
                    prevRecord: frozenPrevRecord,
                    nextRecord: maybeNextRecord,
                    path: patch.path,
                    prevValue: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$object$2f$get$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["get"])(prevRecord, patch.path),
                    nextValue: patch.value
                }
            });
            this.hooks.emit(updateEvent);
            if (updateEvent.defaultPrevented) {
                const inversePatch = inversePatches[i];
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["invariant"])(inversePatch != null, "Failed to update a record (%j): missing inverse patch at index %d", prevRecord, i);
                patchesToUndo.push(inversePatch);
            }
        }
        const nextRecord = patchesToUndo.length > 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mutative$2f$dist$2f$mutative$2e$esm$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["apply"])(maybeNextRecord, patchesToUndo) : maybeNextRecord;
        logger.log("re-applying the schema...");
        const { sanitizedInitialValues } = this.#sanitizeInitialValues(nextRecord);
        const validationResult = await this.options.schema["~standard"].validate(sanitizedInitialValues);
        if (validationResult.issues) {
            console.error(validationResult.issues);
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$outvariant$2f$lib$2f$index$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["InvariantError"]("Failed to update record (%j): resulting record does not match the schema", frozenPrevRecord);
        }
        const finalRecord = validationResult.value;
        logger.log("schema re-applied!");
        const descriptors = Object.getOwnPropertyDescriptors(prevRecord);
        for (const key of Reflect.ownKeys(descriptors)){
            const descriptor = descriptors[key];
            if (typeof key === "symbol" || typeof descriptor.get === "function") Object.defineProperty(finalRecord, key, descriptor);
        }
        return finalRecord;
    }
    /**
	* Returns a reproducible collection ID number based on the collection
	* creation order. Collection ID has to be reproducible across runtimes
	* to enable synchronization.
	*/ #generateCollectionId() {
        collectionsCreated++;
        const seed = 0;
        const value = collectionsCreated.toString();
        let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
        for(let i = 0, ch; i < value.length; i++){
            ch = value.charCodeAt(i);
            h1 = Math.imul(h1 ^ ch, 2654435761);
            h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);
        h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
        h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
        h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);
        return 4294967296 * (2097151 & h2) + (h1 >>> 0);
    }
};
;
}),
"[project]/node_modules/@msw/data/build/index.js [client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$logger$2d$C8Rm9JRM$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msw/data/build/logger-C8Rm9JRM.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$hooks$2d$xbgk8a4G$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msw/data/build/hooks-xbgk8a4G.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$collection$2d$BJduKbwC$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msw/data/build/collection-BJduKbwC.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msw$2f$data$2f$build$2f$errors$2d$CVsx5ebH$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msw/data/build/errors-CVsx5ebH.js [client] (ecmascript)");
;
;
;
;
;
}),
"[project]/node_modules/rettime/build/index.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Emitter",
    ()=>Emitter,
    "TypedEvent",
    ()=>TypedEvent
]);
const kDefaultPrevented = Symbol("kDefaultPrevented");
const kPropagationStopped = Symbol("kPropagationStopped");
const kImmediatePropagationStopped = Symbol("kImmediatePropagationStopped");
class TypedEvent extends MessageEvent {
    /**
   * @note Keep a placeholder property with the return type
   * because the type must be set somewhere in order to be
   * correctly associated and inferred from the event.
   */ #returnType;
    [kDefaultPrevented];
    [kPropagationStopped];
    [kImmediatePropagationStopped];
    constructor(...args){
        super(args[0], args[1]);
        this[kDefaultPrevented] = false;
    }
    get defaultPrevented() {
        return this[kDefaultPrevented];
    }
    preventDefault() {
        super.preventDefault();
        this[kDefaultPrevented] = true;
    }
    stopImmediatePropagation() {
        super.stopImmediatePropagation();
        this[kImmediatePropagationStopped] = true;
    }
}
const kListenerOptions = Symbol("kListenerOptions");
class Emitter {
    #listeners;
    constructor(){
        this.#listeners = {};
    }
    /**
   * Adds a listener for the given event type.
   *
   * @returns {AbortController} An `AbortController` that can be used to remove the listener.
   */ on(type, listener, options) {
        return this.#addListener(type, listener, options);
    }
    /**
   * Adds a one-time listener for the given event type.
   *
   * @returns {AbortController} An `AbortController` that can be used to remove the listener.
   */ once(type, listener, options) {
        return this.on(type, listener, {
            ...options || {},
            once: true
        });
    }
    /**
   * Prepends a listener for the given event type.
   *
   * @returns {AbortController} An `AbortController` that can be used to remove the listener.
   */ earlyOn(type, listener, options) {
        return this.#addListener(type, listener, options, "prepend");
    }
    /**
   * Prepends a one-time listener for the given event type.
   */ earlyOnce(type, listener, options) {
        return this.earlyOn(type, listener, {
            ...options || {},
            once: true
        });
    }
    /**
   * Emits the given typed event.
   *
   * @returns {boolean} Returns `true` if the event had any listeners, `false` otherwise.
   */ emit(event) {
        if (this.listenerCount(event.type) === 0) {
            return false;
        }
        const proxiedEvent = this.#proxyEvent(event);
        for (const listener of this.#listeners[event.type]){
            if (proxiedEvent.event[kPropagationStopped] != null && proxiedEvent.event[kPropagationStopped] !== this) {
                return false;
            }
            if (proxiedEvent.event[kImmediatePropagationStopped]) {
                break;
            }
            this.#callListener(proxiedEvent.event, listener);
        }
        proxiedEvent.revoke();
        return true;
    }
    /**
   * Emits the given typed event and returns a promise that resolves
   * when all the listeners for that event have settled.
   *
   * @returns {Promise<Array<Emitter.ListenerReturnType>>} A promise that resolves
   * with the return values of all listeners.
   */ async emitAsPromise(event) {
        if (this.listenerCount(event.type) === 0) {
            return [];
        }
        const pendingListeners = [];
        const proxiedEvent = this.#proxyEvent(event);
        for (const listener of this.#listeners[event.type]){
            if (proxiedEvent.event[kPropagationStopped] != null && proxiedEvent.event[kPropagationStopped] !== this) {
                return [];
            }
            if (proxiedEvent.event[kImmediatePropagationStopped]) {
                break;
            }
            pendingListeners.push(// Awaiting individual listeners guarantees their call order.
            await Promise.resolve(this.#callListener(proxiedEvent.event, listener)));
        }
        proxiedEvent.revoke();
        return Promise.allSettled(pendingListeners).then((results)=>{
            return results.map((result)=>result.status === "fulfilled" ? result.value : result.reason);
        });
    }
    /**
   * Emits the given event and returns a generator that yields
   * the result of each listener in the order of their registration.
   * This way, you stop exhausting the listeners once you get the expected value.
   */ *emitAsGenerator(event) {
        if (this.listenerCount(event.type) === 0) {
            return;
        }
        const proxiedEvent = this.#proxyEvent(event);
        for (const listener of this.#listeners[event.type]){
            if (proxiedEvent.event[kPropagationStopped] != null && proxiedEvent.event[kPropagationStopped] !== this) {
                return;
            }
            if (proxiedEvent.event[kImmediatePropagationStopped]) {
                break;
            }
            yield this.#callListener(proxiedEvent.event, listener);
        }
        proxiedEvent.revoke();
    }
    /**
   * Removes a listener for the given event type.
   */ removeListener(type, listener) {
        if (this.listenerCount(type) === 0) {
            return;
        }
        const nextListeners = [];
        for (const existingListener of this.#listeners[type]){
            if (existingListener !== listener) {
                nextListeners.push(existingListener);
            }
        }
        this.#listeners[type] = nextListeners;
    }
    /**
   * Removes all listeners for the given event type.
   * If no event type is provided, removes all existing listeners.
   */ removeAllListeners(type) {
        if (type == null) {
            this.#listeners = {};
            return;
        }
        this.#listeners[type] = [];
    }
    /**
   * Returns the list of listeners for the given event type.
   * If no even type is provided, returns all listeners.
   */ listeners(type) {
        if (type == null) {
            return Object.values(this.#listeners).flat();
        }
        return this.#listeners[type] || [];
    }
    /**
   * Returns the number of listeners for the given event type.
   * If no even type is provided, returns the total number of listeners.
   */ listenerCount(type) {
        return this.listeners(type).length;
    }
    #addListener(type, listener, options, insertMode = "append") {
        this.#listeners[type] ??= [];
        if (insertMode === "prepend") {
            this.#listeners[type].unshift(listener);
        } else {
            this.#listeners[type].push(listener);
        }
        if (options) {
            Object.defineProperty(listener, kListenerOptions, {
                value: options,
                enumerable: false,
                writable: false
            });
            if (options.signal) {
                options.signal.addEventListener("abort", ()=>{
                    this.removeListener(type, listener);
                }, {
                    once: true
                });
            }
        }
        return this;
    }
    #proxyEvent(event) {
        const { stopPropagation } = event;
        event.stopPropagation = new Proxy(event.stopPropagation, {
            apply: (target, thisArg, argArray)=>{
                event[kPropagationStopped] = this;
                return Reflect.apply(target, thisArg, argArray);
            }
        });
        return {
            event,
            revoke () {
                event.stopPropagation = stopPropagation;
            }
        };
    }
    #callListener(event, listener) {
        const returnValue = listener.call(this, event);
        if (listener[kListenerOptions]?.once) {
            this.removeListener(event.type, listener);
        }
        return returnValue;
    }
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/es-toolkit/dist/_internal/isUnsafeProperty.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isUnsafeProperty",
    ()=>isUnsafeProperty
]);
function isUnsafeProperty(key) {
    return key === '__proto__';
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/_internal/isDeepKey.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isDeepKey",
    ()=>isDeepKey
]);
function isDeepKey(key) {
    switch(typeof key){
        case 'number':
        case 'symbol':
            {
                return false;
            }
        case 'string':
            {
                return key.includes('.') || key.includes('[') || key.includes(']');
            }
    }
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/_internal/toKey.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "toKey",
    ()=>toKey
]);
function toKey(value) {
    if (typeof value === 'string' || typeof value === 'symbol') {
        return value;
    }
    if (Object.is(value?.valueOf?.(), -0)) {
        return '-0';
    }
    return String(value);
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/util/toString.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "toString",
    ()=>toString
]);
function toString(value) {
    if (value == null) {
        return '';
    }
    if (typeof value === 'string') {
        return value;
    }
    if (Array.isArray(value)) {
        return value.map(toString).join(',');
    }
    const result = String(value);
    if (result === '0' && Object.is(Number(value), -0)) {
        return '-0';
    }
    return result;
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/util/toPath.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "toPath",
    ()=>toPath
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$util$2f$toString$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/util/toString.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$toKey$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/_internal/toKey.mjs [client] (ecmascript)");
;
;
function toPath(deepKey) {
    if (Array.isArray(deepKey)) {
        return deepKey.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$toKey$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["toKey"]);
    }
    if (typeof deepKey === 'symbol') {
        return [
            deepKey
        ];
    }
    deepKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$util$2f$toString$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["toString"])(deepKey);
    const result = [];
    const length = deepKey.length;
    if (length === 0) {
        return result;
    }
    let index = 0;
    let key = '';
    let quoteChar = '';
    let bracket = false;
    if (deepKey.charCodeAt(0) === 46) {
        result.push('');
        index++;
    }
    while(index < length){
        const char = deepKey[index];
        if (quoteChar) {
            if (char === '\\' && index + 1 < length) {
                index++;
                key += deepKey[index];
            } else if (char === quoteChar) {
                quoteChar = '';
            } else {
                key += char;
            }
        } else if (bracket) {
            if (char === '"' || char === "'") {
                quoteChar = char;
            } else if (char === ']') {
                bracket = false;
                result.push(key);
                key = '';
            } else {
                key += char;
            }
        } else {
            if (char === '[') {
                bracket = true;
                if (key) {
                    result.push(key);
                    key = '';
                }
            } else if (char === '.') {
                if (key) {
                    result.push(key);
                    key = '';
                }
            } else {
                key += char;
            }
        }
        index++;
    }
    if (key) {
        result.push(key);
    }
    return result;
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/object/get.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "get",
    ()=>get
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$_internal$2f$isUnsafeProperty$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/_internal/isUnsafeProperty.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$isDeepKey$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/_internal/isDeepKey.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$toKey$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/_internal/toKey.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$util$2f$toPath$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/util/toPath.mjs [client] (ecmascript)");
;
;
;
;
function get(object, path, defaultValue) {
    if (object == null) {
        return defaultValue;
    }
    switch(typeof path){
        case 'string':
            {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$_internal$2f$isUnsafeProperty$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isUnsafeProperty"])(path)) {
                    return defaultValue;
                }
                const result = object[path];
                if (result === undefined) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$isDeepKey$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isDeepKey"])(path)) {
                        return get(object, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$util$2f$toPath$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["toPath"])(path), defaultValue);
                    } else {
                        return defaultValue;
                    }
                }
                return result;
            }
        case 'number':
        case 'symbol':
            {
                if (typeof path === 'number') {
                    path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$toKey$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["toKey"])(path);
                }
                const result = object[path];
                if (result === undefined) {
                    return defaultValue;
                }
                return result;
            }
        default:
            {
                if (Array.isArray(path)) {
                    return getWithPath(object, path, defaultValue);
                }
                if (Object.is(path?.valueOf(), -0)) {
                    path = '-0';
                } else {
                    path = String(path);
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$_internal$2f$isUnsafeProperty$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isUnsafeProperty"])(path)) {
                    return defaultValue;
                }
                const result = object[path];
                if (result === undefined) {
                    return defaultValue;
                }
                return result;
            }
    }
}
function getWithPath(object, path, defaultValue) {
    if (path.length === 0) {
        return defaultValue;
    }
    let current = object;
    for(let index = 0; index < path.length; index++){
        if (current == null) {
            return defaultValue;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$_internal$2f$isUnsafeProperty$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isUnsafeProperty"])(path[index])) {
            return defaultValue;
        }
        current = current[path[index]];
    }
    if (current === undefined) {
        return defaultValue;
    }
    return current;
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/util/eq.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "eq",
    ()=>eq
]);
function eq(value, other) {
    return value === other || Number.isNaN(value) && Number.isNaN(other);
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/_internal/assignValue.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "assignValue",
    ()=>assignValue
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$util$2f$eq$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/util/eq.mjs [client] (ecmascript)");
;
const assignValue = (object, key, value)=>{
    const objValue = object[key];
    if (!(Object.hasOwn(object, key) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$util$2f$eq$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["eq"])(objValue, value)) || value === undefined && !(key in object)) {
        object[key] = value;
    }
};
;
}),
"[project]/node_modules/es-toolkit/dist/compat/_internal/isIndex.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isIndex",
    ()=>isIndex
]);
const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length = Number.MAX_SAFE_INTEGER) {
    switch(typeof value){
        case 'number':
            {
                return Number.isInteger(value) && value >= 0 && value < length;
            }
        case 'symbol':
            {
                return false;
            }
        case 'string':
            {
                return IS_UNSIGNED_INTEGER.test(value);
            }
    }
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/predicate/isSymbol.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isSymbol",
    ()=>isSymbol
]);
function isSymbol(value) {
    return typeof value === 'symbol' || value instanceof Symbol;
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/_internal/isKey.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isKey",
    ()=>isKey
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$predicate$2f$isSymbol$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/predicate/isSymbol.mjs [client] (ecmascript)");
;
const regexIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
const regexIsPlainProp = /^\w*$/;
function isKey(value, object) {
    if (Array.isArray(value)) {
        return false;
    }
    if (typeof value === 'number' || typeof value === 'boolean' || value == null || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$predicate$2f$isSymbol$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isSymbol"])(value)) {
        return true;
    }
    return typeof value === 'string' && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value)) || object != null && Object.hasOwn(object, value);
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/predicate/isObject.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isObject",
    ()=>isObject
]);
function isObject(value) {
    return value !== null && (typeof value === 'object' || typeof value === 'function');
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/object/updateWith.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "updateWith",
    ()=>updateWith
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$_internal$2f$isUnsafeProperty$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/_internal/isUnsafeProperty.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$assignValue$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/_internal/assignValue.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$isIndex$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/_internal/isIndex.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$isKey$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/_internal/isKey.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$toKey$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/_internal/toKey.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$predicate$2f$isObject$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/predicate/isObject.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$util$2f$toPath$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/util/toPath.mjs [client] (ecmascript)");
;
;
;
;
;
;
;
function updateWith(obj, path, updater, customizer) {
    if (obj == null && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$predicate$2f$isObject$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isObject"])(obj)) {
        return obj;
    }
    const resolvedPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$isKey$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isKey"])(path, obj) ? [
        path
    ] : Array.isArray(path) ? path : typeof path === 'string' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$util$2f$toPath$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["toPath"])(path) : [
        path
    ];
    let current = obj;
    for(let i = 0; i < resolvedPath.length && current != null; i++){
        const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$toKey$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["toKey"])(resolvedPath[i]);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$_internal$2f$isUnsafeProperty$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isUnsafeProperty"])(key)) {
            continue;
        }
        let newValue;
        if (i === resolvedPath.length - 1) {
            newValue = updater(current[key]);
        } else {
            const objValue = current[key];
            const customizerResult = customizer?.(objValue, key, obj);
            newValue = customizerResult !== undefined ? customizerResult : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$predicate$2f$isObject$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isObject"])(objValue) ? objValue : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$isIndex$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isIndex"])(resolvedPath[i + 1]) ? [] : {};
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$assignValue$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["assignValue"])(current, key, newValue);
        current = current[key];
    }
    return obj;
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/object/set.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "set",
    ()=>set
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$object$2f$updateWith$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/object/updateWith.mjs [client] (ecmascript)");
;
function set(obj, path, value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$object$2f$updateWith$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["updateWith"])(obj, path, ()=>value, ()=>undefined);
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/object/unset.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "unset",
    ()=>unset
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$object$2f$get$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/object/get.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$_internal$2f$isUnsafeProperty$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/_internal/isUnsafeProperty.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$isDeepKey$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/_internal/isDeepKey.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$toKey$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/_internal/toKey.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$util$2f$toPath$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/util/toPath.mjs [client] (ecmascript)");
;
;
;
;
;
function unset(obj, path) {
    if (obj == null) {
        return true;
    }
    switch(typeof path){
        case 'symbol':
        case 'number':
        case 'object':
            {
                if (Array.isArray(path)) {
                    return unsetWithPath(obj, path);
                }
                if (typeof path === 'number') {
                    path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$toKey$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["toKey"])(path);
                } else if (typeof path === 'object') {
                    if (Object.is(path?.valueOf(), -0)) {
                        path = '-0';
                    } else {
                        path = String(path);
                    }
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$_internal$2f$isUnsafeProperty$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isUnsafeProperty"])(path)) {
                    return false;
                }
                if (obj?.[path] === undefined) {
                    return true;
                }
                try {
                    delete obj[path];
                    return true;
                } catch  {
                    return false;
                }
            }
        case 'string':
            {
                if (obj?.[path] === undefined && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$isDeepKey$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isDeepKey"])(path)) {
                    return unsetWithPath(obj, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$util$2f$toPath$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["toPath"])(path));
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$_internal$2f$isUnsafeProperty$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isUnsafeProperty"])(path)) {
                    return false;
                }
                try {
                    delete obj[path];
                    return true;
                } catch  {
                    return false;
                }
            }
    }
}
function unsetWithPath(obj, path) {
    const parent = path.length === 1 ? obj : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$object$2f$get$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["get"])(obj, path.slice(0, -1));
    const lastKey = path[path.length - 1];
    if (parent?.[lastKey] === undefined) {
        return true;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$_internal$2f$isUnsafeProperty$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isUnsafeProperty"])(lastKey)) {
        return false;
    }
    try {
        delete parent[lastKey];
        return true;
    } catch  {
        return false;
    }
}
;
}),
"[project]/node_modules/es-toolkit/dist/predicate/isPlainObject.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isPlainObject",
    ()=>isPlainObject
]);
function isPlainObject(value) {
    if (!value || typeof value !== 'object') {
        return false;
    }
    const proto = Object.getPrototypeOf(value);
    const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
    if (!hasObjectPrototype) {
        return false;
    }
    return Object.prototype.toString.call(value) === '[object Object]';
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getSymbols",
    ()=>getSymbols
]);
function getSymbols(object) {
    return Object.getOwnPropertySymbols(object).filter((symbol)=>Object.prototype.propertyIsEnumerable.call(object, symbol));
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/_internal/getTag.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getTag",
    ()=>getTag
]);
function getTag(value) {
    if (value == null) {
        return value === undefined ? '[object Undefined]' : '[object Null]';
    }
    return Object.prototype.toString.call(value);
}
;
}),
"[project]/node_modules/es-toolkit/dist/compat/_internal/tags.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "argumentsTag",
    ()=>argumentsTag,
    "arrayBufferTag",
    ()=>arrayBufferTag,
    "arrayTag",
    ()=>arrayTag,
    "bigInt64ArrayTag",
    ()=>bigInt64ArrayTag,
    "bigUint64ArrayTag",
    ()=>bigUint64ArrayTag,
    "booleanTag",
    ()=>booleanTag,
    "dataViewTag",
    ()=>dataViewTag,
    "dateTag",
    ()=>dateTag,
    "errorTag",
    ()=>errorTag,
    "float32ArrayTag",
    ()=>float32ArrayTag,
    "float64ArrayTag",
    ()=>float64ArrayTag,
    "functionTag",
    ()=>functionTag,
    "int16ArrayTag",
    ()=>int16ArrayTag,
    "int32ArrayTag",
    ()=>int32ArrayTag,
    "int8ArrayTag",
    ()=>int8ArrayTag,
    "mapTag",
    ()=>mapTag,
    "numberTag",
    ()=>numberTag,
    "objectTag",
    ()=>objectTag,
    "regexpTag",
    ()=>regexpTag,
    "setTag",
    ()=>setTag,
    "stringTag",
    ()=>stringTag,
    "symbolTag",
    ()=>symbolTag,
    "uint16ArrayTag",
    ()=>uint16ArrayTag,
    "uint32ArrayTag",
    ()=>uint32ArrayTag,
    "uint8ArrayTag",
    ()=>uint8ArrayTag,
    "uint8ClampedArrayTag",
    ()=>uint8ClampedArrayTag
]);
const regexpTag = '[object RegExp]';
const stringTag = '[object String]';
const numberTag = '[object Number]';
const booleanTag = '[object Boolean]';
const argumentsTag = '[object Arguments]';
const symbolTag = '[object Symbol]';
const dateTag = '[object Date]';
const mapTag = '[object Map]';
const setTag = '[object Set]';
const arrayTag = '[object Array]';
const functionTag = '[object Function]';
const arrayBufferTag = '[object ArrayBuffer]';
const objectTag = '[object Object]';
const errorTag = '[object Error]';
const dataViewTag = '[object DataView]';
const uint8ArrayTag = '[object Uint8Array]';
const uint8ClampedArrayTag = '[object Uint8ClampedArray]';
const uint16ArrayTag = '[object Uint16Array]';
const uint32ArrayTag = '[object Uint32Array]';
const bigUint64ArrayTag = '[object BigUint64Array]';
const int8ArrayTag = '[object Int8Array]';
const int16ArrayTag = '[object Int16Array]';
const int32ArrayTag = '[object Int32Array]';
const bigInt64ArrayTag = '[object BigInt64Array]';
const float32ArrayTag = '[object Float32Array]';
const float64ArrayTag = '[object Float64Array]';
;
}),
"[project]/node_modules/es-toolkit/dist/predicate/isEqualWith.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isEqualWith",
    ()=>isEqualWith
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$predicate$2f$isPlainObject$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/predicate/isPlainObject.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$getSymbols$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$getTag$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/_internal/getTag.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/_internal/tags.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$util$2f$eq$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/compat/util/eq.mjs [client] (ecmascript)");
;
;
;
;
;
function isEqualWith(a, b, areValuesEqual) {
    return isEqualWithImpl(a, b, undefined, undefined, undefined, undefined, areValuesEqual);
}
function isEqualWithImpl(a, b, property, aParent, bParent, stack, areValuesEqual) {
    const result = areValuesEqual(a, b, property, aParent, bParent, stack);
    if (result !== undefined) {
        return result;
    }
    if (typeof a === typeof b) {
        switch(typeof a){
            case 'bigint':
            case 'string':
            case 'boolean':
            case 'symbol':
            case 'undefined':
                {
                    return a === b;
                }
            case 'number':
                {
                    return a === b || Object.is(a, b);
                }
            case 'function':
                {
                    return a === b;
                }
            case 'object':
                {
                    return areObjectsEqual(a, b, stack, areValuesEqual);
                }
        }
    }
    return areObjectsEqual(a, b, stack, areValuesEqual);
}
function areObjectsEqual(a, b, stack, areValuesEqual) {
    if (Object.is(a, b)) {
        return true;
    }
    let aTag = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$getTag$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getTag"])(a);
    let bTag = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$getTag$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getTag"])(b);
    if (aTag === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["argumentsTag"]) {
        aTag = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["objectTag"];
    }
    if (bTag === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["argumentsTag"]) {
        bTag = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["objectTag"];
    }
    if (aTag !== bTag) {
        return false;
    }
    switch(aTag){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["stringTag"]:
            return a.toString() === b.toString();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["numberTag"]:
            {
                const x = a.valueOf();
                const y = b.valueOf();
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$util$2f$eq$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["eq"])(x, y);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["booleanTag"]:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["dateTag"]:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["symbolTag"]:
            return Object.is(a.valueOf(), b.valueOf());
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["regexpTag"]:
            {
                return a.source === b.source && a.flags === b.flags;
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["functionTag"]:
            {
                return a === b;
            }
    }
    stack = stack ?? new Map();
    const aStack = stack.get(a);
    const bStack = stack.get(b);
    if (aStack != null && bStack != null) {
        return aStack === b;
    }
    stack.set(a, b);
    stack.set(b, a);
    try {
        switch(aTag){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["mapTag"]:
                {
                    if (a.size !== b.size) {
                        return false;
                    }
                    for (const [key, value] of a.entries()){
                        if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a, b, stack, areValuesEqual)) {
                            return false;
                        }
                    }
                    return true;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["setTag"]:
                {
                    if (a.size !== b.size) {
                        return false;
                    }
                    const aValues = Array.from(a.values());
                    const bValues = Array.from(b.values());
                    for(let i = 0; i < aValues.length; i++){
                        const aValue = aValues[i];
                        const index = bValues.findIndex((bValue)=>{
                            return isEqualWithImpl(aValue, bValue, undefined, a, b, stack, areValuesEqual);
                        });
                        if (index === -1) {
                            return false;
                        }
                        bValues.splice(index, 1);
                    }
                    return true;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["arrayTag"]:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["uint8ArrayTag"]:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["uint8ClampedArrayTag"]:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["uint16ArrayTag"]:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["uint32ArrayTag"]:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["bigUint64ArrayTag"]:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["int8ArrayTag"]:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["int16ArrayTag"]:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["int32ArrayTag"]:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["bigInt64ArrayTag"]:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["float32ArrayTag"]:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["float64ArrayTag"]:
                {
                    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"] !== 'undefined' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(a) !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(b)) {
                        return false;
                    }
                    if (a.length !== b.length) {
                        return false;
                    }
                    for(let i = 0; i < a.length; i++){
                        if (!isEqualWithImpl(a[i], b[i], i, a, b, stack, areValuesEqual)) {
                            return false;
                        }
                    }
                    return true;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["arrayBufferTag"]:
                {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["dataViewTag"]:
                {
                    if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {
                        return false;
                    }
                    return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["errorTag"]:
                {
                    return a.name === b.name && a.message === b.message;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$tags$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["objectTag"]:
                {
                    const areEqualInstances = areObjectsEqual(a.constructor, b.constructor, stack, areValuesEqual) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$predicate$2f$isPlainObject$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isPlainObject"])(a) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$predicate$2f$isPlainObject$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isPlainObject"])(b);
                    if (!areEqualInstances) {
                        return false;
                    }
                    const aKeys = [
                        ...Object.keys(a),
                        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$getSymbols$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSymbols"])(a)
                    ];
                    const bKeys = [
                        ...Object.keys(b),
                        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$compat$2f$_internal$2f$getSymbols$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSymbols"])(b)
                    ];
                    if (aKeys.length !== bKeys.length) {
                        return false;
                    }
                    for(let i = 0; i < aKeys.length; i++){
                        const propKey = aKeys[i];
                        const aProp = a[propKey];
                        if (!Object.hasOwn(b, propKey)) {
                            return false;
                        }
                        const bProp = b[propKey];
                        if (!isEqualWithImpl(aProp, bProp, propKey, a, b, stack, areValuesEqual)) {
                            return false;
                        }
                    }
                    return true;
                }
            default:
                {
                    return false;
                }
        }
    } finally{
        stack.delete(a);
        stack.delete(b);
    }
}
;
}),
"[project]/node_modules/es-toolkit/dist/function/noop.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "noop",
    ()=>noop
]);
function noop() {}
;
}),
"[project]/node_modules/es-toolkit/dist/predicate/isEqual.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isEqual",
    ()=>isEqual
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$predicate$2f$isEqualWith$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/predicate/isEqualWith.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$function$2f$noop$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/es-toolkit/dist/function/noop.mjs [client] (ecmascript)");
;
;
function isEqual(a, b) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$predicate$2f$isEqualWith$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isEqualWith"])(a, b, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$es$2d$toolkit$2f$dist$2f$function$2f$noop$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["noop"]);
}
;
}),
"[project]/node_modules/mutative/dist/mutative.esm.mjs [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "apply",
    ()=>apply,
    "castDraft",
    ()=>castDraft,
    "castImmutable",
    ()=>castImmutable,
    "castMutable",
    ()=>castMutable,
    "create",
    ()=>create,
    "current",
    ()=>current,
    "isDraft",
    ()=>isDraft,
    "isDraftable",
    ()=>isDraftable,
    "makeCreator",
    ()=>makeCreator,
    "markSimpleObject",
    ()=>markSimpleObject,
    "original",
    ()=>original,
    "rawReturn",
    ()=>rawReturn,
    "unsafe",
    ()=>unsafe
]);
const Operation = {
    Remove: 'remove',
    Replace: 'replace',
    Add: 'add'
};
// Don't use `Symbol()` just for 3rd party access the draft
const PROXY_DRAFT = Symbol.for('__MUTATIVE_PROXY_DRAFT__');
const RAW_RETURN_SYMBOL = Symbol('__MUTATIVE_RAW_RETURN_SYMBOL__');
const iteratorSymbol = Symbol.iterator;
const dataTypes = {
    mutable: 'mutable',
    immutable: 'immutable'
};
const internal = {};
function has(target, key) {
    return target instanceof Map ? target.has(key) : Object.prototype.hasOwnProperty.call(target, key);
}
function getDescriptor(target, key) {
    if (key in target) {
        let prototype = Reflect.getPrototypeOf(target);
        while(prototype){
            const descriptor = Reflect.getOwnPropertyDescriptor(prototype, key);
            if (descriptor) return descriptor;
            prototype = Reflect.getPrototypeOf(prototype);
        }
    }
    return;
}
function isBaseSetInstance(obj) {
    return Object.getPrototypeOf(obj) === Set.prototype;
}
function isBaseMapInstance(obj) {
    return Object.getPrototypeOf(obj) === Map.prototype;
}
function latest(proxyDraft) {
    var _a;
    return (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original;
}
/**
 * Check if the value is a draft
 */ function isDraft(target) {
    return !!getProxyDraft(target);
}
function getProxyDraft(value) {
    if (typeof value !== 'object') return null;
    return value === null || value === void 0 ? void 0 : value[PROXY_DRAFT];
}
function getValue(value) {
    var _a;
    const proxyDraft = getProxyDraft(value);
    return proxyDraft ? (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original : value;
}
/**
 * Check if a value is draftable
 */ function isDraftable(value, options) {
    if (!value || typeof value !== 'object') return false;
    let markResult;
    return Object.getPrototypeOf(value) === Object.prototype || Array.isArray(value) || value instanceof Map || value instanceof Set || !!(options === null || options === void 0 ? void 0 : options.mark) && ((markResult = options.mark(value, dataTypes)) === dataTypes.immutable || typeof markResult === 'function');
}
function getPath(target, path = []) {
    if (Object.hasOwnProperty.call(target, 'key')) {
        // check if the parent is a draft and the original value is not equal to the current value
        const parentCopy = target.parent.copy;
        const proxyDraft = getProxyDraft(get(parentCopy, target.key));
        if (proxyDraft !== null && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== target.original) {
            return null;
        }
        const isSet = target.parent.type === 3 /* DraftType.Set */ ;
        const key = isSet ? Array.from(target.parent.setMap.keys()).indexOf(target.key) : target.key;
        // check if the key is still in the next state parent
        if (!(isSet && parentCopy.size > key || has(parentCopy, key))) return null;
        path.push(key);
    }
    if (target.parent) {
        return getPath(target.parent, path);
    }
    // `target` is root draft.
    path.reverse();
    try {
        // check if the path is valid
        resolvePath(target.copy, path);
    } catch (e) {
        return null;
    }
    return path;
}
function getType(target) {
    if (Array.isArray(target)) return 1 /* DraftType.Array */ ;
    if (target instanceof Map) return 2 /* DraftType.Map */ ;
    if (target instanceof Set) return 3 /* DraftType.Set */ ;
    return 0 /* DraftType.Object */ ;
}
function get(target, key) {
    return getType(target) === 2 /* DraftType.Map */  ? target.get(key) : target[key];
}
function set(target, key, value) {
    const type = getType(target);
    if (type === 2 /* DraftType.Map */ ) {
        target.set(key, value);
    } else {
        target[key] = value;
    }
}
function peek(target, key) {
    const state = getProxyDraft(target);
    const source = state ? latest(state) : target;
    return source[key];
}
function isEqual(x, y) {
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}
function revokeProxy(proxyDraft) {
    if (!proxyDraft) return;
    while(proxyDraft.finalities.revoke.length > 0){
        const revoke = proxyDraft.finalities.revoke.pop();
        revoke();
    }
}
// handle JSON Pointer path with spec https://www.rfc-editor.org/rfc/rfc6901
function escapePath(path, pathAsArray) {
    return pathAsArray ? path : [
        ''
    ].concat(path).map((_item)=>{
        const item = `${_item}`;
        if (item.indexOf('/') === -1 && item.indexOf('~') === -1) return item;
        return item.replace(/~/g, '~0').replace(/\//g, '~1');
    }).join('/');
}
function unescapePath(path) {
    if (Array.isArray(path)) return path;
    return path.split('/').map((_item)=>_item.replace(/~1/g, '/').replace(/~0/g, '~')).slice(1);
}
function resolvePath(base, path) {
    for(let index = 0; index < path.length - 1; index += 1){
        const key = path[index];
        // use `index` in Set draft
        base = get(getType(base) === 3 /* DraftType.Set */  ? Array.from(base) : base, key);
        if (typeof base !== 'object') {
            throw new Error(`Cannot resolve patch at '${path.join('/')}'.`);
        }
    }
    return base;
}
function strictCopy(target) {
    const copy = Object.create(Object.getPrototypeOf(target));
    Reflect.ownKeys(target).forEach((key)=>{
        let desc = Reflect.getOwnPropertyDescriptor(target, key);
        if (desc.enumerable && desc.configurable && desc.writable) {
            copy[key] = target[key];
            return;
        }
        // for freeze
        if (!desc.writable) {
            desc.writable = true;
            desc.configurable = true;
        }
        if (desc.get || desc.set) desc = {
            configurable: true,
            writable: true,
            enumerable: desc.enumerable,
            value: target[key]
        };
        Reflect.defineProperty(copy, key, desc);
    });
    return copy;
}
const propIsEnum = Object.prototype.propertyIsEnumerable;
function shallowCopy(original, options) {
    let markResult;
    if (Array.isArray(original)) {
        return Array.prototype.concat.call(original);
    } else if (original instanceof Set) {
        if (!isBaseSetInstance(original)) {
            const SubClass = Object.getPrototypeOf(original).constructor;
            return new SubClass(original.values());
        }
        return Set.prototype.difference ? Set.prototype.difference.call(original, new Set()) : new Set(original.values());
    } else if (original instanceof Map) {
        if (!isBaseMapInstance(original)) {
            const SubClass = Object.getPrototypeOf(original).constructor;
            return new SubClass(original);
        }
        return new Map(original);
    } else if ((options === null || options === void 0 ? void 0 : options.mark) && (markResult = options.mark(original, dataTypes), markResult !== undefined) && markResult !== dataTypes.mutable) {
        if (markResult === dataTypes.immutable) {
            return strictCopy(original);
        } else if (typeof markResult === 'function') {
            if (options.enablePatches || options.enableAutoFreeze) {
                throw new Error(`You can't use mark and patches or auto freeze together.`);
            }
            return markResult();
        }
        throw new Error(`Unsupported mark result: ${markResult}`);
    } else if (typeof original === 'object' && Object.getPrototypeOf(original) === Object.prototype) {
        // For best performance with shallow copies,
        // don't use `Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));` by default.
        const copy = {};
        Object.keys(original).forEach((key)=>{
            copy[key] = original[key];
        });
        Object.getOwnPropertySymbols(original).forEach((key)=>{
            if (propIsEnum.call(original, key)) {
                copy[key] = original[key];
            }
        });
        return copy;
    } else {
        throw new Error(`Please check mark() to ensure that it is a stable marker draftable function.`);
    }
}
function ensureShallowCopy(target) {
    if (target.copy) return;
    target.copy = shallowCopy(target.original, target.options);
}
function deepClone(target) {
    if (!isDraftable(target)) return getValue(target);
    if (Array.isArray(target)) return target.map(deepClone);
    if (target instanceof Map) {
        const iterable = Array.from(target.entries()).map(([k, v])=>[
                k,
                deepClone(v)
            ]);
        if (!isBaseMapInstance(target)) {
            const SubClass = Object.getPrototypeOf(target).constructor;
            return new SubClass(iterable);
        }
        return new Map(iterable);
    }
    if (target instanceof Set) {
        const iterable = Array.from(target).map(deepClone);
        if (!isBaseSetInstance(target)) {
            const SubClass = Object.getPrototypeOf(target).constructor;
            return new SubClass(iterable);
        }
        return new Set(iterable);
    }
    const copy = Object.create(Object.getPrototypeOf(target));
    for(const key in target)copy[key] = deepClone(target[key]);
    return copy;
}
function cloneIfNeeded(target) {
    return isDraft(target) ? deepClone(target) : target;
}
function markChanged(proxyDraft) {
    var _a;
    proxyDraft.assignedMap = (_a = proxyDraft.assignedMap) !== null && _a !== void 0 ? _a : new Map();
    if (!proxyDraft.operated) {
        proxyDraft.operated = true;
        if (proxyDraft.parent) {
            markChanged(proxyDraft.parent);
        }
    }
}
function throwFrozenError() {
    throw new Error('Cannot modify frozen object');
}
function deepFreeze(target, subKey, updatedValues, stack, keys) {
    {
        updatedValues = updatedValues !== null && updatedValues !== void 0 ? updatedValues : new WeakMap();
        stack = stack !== null && stack !== void 0 ? stack : [];
        keys = keys !== null && keys !== void 0 ? keys : [];
        const value = updatedValues.has(target) ? updatedValues.get(target) : target;
        if (stack.length > 0) {
            const index = stack.indexOf(value);
            if (value && typeof value === 'object' && index !== -1) {
                if (stack[0] === value) {
                    throw new Error(`Forbids circular reference`);
                }
                throw new Error(`Forbids circular reference: ~/${keys.slice(0, index).map((key, index)=>{
                    if (typeof key === 'symbol') return `[${key.toString()}]`;
                    const parent = stack[index];
                    if (typeof key === 'object' && (parent instanceof Map || parent instanceof Set)) return Array.from(parent.keys()).indexOf(key);
                    return key;
                }).join('/')}`);
            }
            stack.push(value);
            keys.push(subKey);
        } else {
            stack.push(value);
        }
    }
    if (Object.isFrozen(target) || isDraft(target)) {
        {
            stack.pop();
            keys.pop();
        }
        return;
    }
    const type = getType(target);
    switch(type){
        case 2 /* DraftType.Map */ :
            for (const [key, value] of target){
                deepFreeze(key, key, updatedValues, stack, keys);
                deepFreeze(value, key, updatedValues, stack, keys);
            }
            target.set = target.clear = target.delete = throwFrozenError;
            break;
        case 3 /* DraftType.Set */ :
            for (const value of target){
                deepFreeze(value, value, updatedValues, stack, keys);
            }
            target.add = target.clear = target.delete = throwFrozenError;
            break;
        case 1 /* DraftType.Array */ :
            Object.freeze(target);
            let index = 0;
            for (const value of target){
                deepFreeze(value, index, updatedValues, stack, keys);
                index += 1;
            }
            break;
        default:
            Object.freeze(target);
            // ignore non-enumerable or symbol properties
            Object.keys(target).forEach((name)=>{
                const value = target[name];
                deepFreeze(value, name, updatedValues, stack, keys);
            });
    }
    {
        stack.pop();
        keys.pop();
    }
}
function forEach(target, iter) {
    const type = getType(target);
    if (type === 0 /* DraftType.Object */ ) {
        Reflect.ownKeys(target).forEach((key)=>{
            iter(key, target[key], target);
        });
    } else if (type === 1 /* DraftType.Array */ ) {
        let index = 0;
        for (const entry of target){
            iter(index, entry, target);
            index += 1;
        }
    } else {
        target.forEach((entry, index)=>iter(index, entry, target));
    }
}
function handleValue(target, handledSet, options) {
    if (isDraft(target) || !isDraftable(target, options) || handledSet.has(target) || Object.isFrozen(target)) return;
    const isSet = target instanceof Set;
    const setMap = isSet ? new Map() : undefined;
    handledSet.add(target);
    forEach(target, (key, value)=>{
        var _a;
        if (isDraft(value)) {
            const proxyDraft = getProxyDraft(value);
            ensureShallowCopy(proxyDraft);
            // A draft where a child node has been changed, or assigned a value
            const updatedValue = ((_a = proxyDraft.assignedMap) === null || _a === void 0 ? void 0 : _a.size) || proxyDraft.operated ? proxyDraft.copy : proxyDraft.original;
            // final update value
            set(isSet ? setMap : target, key, updatedValue);
        } else {
            handleValue(value, handledSet, options);
        }
    });
    if (setMap) {
        const set = target;
        const values = Array.from(set);
        set.clear();
        values.forEach((value)=>{
            set.add(setMap.has(value) ? setMap.get(value) : value);
        });
    }
}
function finalizeAssigned(proxyDraft, key) {
    // handle the draftable assigned values and the value is not a draft
    const copy = proxyDraft.type === 3 /* DraftType.Set */  ? proxyDraft.setMap : proxyDraft.copy;
    if (proxyDraft.finalities.revoke.length > 1 && proxyDraft.assignedMap.get(key) && copy) {
        handleValue(get(copy, key), proxyDraft.finalities.handledSet, proxyDraft.options);
    }
}
function finalizeSetValue(target) {
    if (target.type === 3 /* DraftType.Set */  && target.copy) {
        target.copy.clear();
        target.setMap.forEach((value)=>{
            target.copy.add(getValue(value));
        });
    }
}
function finalizePatches(target, generatePatches, patches, inversePatches) {
    const shouldFinalize = target.operated && target.assignedMap && target.assignedMap.size > 0 && !target.finalized;
    if (shouldFinalize) {
        if (patches && inversePatches) {
            const basePath = getPath(target);
            if (basePath) {
                generatePatches(target, basePath, patches, inversePatches);
            }
        }
        target.finalized = true;
    }
}
function markFinalization(target, key, value, generatePatches) {
    const proxyDraft = getProxyDraft(value);
    if (proxyDraft) {
        // !case: assign the draft value
        if (!proxyDraft.callbacks) {
            proxyDraft.callbacks = [];
        }
        proxyDraft.callbacks.push((patches, inversePatches)=>{
            var _a;
            const copy = target.type === 3 /* DraftType.Set */  ? target.setMap : target.copy;
            if (isEqual(get(copy, key), value)) {
                let updatedValue = proxyDraft.original;
                if (proxyDraft.copy) {
                    updatedValue = proxyDraft.copy;
                }
                finalizeSetValue(target);
                finalizePatches(target, generatePatches, patches, inversePatches);
                if (target.options.enableAutoFreeze) {
                    target.options.updatedValues = (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();
                    target.options.updatedValues.set(updatedValue, proxyDraft.original);
                }
                // final update value
                set(copy, key, updatedValue);
            }
        });
        if (target.options.enableAutoFreeze) {
            // !case: assign the draft value in cross draft tree
            if (proxyDraft.finalities !== target.finalities) {
                target.options.enableAutoFreeze = false;
            }
        }
    }
    if (isDraftable(value, target.options)) {
        // !case: assign the non-draft value
        target.finalities.draft.push(()=>{
            const copy = target.type === 3 /* DraftType.Set */  ? target.setMap : target.copy;
            if (isEqual(get(copy, key), value)) {
                finalizeAssigned(target, key);
            }
        });
    }
}
function generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray) {
    let { original, assignedMap, options } = proxyState;
    let copy = proxyState.copy;
    if (copy.length < original.length) {
        [original, copy] = [
            copy,
            original
        ];
        [patches, inversePatches] = [
            inversePatches,
            patches
        ];
    }
    for(let index = 0; index < original.length; index += 1){
        if (assignedMap.get(index.toString()) && copy[index] !== original[index]) {
            const _path = basePath.concat([
                index
            ]);
            const path = escapePath(_path, pathAsArray);
            patches.push({
                op: Operation.Replace,
                path,
                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
                value: cloneIfNeeded(copy[index])
            });
            inversePatches.push({
                op: Operation.Replace,
                path,
                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
                value: cloneIfNeeded(original[index])
            });
        }
    }
    for(let index = original.length; index < copy.length; index += 1){
        const _path = basePath.concat([
            index
        ]);
        const path = escapePath(_path, pathAsArray);
        patches.push({
            op: Operation.Add,
            path,
            // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
            value: cloneIfNeeded(copy[index])
        });
    }
    if (original.length < copy.length) {
        // https://www.rfc-editor.org/rfc/rfc6902#appendix-A.4
        // For performance, here we only generate an operation that replaces the length of the array,
        // which is inconsistent with JSON Patch specification
        const { arrayLengthAssignment = true } = options.enablePatches;
        if (arrayLengthAssignment) {
            const _path = basePath.concat([
                'length'
            ]);
            const path = escapePath(_path, pathAsArray);
            inversePatches.push({
                op: Operation.Replace,
                path,
                value: original.length
            });
        } else {
            for(let index = copy.length; original.length < index; index -= 1){
                const _path = basePath.concat([
                    index - 1
                ]);
                const path = escapePath(_path, pathAsArray);
                inversePatches.push({
                    op: Operation.Remove,
                    path
                });
            }
        }
    }
}
function generatePatchesFromAssigned({ original, copy, assignedMap }, basePath, patches, inversePatches, pathAsArray) {
    assignedMap.forEach((assignedValue, key)=>{
        const originalValue = get(original, key);
        const value = cloneIfNeeded(get(copy, key));
        const op = !assignedValue ? Operation.Remove : has(original, key) ? Operation.Replace : Operation.Add;
        if (isEqual(originalValue, value) && op === Operation.Replace) return;
        const _path = basePath.concat(key);
        const path = escapePath(_path, pathAsArray);
        patches.push(op === Operation.Remove ? {
            op,
            path
        } : {
            op,
            path,
            value
        });
        inversePatches.push(op === Operation.Add ? {
            op: Operation.Remove,
            path
        } : op === Operation.Remove ? {
            op: Operation.Add,
            path,
            value: originalValue
        } : {
            op: Operation.Replace,
            path,
            value: originalValue
        });
    });
}
function generateSetPatches({ original, copy }, basePath, patches, inversePatches, pathAsArray) {
    let index = 0;
    original.forEach((value)=>{
        if (!copy.has(value)) {
            const _path = basePath.concat([
                index
            ]);
            const path = escapePath(_path, pathAsArray);
            patches.push({
                op: Operation.Remove,
                path,
                value
            });
            inversePatches.unshift({
                op: Operation.Add,
                path,
                value
            });
        }
        index += 1;
    });
    index = 0;
    copy.forEach((value)=>{
        if (!original.has(value)) {
            const _path = basePath.concat([
                index
            ]);
            const path = escapePath(_path, pathAsArray);
            patches.push({
                op: Operation.Add,
                path,
                value
            });
            inversePatches.unshift({
                op: Operation.Remove,
                path,
                value
            });
        }
        index += 1;
    });
}
function generatePatches(proxyState, basePath, patches, inversePatches) {
    const { pathAsArray = true } = proxyState.options.enablePatches;
    switch(proxyState.type){
        case 0 /* DraftType.Object */ :
        case 2 /* DraftType.Map */ :
            return generatePatchesFromAssigned(proxyState, basePath, patches, inversePatches, pathAsArray);
        case 1 /* DraftType.Array */ :
            return generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray);
        case 3 /* DraftType.Set */ :
            return generateSetPatches(proxyState, basePath, patches, inversePatches, pathAsArray);
    }
}
let readable = false;
const checkReadable = (value, options, ignoreCheckDraftable = false)=>{
    if (typeof value === 'object' && value !== null && (!isDraftable(value, options) || ignoreCheckDraftable) && !readable) {
        throw new Error(`Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.`);
    }
};
/**
 * `unsafe(callback)` to access mutable data directly in strict mode.
 *
 * ## Example
 *
 * ```ts
 * import { create, unsafe } from '../index';
 *
 * class Foobar {
 *   bar = 1;
 * }
 *
 * const baseState = { foobar: new Foobar() };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *    unsafe(() => {
 *      draft.foobar.bar = 2;
 *    });
 *   },
 *   {
 *     strict: true,
 *   }
 * );
 *
 * expect(state).toBe(baseState);
 * expect(state.foobar).toBe(baseState.foobar);
 * expect(state.foobar.bar).toBe(2);
 * ```
 */ function unsafe(callback) {
    readable = true;
    let result;
    try {
        result = callback();
    } finally{
        readable = false;
    }
    return result;
}
const mapHandler = {
    get size () {
        const current = latest(getProxyDraft(this));
        return current.size;
    },
    has (key) {
        return latest(getProxyDraft(this)).has(key);
    },
    set (key, value) {
        const target = getProxyDraft(this);
        const source = latest(target);
        if (!source.has(key) || !isEqual(source.get(key), value)) {
            ensureShallowCopy(target);
            markChanged(target);
            target.assignedMap.set(key, true);
            target.copy.set(key, value);
            markFinalization(target, key, value, generatePatches);
        }
        return this;
    },
    delete (key) {
        if (!this.has(key)) {
            return false;
        }
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        markChanged(target);
        if (target.original.has(key)) {
            target.assignedMap.set(key, false);
        } else {
            target.assignedMap.delete(key);
        }
        target.copy.delete(key);
        return true;
    },
    clear () {
        const target = getProxyDraft(this);
        if (!this.size) return;
        ensureShallowCopy(target);
        markChanged(target);
        target.assignedMap = new Map();
        for (const [key] of target.original){
            target.assignedMap.set(key, false);
        }
        target.copy.clear();
    },
    forEach (callback, thisArg) {
        const target = getProxyDraft(this);
        latest(target).forEach((_value, _key)=>{
            callback.call(thisArg, this.get(_key), _key, this);
        });
    },
    get (key) {
        var _a, _b;
        const target = getProxyDraft(this);
        const value = latest(target).get(key);
        const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;
        if (target.options.strict) {
            checkReadable(value, target.options, mutable);
        }
        if (mutable) {
            return value;
        }
        if (target.finalized || !isDraftable(value, target.options)) {
            return value;
        }
        // drafted or reassigned
        if (value !== target.original.get(key)) {
            return value;
        }
        const draft = internal.createDraft({
            original: value,
            parentDraft: target,
            key,
            finalities: target.finalities,
            options: target.options
        });
        ensureShallowCopy(target);
        target.copy.set(key, draft);
        return draft;
    },
    keys () {
        return latest(getProxyDraft(this)).keys();
    },
    values () {
        const iterator = this.keys();
        return {
            [iteratorSymbol]: ()=>this.values(),
            next: ()=>{
                const result = iterator.next();
                if (result.done) return result;
                const value = this.get(result.value);
                return {
                    done: false,
                    value
                };
            }
        };
    },
    entries () {
        const iterator = this.keys();
        return {
            [iteratorSymbol]: ()=>this.entries(),
            next: ()=>{
                const result = iterator.next();
                if (result.done) return result;
                const value = this.get(result.value);
                return {
                    done: false,
                    value: [
                        result.value,
                        value
                    ]
                };
            }
        };
    },
    [iteratorSymbol] () {
        return this.entries();
    }
};
const mapHandlerKeys = Reflect.ownKeys(mapHandler);
const getNextIterator = (target, iterator, { isValuesIterator })=>()=>{
        var _a, _b;
        const result = iterator.next();
        if (result.done) return result;
        const key = result.value;
        let value = target.setMap.get(key);
        const currentDraft = getProxyDraft(value);
        const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;
        if (target.options.strict) {
            checkReadable(key, target.options, mutable);
        }
        if (!mutable && !currentDraft && isDraftable(key, target.options) && !target.finalized && target.original.has(key)) {
            // draft a draftable original set item
            const proxy = internal.createDraft({
                original: key,
                parentDraft: target,
                key,
                finalities: target.finalities,
                options: target.options
            });
            target.setMap.set(key, proxy);
            value = proxy;
        } else if (currentDraft) {
            // drafted
            value = currentDraft.proxy;
        }
        return {
            done: false,
            value: isValuesIterator ? value : [
                value,
                value
            ]
        };
    };
const setHandler = {
    get size () {
        const target = getProxyDraft(this);
        return target.setMap.size;
    },
    has (value) {
        const target = getProxyDraft(this);
        // reassigned or non-draftable values
        if (target.setMap.has(value)) return true;
        ensureShallowCopy(target);
        const valueProxyDraft = getProxyDraft(value);
        // drafted
        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) return true;
        return false;
    },
    add (value) {
        const target = getProxyDraft(this);
        if (!this.has(value)) {
            ensureShallowCopy(target);
            markChanged(target);
            target.assignedMap.set(value, true);
            target.setMap.set(value, value);
            markFinalization(target, value, value, generatePatches);
        }
        return this;
    },
    delete (value) {
        if (!this.has(value)) {
            return false;
        }
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        markChanged(target);
        const valueProxyDraft = getProxyDraft(value);
        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) {
            // delete drafted
            target.assignedMap.set(valueProxyDraft.original, false);
            return target.setMap.delete(valueProxyDraft.original);
        }
        if (!valueProxyDraft && target.setMap.has(value)) {
            // non-draftable values
            target.assignedMap.set(value, false);
        } else {
            // reassigned
            target.assignedMap.delete(value);
        }
        // delete reassigned or non-draftable values
        return target.setMap.delete(value);
    },
    clear () {
        if (!this.size) return;
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        markChanged(target);
        for (const value of target.original){
            target.assignedMap.set(value, false);
        }
        target.setMap.clear();
    },
    values () {
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        const iterator = target.setMap.keys();
        return {
            [Symbol.iterator]: ()=>this.values(),
            next: getNextIterator(target, iterator, {
                isValuesIterator: true
            })
        };
    },
    entries () {
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        const iterator = target.setMap.keys();
        return {
            [Symbol.iterator]: ()=>this.entries(),
            next: getNextIterator(target, iterator, {
                isValuesIterator: false
            })
        };
    },
    keys () {
        return this.values();
    },
    [iteratorSymbol] () {
        return this.values();
    },
    forEach (callback, thisArg) {
        const iterator = this.values();
        let result = iterator.next();
        while(!result.done){
            callback.call(thisArg, result.value, result.value, this);
            result = iterator.next();
        }
    }
};
if (Set.prototype.difference) {
    // for compatibility with new Set methods
    // https://github.com/tc39/proposal-set-methods
    // And `https://github.com/tc39/proposal-set-methods/blob/main/details.md#symbolspecies` has some details about the `@@species` symbol.
    // So we can't use SubSet instance constructor to get the constructor of the SubSet instance.
    Object.assign(setHandler, {
        intersection (other) {
            return Set.prototype.intersection.call(new Set(this.values()), other);
        },
        union (other) {
            return Set.prototype.union.call(new Set(this.values()), other);
        },
        difference (other) {
            return Set.prototype.difference.call(new Set(this.values()), other);
        },
        symmetricDifference (other) {
            return Set.prototype.symmetricDifference.call(new Set(this.values()), other);
        },
        isSubsetOf (other) {
            return Set.prototype.isSubsetOf.call(new Set(this.values()), other);
        },
        isSupersetOf (other) {
            return Set.prototype.isSupersetOf.call(new Set(this.values()), other);
        },
        isDisjointFrom (other) {
            return Set.prototype.isDisjointFrom.call(new Set(this.values()), other);
        }
    });
}
const setHandlerKeys = Reflect.ownKeys(setHandler);
const proxyHandler = {
    get (target, key, receiver) {
        var _a, _b;
        const copy = (_a = target.copy) === null || _a === void 0 ? void 0 : _a[key];
        // Improve draft reading performance by caching the draft copy.
        if (copy && target.finalities.draftsCache.has(copy)) {
            return copy;
        }
        if (key === PROXY_DRAFT) return target;
        let markResult;
        if (target.options.mark) {
            // handle `Uncaught TypeError: Method get Map.prototype.size called on incompatible receiver #<Map>`
            // or `Uncaught TypeError: Method get Set.prototype.size called on incompatible receiver #<Set>`
            const value = key === 'size' && (target.original instanceof Map || target.original instanceof Set) ? Reflect.get(target.original, key) : Reflect.get(target.original, key, receiver);
            markResult = target.options.mark(value, dataTypes);
            if (markResult === dataTypes.mutable) {
                if (target.options.strict) {
                    checkReadable(value, target.options, true);
                }
                return value;
            }
        }
        const source = latest(target);
        if (source instanceof Map && mapHandlerKeys.includes(key)) {
            if (key === 'size') {
                return Object.getOwnPropertyDescriptor(mapHandler, 'size').get.call(target.proxy);
            }
            const handle = mapHandler[key];
            return handle.bind(target.proxy);
        }
        if (source instanceof Set && setHandlerKeys.includes(key)) {
            if (key === 'size') {
                return Object.getOwnPropertyDescriptor(setHandler, 'size').get.call(target.proxy);
            }
            const handle = setHandler[key];
            return handle.bind(target.proxy);
        }
        if (!has(source, key)) {
            const desc = getDescriptor(source, key);
            return desc ? `value` in desc ? desc.value : (_b = desc.get) === null || _b === void 0 ? void 0 : _b.call(target.proxy) : undefined;
        }
        const value = source[key];
        if (target.options.strict) {
            checkReadable(value, target.options);
        }
        if (target.finalized || !isDraftable(value, target.options)) {
            return value;
        }
        // Ensure that the assigned values are not drafted
        if (value === peek(target.original, key)) {
            ensureShallowCopy(target);
            target.copy[key] = createDraft({
                original: target.original[key],
                parentDraft: target,
                key: target.type === 1 /* DraftType.Array */  ? Number(key) : key,
                finalities: target.finalities,
                options: target.options
            });
            // !case: support for custom shallow copy function
            if (typeof markResult === 'function') {
                const subProxyDraft = getProxyDraft(target.copy[key]);
                ensureShallowCopy(subProxyDraft);
                // Trigger a custom shallow copy to update to a new copy
                markChanged(subProxyDraft);
                return subProxyDraft.copy;
            }
            return target.copy[key];
        }
        if (isDraft(value)) {
            target.finalities.draftsCache.add(value);
        }
        return value;
    },
    set (target, key, value) {
        var _a;
        if (target.type === 3 /* DraftType.Set */  || target.type === 2 /* DraftType.Map */ ) {
            throw new Error(`Map/Set draft does not support any property assignment.`);
        }
        let _key;
        if (target.type === 1 /* DraftType.Array */  && key !== 'length' && !(Number.isInteger(_key = Number(key)) && _key >= 0 && (key === 0 || _key === 0 || String(_key) === String(key)))) {
            throw new Error(`Only supports setting array indices and the 'length' property.`);
        }
        const desc = getDescriptor(latest(target), key);
        if (desc === null || desc === void 0 ? void 0 : desc.set) {
            // !case: cover the case of setter
            desc.set.call(target.proxy, value);
            return true;
        }
        const current = peek(latest(target), key);
        const currentProxyDraft = getProxyDraft(current);
        if (currentProxyDraft && isEqual(currentProxyDraft.original, value)) {
            // !case: ignore the case of assigning the original draftable value to a draft
            target.copy[key] = value;
            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();
            target.assignedMap.set(key, false);
            return true;
        }
        // !case: handle new props with value 'undefined'
        if (isEqual(value, current) && (value !== undefined || has(target.original, key))) return true;
        ensureShallowCopy(target);
        markChanged(target);
        if (has(target.original, key) && isEqual(value, target.original[key])) {
            // !case: handle the case of assigning the original non-draftable value to a draft
            target.assignedMap.delete(key);
        } else {
            target.assignedMap.set(key, true);
        }
        target.copy[key] = value;
        markFinalization(target, key, value, generatePatches);
        return true;
    },
    has (target, key) {
        return key in latest(target);
    },
    ownKeys (target) {
        return Reflect.ownKeys(latest(target));
    },
    getOwnPropertyDescriptor (target, key) {
        const source = latest(target);
        const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
        if (!descriptor) return descriptor;
        return {
            writable: true,
            configurable: target.type !== 1 /* DraftType.Array */  || key !== 'length',
            enumerable: descriptor.enumerable,
            value: source[key]
        };
    },
    getPrototypeOf (target) {
        return Reflect.getPrototypeOf(target.original);
    },
    setPrototypeOf () {
        throw new Error(`Cannot call 'setPrototypeOf()' on drafts`);
    },
    defineProperty () {
        throw new Error(`Cannot call 'defineProperty()' on drafts`);
    },
    deleteProperty (target, key) {
        var _a;
        if (target.type === 1 /* DraftType.Array */ ) {
            return proxyHandler.set.call(this, target, key, undefined, target.proxy);
        }
        if (peek(target.original, key) !== undefined || key in target.original) {
            // !case: delete an existing key
            ensureShallowCopy(target);
            markChanged(target);
            target.assignedMap.set(key, false);
        } else {
            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();
            // The original non-existent key has been deleted
            target.assignedMap.delete(key);
        }
        if (target.copy) delete target.copy[key];
        return true;
    }
};
function createDraft(createDraftOptions) {
    const { original, parentDraft, key, finalities, options } = createDraftOptions;
    const type = getType(original);
    const proxyDraft = {
        type,
        finalized: false,
        parent: parentDraft,
        original,
        copy: null,
        proxy: null,
        finalities,
        options,
        // Mapping of draft Set items to their corresponding draft values.
        setMap: type === 3 /* DraftType.Set */  ? new Map(original.entries()) : undefined
    };
    // !case: undefined as a draft map key
    if (key || 'key' in createDraftOptions) {
        proxyDraft.key = key;
    }
    const { proxy, revoke } = Proxy.revocable(type === 1 /* DraftType.Array */  ? Object.assign([], proxyDraft) : proxyDraft, proxyHandler);
    finalities.revoke.push(revoke);
    proxyDraft.proxy = proxy;
    if (parentDraft) {
        const target = parentDraft;
        target.finalities.draft.push((patches, inversePatches)=>{
            var _a, _b;
            const oldProxyDraft = getProxyDraft(proxy);
            // if target is a Set draft, `setMap` is the real Set copies proxy mapping.
            let copy = target.type === 3 /* DraftType.Set */  ? target.setMap : target.copy;
            const draft = get(copy, key);
            const proxyDraft = getProxyDraft(draft);
            if (proxyDraft) {
                // assign the updated value to the copy object
                let updatedValue = proxyDraft.original;
                if (proxyDraft.operated) {
                    updatedValue = getValue(draft);
                }
                finalizeSetValue(proxyDraft);
                finalizePatches(proxyDraft, generatePatches, patches, inversePatches);
                if (target.options.enableAutoFreeze) {
                    target.options.updatedValues = (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();
                    target.options.updatedValues.set(updatedValue, proxyDraft.original);
                }
                // final update value
                set(copy, key, updatedValue);
            }
            // !case: handle the deleted key
            (_b = oldProxyDraft.callbacks) === null || _b === void 0 ? void 0 : _b.forEach((callback)=>{
                callback(patches, inversePatches);
            });
        });
    } else {
        // !case: handle the root draft
        const target = getProxyDraft(proxy);
        target.finalities.draft.push((patches, inversePatches)=>{
            finalizeSetValue(target);
            finalizePatches(target, generatePatches, patches, inversePatches);
        });
    }
    return proxy;
}
internal.createDraft = createDraft;
function finalizeDraft(result, returnedValue, patches, inversePatches, enableAutoFreeze) {
    var _a;
    const proxyDraft = getProxyDraft(result);
    const original = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : result;
    const hasReturnedValue = !!returnedValue.length;
    if (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated) {
        while(proxyDraft.finalities.draft.length > 0){
            const finalize = proxyDraft.finalities.draft.pop();
            finalize(patches, inversePatches);
        }
    }
    const state = hasReturnedValue ? returnedValue[0] : proxyDraft ? proxyDraft.operated ? proxyDraft.copy : proxyDraft.original : result;
    if (proxyDraft) revokeProxy(proxyDraft);
    if (enableAutoFreeze) {
        deepFreeze(state, state, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options.updatedValues);
    }
    return [
        state,
        patches && hasReturnedValue ? [
            {
                op: Operation.Replace,
                path: [],
                value: returnedValue[0]
            }
        ] : patches,
        inversePatches && hasReturnedValue ? [
            {
                op: Operation.Replace,
                path: [],
                value: original
            }
        ] : inversePatches
    ];
}
function draftify(baseState, options) {
    var _a;
    const finalities = {
        draft: [],
        revoke: [],
        handledSet: new WeakSet(),
        draftsCache: new WeakSet()
    };
    let patches;
    let inversePatches;
    if (options.enablePatches) {
        patches = [];
        inversePatches = [];
    }
    const isMutable = ((_a = options.mark) === null || _a === void 0 ? void 0 : _a.call(options, baseState, dataTypes)) === dataTypes.mutable || !isDraftable(baseState, options);
    const draft = isMutable ? baseState : createDraft({
        original: baseState,
        parentDraft: null,
        finalities,
        options
    });
    return [
        draft,
        (returnedValue = [])=>{
            const [finalizedState, finalizedPatches, finalizedInversePatches] = finalizeDraft(draft, returnedValue, patches, inversePatches, options.enableAutoFreeze);
            return options.enablePatches ? [
                finalizedState,
                finalizedPatches,
                finalizedInversePatches
            ] : finalizedState;
        }
    ];
}
function handleReturnValue(options) {
    const { rootDraft, value, useRawReturn = false, isRoot = true } = options;
    forEach(value, (key, item, source)=>{
        const proxyDraft = getProxyDraft(item);
        // just handle the draft which is created by the same rootDraft
        if (proxyDraft && rootDraft && proxyDraft.finalities === rootDraft.finalities) {
            options.isContainDraft = true;
            const currentValue = proxyDraft.original;
            // final update value, but just handle return value
            if (source instanceof Set) {
                const arr = Array.from(source);
                source.clear();
                arr.forEach((_item)=>source.add(key === _item ? currentValue : _item));
            } else {
                set(source, key, currentValue);
            }
        } else if (typeof item === 'object' && item !== null) {
            options.value = item;
            options.isRoot = false;
            handleReturnValue(options);
        }
    });
    if (isRoot) {
        if (!options.isContainDraft) console.warn(`The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance.`);
        if (useRawReturn) {
            console.warn(`The return value contains drafts, please don't use 'rawReturn()' to wrap the return value.`);
        }
    }
}
function getCurrent(target) {
    var _a;
    const proxyDraft = getProxyDraft(target);
    if (!isDraftable(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options)) return target;
    const type = getType(target);
    if (proxyDraft && !proxyDraft.operated) return proxyDraft.original;
    let currentValue;
    function ensureShallowCopy() {
        currentValue = type === 2 /* DraftType.Map */  ? !isBaseMapInstance(target) ? new (Object.getPrototypeOf(target)).constructor(target) : new Map(target) : type === 3 /* DraftType.Set */  ? Array.from(proxyDraft.setMap.values()) : shallowCopy(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options);
    }
    if (proxyDraft) {
        // It's a proxy draft, let's create a shallow copy eagerly
        proxyDraft.finalized = true;
        try {
            ensureShallowCopy();
        } finally{
            proxyDraft.finalized = false;
        }
    } else {
        // It's not a proxy draft, let's use the target directly and let's see
        // lazily if we need to create a shallow copy
        currentValue = target;
    }
    forEach(currentValue, (key, value)=>{
        if (proxyDraft && isEqual(get(proxyDraft.original, key), value)) return;
        const newValue = getCurrent(value);
        if (newValue !== value) {
            if (currentValue === target) ensureShallowCopy();
            set(currentValue, key, newValue);
        }
    });
    if (type === 3 /* DraftType.Set */ ) {
        const value = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : currentValue;
        return !isBaseSetInstance(value) ? new (Object.getPrototypeOf(value)).constructor(currentValue) : new Set(currentValue);
    }
    return currentValue;
}
function current(target) {
    if (!isDraft(target)) {
        throw new Error(`current() is only used for Draft, parameter: ${target}`);
    }
    return getCurrent(target);
}
/**
 * `makeCreator(options)` to make a creator function.
 *
 * ## Example
 *
 * ```ts
 * import { makeCreator } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const create = makeCreator({ enableAutoFreeze: true });
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *   },
 * );
 *
 * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });
 * expect(state).not.toBe(baseState);
 * expect(state.foo).not.toBe(baseState.foo);
 * expect(state.arr).toBe(baseState.arr);
 * expect(Object.isFrozen(state)).toBeTruthy();
 * ```
 */ const makeCreator = (arg)=>{
    if (arg !== undefined && Object.prototype.toString.call(arg) !== '[object Object]') {
        throw new Error(`Invalid options: ${String(arg)}, 'options' should be an object.`);
    }
    return function create(arg0, arg1, arg2) {
        var _a, _b, _c;
        if (typeof arg0 === 'function' && typeof arg1 !== 'function') {
            return function(base, ...args) {
                return create(base, (draft)=>arg0.call(this, draft, ...args), arg1);
            };
        }
        const base = arg0;
        const mutate = arg1;
        let options = arg2;
        if (typeof arg1 !== 'function') {
            options = arg1;
        }
        if (options !== undefined && Object.prototype.toString.call(options) !== '[object Object]') {
            throw new Error(`Invalid options: ${options}, 'options' should be an object.`);
        }
        options = Object.assign(Object.assign({}, arg), options);
        const state = isDraft(base) ? current(base) : base;
        const mark = Array.isArray(options.mark) ? (value, types)=>{
            for (const mark of options.mark){
                if (typeof mark !== 'function') {
                    throw new Error(`Invalid mark: ${mark}, 'mark' should be a function.`);
                }
                const result = mark(value, types);
                if (result) {
                    return result;
                }
            }
            return;
        } : options.mark;
        const enablePatches = (_a = options.enablePatches) !== null && _a !== void 0 ? _a : false;
        const strict = (_b = options.strict) !== null && _b !== void 0 ? _b : false;
        const enableAutoFreeze = (_c = options.enableAutoFreeze) !== null && _c !== void 0 ? _c : false;
        const _options = {
            enableAutoFreeze,
            mark,
            strict,
            enablePatches
        };
        if (!isDraftable(state, _options) && typeof state === 'object' && state !== null) {
            throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);
        }
        const [draft, finalize] = draftify(state, _options);
        if (typeof arg1 !== 'function') {
            if (!isDraftable(state, _options)) {
                throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);
            }
            return [
                draft,
                finalize
            ];
        }
        let result;
        try {
            result = mutate(draft);
        } catch (error) {
            revokeProxy(getProxyDraft(draft));
            throw error;
        }
        const returnValue = (value)=>{
            const proxyDraft = getProxyDraft(draft);
            if (!isDraft(value)) {
                if (value !== undefined && !isEqual(value, draft) && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated)) {
                    throw new Error(`Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.`);
                }
                const rawReturnValue = value === null || value === void 0 ? void 0 : value[RAW_RETURN_SYMBOL];
                if (rawReturnValue) {
                    const _value = rawReturnValue[0];
                    if (_options.strict && typeof value === 'object' && value !== null) {
                        handleReturnValue({
                            rootDraft: proxyDraft,
                            value,
                            useRawReturn: true
                        });
                    }
                    return finalize([
                        _value
                    ]);
                }
                if (value !== undefined) {
                    if (typeof value === 'object' && value !== null) {
                        handleReturnValue({
                            rootDraft: proxyDraft,
                            value
                        });
                    }
                    return finalize([
                        value
                    ]);
                }
            }
            if (value === draft || value === undefined) {
                return finalize([]);
            }
            const returnedProxyDraft = getProxyDraft(value);
            if (_options === returnedProxyDraft.options) {
                if (returnedProxyDraft.operated) {
                    throw new Error(`Cannot return a modified child draft.`);
                }
                return finalize([
                    current(value)
                ]);
            }
            return finalize([
                value
            ]);
        };
        if (result instanceof Promise) {
            return result.then(returnValue, (error)=>{
                revokeProxy(getProxyDraft(draft));
                throw error;
            });
        }
        return returnValue(result);
    };
};
/**
 * `create(baseState, callback, options)` to create the next state
 *
 * ## Example
 *
 * ```ts
 * import { create } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *   },
 * );
 *
 * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });
 * expect(state).not.toBe(baseState);
 * expect(state.foo).not.toBe(baseState.foo);
 * expect(state.arr).toBe(baseState.arr);
 * ```
 */ const create = makeCreator();
/**
 * `apply(state, patches)` to apply patches to state
 *
 * ## Example
 *
 * ```ts
 * import { create, apply } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const [state, patches] = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *   },
 *   { enablePatches: true }
 * );
 * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });
 * expect(patches).toEqual([{ op: 'replace', path: ['foo', 'bar'], value: 'str2' }]);
 * expect(state).toEqual(apply(baseState, patches));
 * ```
 */ function apply(state, patches, applyOptions) {
    let i;
    for(i = patches.length - 1; i >= 0; i -= 1){
        const { value, op, path } = patches[i];
        if (!path.length && op === Operation.Replace || path === '' && op === Operation.Add) {
            state = value;
            break;
        }
    }
    if (i > -1) {
        patches = patches.slice(i + 1);
    }
    const mutate = (draft)=>{
        patches.forEach((patch)=>{
            const { path: _path, op } = patch;
            const path = unescapePath(_path);
            let base = draft;
            for(let index = 0; index < path.length - 1; index += 1){
                const parentType = getType(base);
                let key = path[index];
                if (typeof key !== 'string' && typeof key !== 'number') {
                    key = String(key);
                }
                if ((parentType === 0 /* DraftType.Object */  || parentType === 1 /* DraftType.Array */ ) && (key === '__proto__' || key === 'constructor') || typeof base === 'function' && key === 'prototype') {
                    throw new Error(`Patching reserved attributes like __proto__ and constructor is not allowed.`);
                }
                // use `index` in Set draft
                base = get(parentType === 3 /* DraftType.Set */  ? Array.from(base) : base, key);
                if (typeof base !== 'object') {
                    throw new Error(`Cannot apply patch at '${path.join('/')}'.`);
                }
            }
            const type = getType(base);
            // ensure the original patch is not modified.
            const value = deepClone(patch.value);
            const key = path[path.length - 1];
            switch(op){
                case Operation.Replace:
                    switch(type){
                        case 2 /* DraftType.Map */ :
                            return base.set(key, value);
                        case 3 /* DraftType.Set */ :
                            throw new Error(`Cannot apply replace patch to set.`);
                        default:
                            return base[key] = value;
                    }
                case Operation.Add:
                    switch(type){
                        case 1 /* DraftType.Array */ :
                            // If the "-" character is used to
                            // index the end of the array (see [RFC6901](https://datatracker.ietf.org/doc/html/rfc6902)),
                            // this has the effect of appending the value to the array.
                            return key === '-' ? base.push(value) : base.splice(key, 0, value);
                        case 2 /* DraftType.Map */ :
                            return base.set(key, value);
                        case 3 /* DraftType.Set */ :
                            return base.add(value);
                        default:
                            return base[key] = value;
                    }
                case Operation.Remove:
                    switch(type){
                        case 1 /* DraftType.Array */ :
                            return base.splice(key, 1);
                        case 2 /* DraftType.Map */ :
                            return base.delete(key);
                        case 3 /* DraftType.Set */ :
                            return base.delete(patch.value);
                        default:
                            return delete base[key];
                    }
                default:
                    throw new Error(`Unsupported patch operation: ${op}.`);
            }
        });
    };
    if (applyOptions === null || applyOptions === void 0 ? void 0 : applyOptions.mutable) {
        {
            if (Object.keys(applyOptions).filter((key)=>key !== 'mutable').length) {
                console.warn('The "mutable" option is not allowed to be used with other options.');
            }
        }
        mutate(state);
        return undefined;
    }
    if (isDraft(state)) {
        if (applyOptions !== undefined) {
            throw new Error(`Cannot apply patches with options to a draft.`);
        }
        mutate(state);
        return state;
    }
    return create(state, mutate, Object.assign(Object.assign({}, applyOptions), {
        enablePatches: false
    }));
}
/**
 * `original(draft)` to get original state in the draft mutation function.
 *
 * ## Example
 *
 * ```ts
 * import { create, original } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *     expect(original(draft.foo)).toEqual({ bar: 'str' });
 *   }
 * );
 * ```
 */ function original(target) {
    const proxyDraft = getProxyDraft(target);
    if (!proxyDraft) {
        throw new Error(`original() is only used for a draft, parameter: ${target}`);
    }
    return proxyDraft.original;
}
/**
 * Use rawReturn() to wrap the return value to skip the draft check and thus improve performance.
 *
 * ## Example
 *
 * ```ts
 * import { create, rawReturn } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     return rawReturn(baseState);
 *   },
 * );
 * expect(state).toBe(baseState);
 * ```
 */ function rawReturn(value) {
    if (arguments.length === 0) {
        throw new Error('rawReturn() must be called with a value.');
    }
    if (arguments.length > 1) {
        throw new Error('rawReturn() must be called with one argument.');
    }
    if (value !== undefined && (typeof value !== 'object' || value === null)) {
        console.warn('rawReturn() must be called with an object(including plain object, arrays, Set, Map, etc.) or `undefined`, other types do not need to be returned via rawReturn().');
    }
    return {
        [RAW_RETURN_SYMBOL]: [
            value
        ]
    };
}
const constructorString = Object.prototype.constructor.toString();
/**
 * Check if the value is a simple object(No prototype chain object or iframe same-origin object),
 * support case: https://github.com/unadlib/mutative/issues/17
 */ const isSimpleObject = (value)=>{
    if (!value || typeof value !== 'object') return false;
    const prototype = Object.getPrototypeOf(value);
    if (prototype === null) {
        return true;
    }
    const constructor = Object.hasOwnProperty.call(prototype, 'constructor') && prototype.constructor;
    if (constructor === Object) return true;
    return typeof constructor === 'function' && Function.toString.call(constructor) === constructorString;
};
const markSimpleObject = (value)=>{
    if (isSimpleObject(value)) {
        return dataTypes.immutable;
    }
    return;
};
/**
 * Cast a value to an Draft type value.
 */ function castDraft(value) {
    return value;
}
/**
 * Cast a value to an Immutable type value.
 */ function castImmutable(value) {
    return value;
}
/**
 * Cast a value to an Mutable type value.
 */ function castMutable(draft) {
    return draft;
}
;
 //# sourceMappingURL=mutative.esm.mjs.map
}),
"[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function() {
    var e = {
        675: function(e, r) {
            "use strict";
            r.byteLength = byteLength;
            r.toByteArray = toByteArray;
            r.fromByteArray = fromByteArray;
            var t = [];
            var f = [];
            var n = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for(var o = 0, u = i.length; o < u; ++o){
                t[o] = i[o];
                f[i.charCodeAt(o)] = o;
            }
            f["-".charCodeAt(0)] = 62;
            f["_".charCodeAt(0)] = 63;
            function getLens(e) {
                var r = e.length;
                if (r % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                }
                var t = e.indexOf("=");
                if (t === -1) t = r;
                var f = t === r ? 0 : 4 - t % 4;
                return [
                    t,
                    f
                ];
            }
            function byteLength(e) {
                var r = getLens(e);
                var t = r[0];
                var f = r[1];
                return (t + f) * 3 / 4 - f;
            }
            function _byteLength(e, r, t) {
                return (r + t) * 3 / 4 - t;
            }
            function toByteArray(e) {
                var r;
                var t = getLens(e);
                var i = t[0];
                var o = t[1];
                var u = new n(_byteLength(e, i, o));
                var a = 0;
                var s = o > 0 ? i - 4 : i;
                var h;
                for(h = 0; h < s; h += 4){
                    r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];
                    u[a++] = r >> 16 & 255;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                if (o === 2) {
                    r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;
                    u[a++] = r & 255;
                }
                if (o === 1) {
                    r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                return u;
            }
            function tripletToBase64(e) {
                return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];
            }
            function encodeChunk(e, r, t) {
                var f;
                var n = [];
                for(var i = r; i < t; i += 3){
                    f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);
                    n.push(tripletToBase64(f));
                }
                return n.join("");
            }
            function fromByteArray(e) {
                var r;
                var f = e.length;
                var n = f % 3;
                var i = [];
                var o = 16383;
                for(var u = 0, a = f - n; u < a; u += o){
                    i.push(encodeChunk(e, u, u + o > a ? a : u + o));
                }
                if (n === 1) {
                    r = e[f - 1];
                    i.push(t[r >> 2] + t[r << 4 & 63] + "==");
                } else if (n === 2) {
                    r = (e[f - 2] << 8) + e[f - 1];
                    i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + "=");
                }
                return i.join("");
            }
        },
        72: function(e, r, t) {
            "use strict";
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var f = t(675);
            var n = t(783);
            var i = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
            r.Buffer = Buffer;
            r.SlowBuffer = SlowBuffer;
            r.INSPECT_MAX_BYTES = 50;
            var o = 2147483647;
            r.kMaxLength = o;
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
            }
            function typedArraySupport() {
                try {
                    var e = new Uint8Array(1);
                    var r = {
                        foo: function() {
                            return 42;
                        }
                    };
                    Object.setPrototypeOf(r, Uint8Array.prototype);
                    Object.setPrototypeOf(e, r);
                    return e.foo() === 42;
                } catch (e) {
                    return false;
                }
            }
            Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.buffer;
                }
            });
            Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.byteOffset;
                }
            });
            function createBuffer(e) {
                if (e > o) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
                var r = new Uint8Array(e);
                Object.setPrototypeOf(r, Buffer.prototype);
                return r;
            }
            function Buffer(e, r, t) {
                if (typeof e === "number") {
                    if (typeof r === "string") {
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    }
                    return allocUnsafe(e);
                }
                return from(e, r, t);
            }
            Buffer.poolSize = 8192;
            function from(e, r, t) {
                if (typeof e === "string") {
                    return fromString(e, r);
                }
                if (ArrayBuffer.isView(e)) {
                    return fromArrayLike(e);
                }
                if (e == null) {
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
                }
                if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof SharedArrayBuffer !== "undefined" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof e === "number") {
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                }
                var f = e.valueOf && e.valueOf();
                if (f != null && f !== e) {
                    return Buffer.from(f, r, t);
                }
                var n = fromObject(e);
                if (n) return n;
                if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === "function") {
                    return Buffer.from(e[Symbol.toPrimitive]("string"), r, t);
                }
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
            }
            Buffer.from = function(e, r, t) {
                return from(e, r, t);
            };
            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
            Object.setPrototypeOf(Buffer, Uint8Array);
            function assertSize(e) {
                if (typeof e !== "number") {
                    throw new TypeError('"size" argument must be of type number');
                } else if (e < 0) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
            }
            function alloc(e, r, t) {
                assertSize(e);
                if (e <= 0) {
                    return createBuffer(e);
                }
                if (r !== undefined) {
                    return typeof t === "string" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);
                }
                return createBuffer(e);
            }
            Buffer.alloc = function(e, r, t) {
                return alloc(e, r, t);
            };
            function allocUnsafe(e) {
                assertSize(e);
                return createBuffer(e < 0 ? 0 : checked(e) | 0);
            }
            Buffer.allocUnsafe = function(e) {
                return allocUnsafe(e);
            };
            Buffer.allocUnsafeSlow = function(e) {
                return allocUnsafe(e);
            };
            function fromString(e, r) {
                if (typeof r !== "string" || r === "") {
                    r = "utf8";
                }
                if (!Buffer.isEncoding(r)) {
                    throw new TypeError("Unknown encoding: " + r);
                }
                var t = byteLength(e, r) | 0;
                var f = createBuffer(t);
                var n = f.write(e, r);
                if (n !== t) {
                    f = f.slice(0, n);
                }
                return f;
            }
            function fromArrayLike(e) {
                var r = e.length < 0 ? 0 : checked(e.length) | 0;
                var t = createBuffer(r);
                for(var f = 0; f < r; f += 1){
                    t[f] = e[f] & 255;
                }
                return t;
            }
            function fromArrayBuffer(e, r, t) {
                if (r < 0 || e.byteLength < r) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (e.byteLength < r + (t || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                }
                var f;
                if (r === undefined && t === undefined) {
                    f = new Uint8Array(e);
                } else if (t === undefined) {
                    f = new Uint8Array(e, r);
                } else {
                    f = new Uint8Array(e, r, t);
                }
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            }
            function fromObject(e) {
                if (Buffer.isBuffer(e)) {
                    var r = checked(e.length) | 0;
                    var t = createBuffer(r);
                    if (t.length === 0) {
                        return t;
                    }
                    e.copy(t, 0, 0, r);
                    return t;
                }
                if (e.length !== undefined) {
                    if (typeof e.length !== "number" || numberIsNaN(e.length)) {
                        return createBuffer(0);
                    }
                    return fromArrayLike(e);
                }
                if (e.type === "Buffer" && Array.isArray(e.data)) {
                    return fromArrayLike(e.data);
                }
            }
            function checked(e) {
                if (e >= o) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + o.toString(16) + " bytes");
                }
                return e | 0;
            }
            function SlowBuffer(e) {
                if (+e != e) {
                    e = 0;
                }
                return Buffer.alloc(+e);
            }
            Buffer.isBuffer = function isBuffer(e) {
                return e != null && e._isBuffer === true && e !== Buffer.prototype;
            };
            Buffer.compare = function compare(e, r) {
                if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);
                if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);
                if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                }
                if (e === r) return 0;
                var t = e.length;
                var f = r.length;
                for(var n = 0, i = Math.min(t, f); n < i; ++n){
                    if (e[n] !== r[n]) {
                        t = e[n];
                        f = r[n];
                        break;
                    }
                }
                if (t < f) return -1;
                if (f < t) return 1;
                return 0;
            };
            Buffer.isEncoding = function isEncoding(e) {
                switch(String(e).toLowerCase()){
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return true;
                    default:
                        return false;
                }
            };
            Buffer.concat = function concat(e, r) {
                if (!Array.isArray(e)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (e.length === 0) {
                    return Buffer.alloc(0);
                }
                var t;
                if (r === undefined) {
                    r = 0;
                    for(t = 0; t < e.length; ++t){
                        r += e[t].length;
                    }
                }
                var f = Buffer.allocUnsafe(r);
                var n = 0;
                for(t = 0; t < e.length; ++t){
                    var i = e[t];
                    if (isInstance(i, Uint8Array)) {
                        i = Buffer.from(i);
                    }
                    if (!Buffer.isBuffer(i)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    i.copy(f, n);
                    n += i.length;
                }
                return f;
            };
            function byteLength(e, r) {
                if (Buffer.isBuffer(e)) {
                    return e.length;
                }
                if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {
                    return e.byteLength;
                }
                if (typeof e !== "string") {
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + "Received type " + typeof e);
                }
                var t = e.length;
                var f = arguments.length > 2 && arguments[2] === true;
                if (!f && t === 0) return 0;
                var n = false;
                for(;;){
                    switch(r){
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return t;
                        case "utf8":
                        case "utf-8":
                            return utf8ToBytes(e).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return t * 2;
                        case "hex":
                            return t >>> 1;
                        case "base64":
                            return base64ToBytes(e).length;
                        default:
                            if (n) {
                                return f ? -1 : utf8ToBytes(e).length;
                            }
                            r = ("" + r).toLowerCase();
                            n = true;
                    }
                }
            }
            Buffer.byteLength = byteLength;
            function slowToString(e, r, t) {
                var f = false;
                if (r === undefined || r < 0) {
                    r = 0;
                }
                if (r > this.length) {
                    return "";
                }
                if (t === undefined || t > this.length) {
                    t = this.length;
                }
                if (t <= 0) {
                    return "";
                }
                t >>>= 0;
                r >>>= 0;
                if (t <= r) {
                    return "";
                }
                if (!e) e = "utf8";
                while(true){
                    switch(e){
                        case "hex":
                            return hexSlice(this, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Slice(this, r, t);
                        case "ascii":
                            return asciiSlice(this, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Slice(this, r, t);
                        case "base64":
                            return base64Slice(this, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return utf16leSlice(this, r, t);
                        default:
                            if (f) throw new TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase();
                            f = true;
                    }
                }
            }
            Buffer.prototype._isBuffer = true;
            function swap(e, r, t) {
                var f = e[r];
                e[r] = e[t];
                e[t] = f;
            }
            Buffer.prototype.swap16 = function swap16() {
                var e = this.length;
                if (e % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for(var r = 0; r < e; r += 2){
                    swap(this, r, r + 1);
                }
                return this;
            };
            Buffer.prototype.swap32 = function swap32() {
                var e = this.length;
                if (e % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for(var r = 0; r < e; r += 4){
                    swap(this, r, r + 3);
                    swap(this, r + 1, r + 2);
                }
                return this;
            };
            Buffer.prototype.swap64 = function swap64() {
                var e = this.length;
                if (e % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for(var r = 0; r < e; r += 8){
                    swap(this, r, r + 7);
                    swap(this, r + 1, r + 6);
                    swap(this, r + 2, r + 5);
                    swap(this, r + 3, r + 4);
                }
                return this;
            };
            Buffer.prototype.toString = function toString() {
                var e = this.length;
                if (e === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, e);
                return slowToString.apply(this, arguments);
            };
            Buffer.prototype.toLocaleString = Buffer.prototype.toString;
            Buffer.prototype.equals = function equals(e) {
                if (!Buffer.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                if (this === e) return true;
                return Buffer.compare(this, e) === 0;
            };
            Buffer.prototype.inspect = function inspect() {
                var e = "";
                var t = r.INSPECT_MAX_BYTES;
                e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim();
                if (this.length > t) e += " ... ";
                return "<Buffer " + e + ">";
            };
            if (i) {
                Buffer.prototype[i] = Buffer.prototype.inspect;
            }
            Buffer.prototype.compare = function compare(e, r, t, f, n) {
                if (isInstance(e, Uint8Array)) {
                    e = Buffer.from(e, e.offset, e.byteLength);
                }
                if (!Buffer.isBuffer(e)) {
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof e);
                }
                if (r === undefined) {
                    r = 0;
                }
                if (t === undefined) {
                    t = e ? e.length : 0;
                }
                if (f === undefined) {
                    f = 0;
                }
                if (n === undefined) {
                    n = this.length;
                }
                if (r < 0 || t > e.length || f < 0 || n > this.length) {
                    throw new RangeError("out of range index");
                }
                if (f >= n && r >= t) {
                    return 0;
                }
                if (f >= n) {
                    return -1;
                }
                if (r >= t) {
                    return 1;
                }
                r >>>= 0;
                t >>>= 0;
                f >>>= 0;
                n >>>= 0;
                if (this === e) return 0;
                var i = n - f;
                var o = t - r;
                var u = Math.min(i, o);
                var a = this.slice(f, n);
                var s = e.slice(r, t);
                for(var h = 0; h < u; ++h){
                    if (a[h] !== s[h]) {
                        i = a[h];
                        o = s[h];
                        break;
                    }
                }
                if (i < o) return -1;
                if (o < i) return 1;
                return 0;
            };
            function bidirectionalIndexOf(e, r, t, f, n) {
                if (e.length === 0) return -1;
                if (typeof t === "string") {
                    f = t;
                    t = 0;
                } else if (t > 2147483647) {
                    t = 2147483647;
                } else if (t < -2147483648) {
                    t = -2147483648;
                }
                t = +t;
                if (numberIsNaN(t)) {
                    t = n ? 0 : e.length - 1;
                }
                if (t < 0) t = e.length + t;
                if (t >= e.length) {
                    if (n) return -1;
                    else t = e.length - 1;
                } else if (t < 0) {
                    if (n) t = 0;
                    else return -1;
                }
                if (typeof r === "string") {
                    r = Buffer.from(r, f);
                }
                if (Buffer.isBuffer(r)) {
                    if (r.length === 0) {
                        return -1;
                    }
                    return arrayIndexOf(e, r, t, f, n);
                } else if (typeof r === "number") {
                    r = r & 255;
                    if (typeof Uint8Array.prototype.indexOf === "function") {
                        if (n) {
                            return Uint8Array.prototype.indexOf.call(e, r, t);
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(e, r, t);
                        }
                    }
                    return arrayIndexOf(e, [
                        r
                    ], t, f, n);
                }
                throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(e, r, t, f, n) {
                var i = 1;
                var o = e.length;
                var u = r.length;
                if (f !== undefined) {
                    f = String(f).toLowerCase();
                    if (f === "ucs2" || f === "ucs-2" || f === "utf16le" || f === "utf-16le") {
                        if (e.length < 2 || r.length < 2) {
                            return -1;
                        }
                        i = 2;
                        o /= 2;
                        u /= 2;
                        t /= 2;
                    }
                }
                function read(e, r) {
                    if (i === 1) {
                        return e[r];
                    } else {
                        return e.readUInt16BE(r * i);
                    }
                }
                var a;
                if (n) {
                    var s = -1;
                    for(a = t; a < o; a++){
                        if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {
                            if (s === -1) s = a;
                            if (a - s + 1 === u) return s * i;
                        } else {
                            if (s !== -1) a -= a - s;
                            s = -1;
                        }
                    }
                } else {
                    if (t + u > o) t = o - u;
                    for(a = t; a >= 0; a--){
                        var h = true;
                        for(var c = 0; c < u; c++){
                            if (read(e, a + c) !== read(r, c)) {
                                h = false;
                                break;
                            }
                        }
                        if (h) return a;
                    }
                }
                return -1;
            }
            Buffer.prototype.includes = function includes(e, r, t) {
                return this.indexOf(e, r, t) !== -1;
            };
            Buffer.prototype.indexOf = function indexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, true);
            };
            Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, false);
            };
            function hexWrite(e, r, t, f) {
                t = Number(t) || 0;
                var n = e.length - t;
                if (!f) {
                    f = n;
                } else {
                    f = Number(f);
                    if (f > n) {
                        f = n;
                    }
                }
                var i = r.length;
                if (f > i / 2) {
                    f = i / 2;
                }
                for(var o = 0; o < f; ++o){
                    var u = parseInt(r.substr(o * 2, 2), 16);
                    if (numberIsNaN(u)) return o;
                    e[t + o] = u;
                }
                return o;
            }
            function utf8Write(e, r, t, f) {
                return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);
            }
            function asciiWrite(e, r, t, f) {
                return blitBuffer(asciiToBytes(r), e, t, f);
            }
            function latin1Write(e, r, t, f) {
                return asciiWrite(e, r, t, f);
            }
            function base64Write(e, r, t, f) {
                return blitBuffer(base64ToBytes(r), e, t, f);
            }
            function ucs2Write(e, r, t, f) {
                return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);
            }
            Buffer.prototype.write = function write(e, r, t, f) {
                if (r === undefined) {
                    f = "utf8";
                    t = this.length;
                    r = 0;
                } else if (t === undefined && typeof r === "string") {
                    f = r;
                    t = this.length;
                    r = 0;
                } else if (isFinite(r)) {
                    r = r >>> 0;
                    if (isFinite(t)) {
                        t = t >>> 0;
                        if (f === undefined) f = "utf8";
                    } else {
                        f = t;
                        t = undefined;
                    }
                } else {
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                }
                var n = this.length - r;
                if (t === undefined || t > n) t = n;
                if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!f) f = "utf8";
                var i = false;
                for(;;){
                    switch(f){
                        case "hex":
                            return hexWrite(this, e, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Write(this, e, r, t);
                        case "ascii":
                            return asciiWrite(this, e, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Write(this, e, r, t);
                        case "base64":
                            return base64Write(this, e, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return ucs2Write(this, e, r, t);
                        default:
                            if (i) throw new TypeError("Unknown encoding: " + f);
                            f = ("" + f).toLowerCase();
                            i = true;
                    }
                }
            };
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            function base64Slice(e, r, t) {
                if (r === 0 && t === e.length) {
                    return f.fromByteArray(e);
                } else {
                    return f.fromByteArray(e.slice(r, t));
                }
            }
            function utf8Slice(e, r, t) {
                t = Math.min(e.length, t);
                var f = [];
                var n = r;
                while(n < t){
                    var i = e[n];
                    var o = null;
                    var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
                    if (n + u <= t) {
                        var a, s, h, c;
                        switch(u){
                            case 1:
                                if (i < 128) {
                                    o = i;
                                }
                                break;
                            case 2:
                                a = e[n + 1];
                                if ((a & 192) === 128) {
                                    c = (i & 31) << 6 | a & 63;
                                    if (c > 127) {
                                        o = c;
                                    }
                                }
                                break;
                            case 3:
                                a = e[n + 1];
                                s = e[n + 2];
                                if ((a & 192) === 128 && (s & 192) === 128) {
                                    c = (i & 15) << 12 | (a & 63) << 6 | s & 63;
                                    if (c > 2047 && (c < 55296 || c > 57343)) {
                                        o = c;
                                    }
                                }
                                break;
                            case 4:
                                a = e[n + 1];
                                s = e[n + 2];
                                h = e[n + 3];
                                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {
                                    c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;
                                    if (c > 65535 && c < 1114112) {
                                        o = c;
                                    }
                                }
                        }
                    }
                    if (o === null) {
                        o = 65533;
                        u = 1;
                    } else if (o > 65535) {
                        o -= 65536;
                        f.push(o >>> 10 & 1023 | 55296);
                        o = 56320 | o & 1023;
                    }
                    f.push(o);
                    n += u;
                }
                return decodeCodePointsArray(f);
            }
            var u = 4096;
            function decodeCodePointsArray(e) {
                var r = e.length;
                if (r <= u) {
                    return String.fromCharCode.apply(String, e);
                }
                var t = "";
                var f = 0;
                while(f < r){
                    t += String.fromCharCode.apply(String, e.slice(f, f += u));
                }
                return t;
            }
            function asciiSlice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n] & 127);
                }
                return f;
            }
            function latin1Slice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n]);
                }
                return f;
            }
            function hexSlice(e, r, t) {
                var f = e.length;
                if (!r || r < 0) r = 0;
                if (!t || t < 0 || t > f) t = f;
                var n = "";
                for(var i = r; i < t; ++i){
                    n += s[e[i]];
                }
                return n;
            }
            function utf16leSlice(e, r, t) {
                var f = e.slice(r, t);
                var n = "";
                for(var i = 0; i < f.length; i += 2){
                    n += String.fromCharCode(f[i] + f[i + 1] * 256);
                }
                return n;
            }
            Buffer.prototype.slice = function slice(e, r) {
                var t = this.length;
                e = ~~e;
                r = r === undefined ? t : ~~r;
                if (e < 0) {
                    e += t;
                    if (e < 0) e = 0;
                } else if (e > t) {
                    e = t;
                }
                if (r < 0) {
                    r += t;
                    if (r < 0) r = 0;
                } else if (r > t) {
                    r = t;
                }
                if (r < e) r = e;
                var f = this.subarray(e, r);
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            };
            function checkOffset(e, r, t) {
                if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
                if (e + r > t) throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                return f;
            };
            Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) {
                    checkOffset(e, r, this.length);
                }
                var f = this[e + --r];
                var n = 1;
                while(r > 0 && (n *= 256)){
                    f += this[e + --r] * n;
                }
                return f;
            };
            Buffer.prototype.readUInt8 = function readUInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                return this[e];
            };
            Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] | this[e + 1] << 8;
            };
            Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] << 8 | this[e + 1];
            };
            Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
            };
            Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
            };
            Buffer.prototype.readIntLE = function readIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                n *= 128;
                if (f >= n) f -= Math.pow(2, 8 * r);
                return f;
            };
            Buffer.prototype.readIntBE = function readIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = r;
                var n = 1;
                var i = this[e + --f];
                while(f > 0 && (n *= 256)){
                    i += this[e + --f] * n;
                }
                n *= 128;
                if (i >= n) i -= Math.pow(2, 8 * r);
                return i;
            };
            Buffer.prototype.readInt8 = function readInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                if (!(this[e] & 128)) return this[e];
                return (255 - this[e] + 1) * -1;
            };
            Buffer.prototype.readInt16LE = function readInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e] | this[e + 1] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt16BE = function readInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e + 1] | this[e] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt32LE = function readInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
            };
            Buffer.prototype.readInt32BE = function readInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
            };
            Buffer.prototype.readFloatLE = function readFloatLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, true, 23, 4);
            };
            Buffer.prototype.readFloatBE = function readFloatBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, false, 23, 4);
            };
            Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, true, 52, 8);
            };
            Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, false, 52, 8);
            };
            function checkInt(e, r, t, f, n, i) {
                if (!Buffer.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (r > n || r < i) throw new RangeError('"value" argument is out of bounds');
                if (t + f > e.length) throw new RangeError("Index out of range");
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = 1;
                var o = 0;
                this[r] = e & 255;
                while(++o < t && (i *= 256)){
                    this[r + o] = e / i & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = t - 1;
                var o = 1;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    this[r + i] = e / o & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 255, 0);
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r + 3] = e >>> 24;
                this[r + 2] = e >>> 16;
                this[r + 1] = e >>> 8;
                this[r] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = 0;
                var o = 1;
                var u = 0;
                this[r] = e & 255;
                while(++i < t && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i - 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = t - 1;
                var o = 1;
                var u = 0;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i + 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 127, -128);
                if (e < 0) e = 255 + e + 1;
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                this[r + 2] = e >>> 16;
                this[r + 3] = e >>> 24;
                return r + 4;
            };
            Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                if (e < 0) e = 4294967295 + e + 1;
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            function checkIEEE754(e, r, t, f, n, i) {
                if (t + f > e.length) throw new RangeError("Index out of range");
                if (t < 0) throw new RangeError("Index out of range");
            }
            function writeFloat(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);
                }
                n.write(e, r, t, f, 23, 4);
                return t + 4;
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {
                return writeFloat(this, e, r, true, t);
            };
            Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {
                return writeFloat(this, e, r, false, t);
            };
            function writeDouble(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);
                }
                n.write(e, r, t, f, 52, 8);
                return t + 8;
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {
                return writeDouble(this, e, r, true, t);
            };
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {
                return writeDouble(this, e, r, false, t);
            };
            Buffer.prototype.copy = function copy(e, r, t, f) {
                if (!Buffer.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                if (!t) t = 0;
                if (!f && f !== 0) f = this.length;
                if (r >= e.length) r = e.length;
                if (!r) r = 0;
                if (f > 0 && f < t) f = t;
                if (f === t) return 0;
                if (e.length === 0 || this.length === 0) return 0;
                if (r < 0) {
                    throw new RangeError("targetStart out of bounds");
                }
                if (t < 0 || t >= this.length) throw new RangeError("Index out of range");
                if (f < 0) throw new RangeError("sourceEnd out of bounds");
                if (f > this.length) f = this.length;
                if (e.length - r < f - t) {
                    f = e.length - r + t;
                }
                var n = f - t;
                if (this === e && typeof Uint8Array.prototype.copyWithin === "function") {
                    this.copyWithin(r, t, f);
                } else if (this === e && t < r && r < f) {
                    for(var i = n - 1; i >= 0; --i){
                        e[i + r] = this[i + t];
                    }
                } else {
                    Uint8Array.prototype.set.call(e, this.subarray(t, f), r);
                }
                return n;
            };
            Buffer.prototype.fill = function fill(e, r, t, f) {
                if (typeof e === "string") {
                    if (typeof r === "string") {
                        f = r;
                        r = 0;
                        t = this.length;
                    } else if (typeof t === "string") {
                        f = t;
                        t = this.length;
                    }
                    if (f !== undefined && typeof f !== "string") {
                        throw new TypeError("encoding must be a string");
                    }
                    if (typeof f === "string" && !Buffer.isEncoding(f)) {
                        throw new TypeError("Unknown encoding: " + f);
                    }
                    if (e.length === 1) {
                        var n = e.charCodeAt(0);
                        if (f === "utf8" && n < 128 || f === "latin1") {
                            e = n;
                        }
                    }
                } else if (typeof e === "number") {
                    e = e & 255;
                } else if (typeof e === "boolean") {
                    e = Number(e);
                }
                if (r < 0 || this.length < r || this.length < t) {
                    throw new RangeError("Out of range index");
                }
                if (t <= r) {
                    return this;
                }
                r = r >>> 0;
                t = t === undefined ? this.length : t >>> 0;
                if (!e) e = 0;
                var i;
                if (typeof e === "number") {
                    for(i = r; i < t; ++i){
                        this[i] = e;
                    }
                } else {
                    var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);
                    var u = o.length;
                    if (u === 0) {
                        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                    }
                    for(i = 0; i < t - r; ++i){
                        this[i + r] = o[i % u];
                    }
                }
                return this;
            };
            var a = /[^+/0-9A-Za-z-_]/g;
            function base64clean(e) {
                e = e.split("=")[0];
                e = e.trim().replace(a, "");
                if (e.length < 2) return "";
                while(e.length % 4 !== 0){
                    e = e + "=";
                }
                return e;
            }
            function utf8ToBytes(e, r) {
                r = r || Infinity;
                var t;
                var f = e.length;
                var n = null;
                var i = [];
                for(var o = 0; o < f; ++o){
                    t = e.charCodeAt(o);
                    if (t > 55295 && t < 57344) {
                        if (!n) {
                            if (t > 56319) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            } else if (o + 1 === f) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            }
                            n = t;
                            continue;
                        }
                        if (t < 56320) {
                            if ((r -= 3) > -1) i.push(239, 191, 189);
                            n = t;
                            continue;
                        }
                        t = (n - 55296 << 10 | t - 56320) + 65536;
                    } else if (n) {
                        if ((r -= 3) > -1) i.push(239, 191, 189);
                    }
                    n = null;
                    if (t < 128) {
                        if ((r -= 1) < 0) break;
                        i.push(t);
                    } else if (t < 2048) {
                        if ((r -= 2) < 0) break;
                        i.push(t >> 6 | 192, t & 63 | 128);
                    } else if (t < 65536) {
                        if ((r -= 3) < 0) break;
                        i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
                    } else if (t < 1114112) {
                        if ((r -= 4) < 0) break;
                        i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
                    } else {
                        throw new Error("Invalid code point");
                    }
                }
                return i;
            }
            function asciiToBytes(e) {
                var r = [];
                for(var t = 0; t < e.length; ++t){
                    r.push(e.charCodeAt(t) & 255);
                }
                return r;
            }
            function utf16leToBytes(e, r) {
                var t, f, n;
                var i = [];
                for(var o = 0; o < e.length; ++o){
                    if ((r -= 2) < 0) break;
                    t = e.charCodeAt(o);
                    f = t >> 8;
                    n = t % 256;
                    i.push(n);
                    i.push(f);
                }
                return i;
            }
            function base64ToBytes(e) {
                return f.toByteArray(base64clean(e));
            }
            function blitBuffer(e, r, t, f) {
                for(var n = 0; n < f; ++n){
                    if (n + t >= r.length || n >= e.length) break;
                    r[n + t] = e[n];
                }
                return n;
            }
            function isInstance(e, r) {
                return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;
            }
            function numberIsNaN(e) {
                return e !== e;
            }
            var s = function() {
                var e = "0123456789abcdef";
                var r = new Array(256);
                for(var t = 0; t < 16; ++t){
                    var f = t * 16;
                    for(var n = 0; n < 16; ++n){
                        r[f + n] = e[t] + e[n];
                    }
                }
                return r;
            }();
        },
        783: function(e, r) {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ r.read = function(e, r, t, f, n) {
                var i, o;
                var u = n * 8 - f - 1;
                var a = (1 << u) - 1;
                var s = a >> 1;
                var h = -7;
                var c = t ? n - 1 : 0;
                var l = t ? -1 : 1;
                var p = e[r + c];
                c += l;
                i = p & (1 << -h) - 1;
                p >>= -h;
                h += u;
                for(; h > 0; i = i * 256 + e[r + c], c += l, h -= 8){}
                o = i & (1 << -h) - 1;
                i >>= -h;
                h += f;
                for(; h > 0; o = o * 256 + e[r + c], c += l, h -= 8){}
                if (i === 0) {
                    i = 1 - s;
                } else if (i === a) {
                    return o ? NaN : (p ? -1 : 1) * Infinity;
                } else {
                    o = o + Math.pow(2, f);
                    i = i - s;
                }
                return (p ? -1 : 1) * o * Math.pow(2, i - f);
            };
            r.write = function(e, r, t, f, n, i) {
                var o, u, a;
                var s = i * 8 - n - 1;
                var h = (1 << s) - 1;
                var c = h >> 1;
                var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                var p = f ? 0 : i - 1;
                var y = f ? 1 : -1;
                var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
                r = Math.abs(r);
                if (isNaN(r) || r === Infinity) {
                    u = isNaN(r) ? 1 : 0;
                    o = h;
                } else {
                    o = Math.floor(Math.log(r) / Math.LN2);
                    if (r * (a = Math.pow(2, -o)) < 1) {
                        o--;
                        a *= 2;
                    }
                    if (o + c >= 1) {
                        r += l / a;
                    } else {
                        r += l * Math.pow(2, 1 - c);
                    }
                    if (r * a >= 2) {
                        o++;
                        a /= 2;
                    }
                    if (o + c >= h) {
                        u = 0;
                        o = h;
                    } else if (o + c >= 1) {
                        u = (r * a - 1) * Math.pow(2, n);
                        o = o + c;
                    } else {
                        u = r * Math.pow(2, c - 1) * Math.pow(2, n);
                        o = 0;
                    }
                }
                for(; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8){}
                o = o << n | u;
                s += n;
                for(; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8){}
                e[t + p - y] |= g * 128;
            };
        }
    };
    var r = {};
    function __nccwpck_require__(t) {
        var f = r[t];
        if (f !== undefined) {
            return f.exports;
        }
        var n = r[t] = {
            exports: {}
        };
        var i = true;
        try {
            e[t](n, n.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete r[t];
        }
        return n.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/buffer") + "/";
    var t = __nccwpck_require__(72);
    module.exports = t;
})();
}),
]);

//# sourceMappingURL=node_modules_7ac14a49._.js.map