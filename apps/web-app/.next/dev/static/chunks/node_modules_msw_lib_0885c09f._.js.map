{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/internal/devUtils.ts"],"sourcesContent":["import { format } from 'outvariant'\n\nconst LIBRARY_PREFIX = '[MSW]'\n\n/**\n * Formats a given message by appending the library's prefix string.\n */\nfunction formatMessage(message: string, ...positionals: any[]): string {\n  const interpolatedMessage = format(message, ...positionals)\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`\n}\n\n/**\n * Prints a library-specific warning.\n */\nfunction warn(message: string, ...positionals: any[]): void {\n  console.warn(formatMessage(message, ...positionals))\n}\n\n/**\n * Prints a library-specific error.\n */\nfunction error(message: string, ...positionals: any[]): void {\n  console.error(formatMessage(message, ...positionals))\n}\n\nexport const devUtils = {\n  formatMessage,\n  warn,\n  error,\n}\n\n/**\n * Internal error instance.\n * Used to differentiate the library errors that must be forwarded\n * to the user from the unhandled exceptions. Use this if you don't\n * wish for the error to be coerced to a 500 fallback response.\n */\nexport class InternalError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'InternalError'\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA,SAAS,cAAc;;AAEvB,MAAM,iBAAiB;AAKvB,SAAS,cAAc,OAAA,EAAA,GAAoB,WAAA,EAA4B;IACrE,MAAM,0BAAsB,iJAAA,EAAO,SAAS,GAAG,WAAW;IAC1D,OAAO,GAAG,cAAc,CAAA,CAAA,EAAI,mBAAmB,EAAA;AACjD;AAKA,SAAS,KAAK,OAAA,EAAA,GAAoB,WAAA,EAA0B;IAC1D,QAAQ,IAAA,CAAK,cAAc,SAAS,GAAG,WAAW,CAAC;AACrD;AAKA,SAAS,MAAM,OAAA,EAAA,GAAoB,WAAA,EAA0B;IAC3D,QAAQ,KAAA,CAAM,cAAc,SAAS,GAAG,WAAW,CAAC;AACtD;AAEO,MAAM,WAAW;IACtB;IACA;IACA;AACF;AAQO,MAAM,sBAAsB,MAAM;IACvC,YAAY,OAAA,CAAiB;QAC3B,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,IAAA,GAAO;IACd;AACF"}},
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/internal/getCallFrame.ts"],"sourcesContent":["// Ignore the source files traces for local testing.\nconst SOURCE_FRAME = /[/\\\\]msw[/\\\\]src[/\\\\](.+)/\n\nconst BUILD_FRAME =\n  /(node_modules)?[/\\\\]lib[/\\\\](core|browser|node|native|iife)[/\\\\]|^[^/\\\\]*$/\n\n/**\n * Return the stack trace frame of a function's invocation.\n */\nexport function getCallFrame(error: Error) {\n  // In <IE11, new Error may return an undefined stack\n  const stack = error.stack\n\n  if (!stack) {\n    return\n  }\n\n  const frames: string[] = stack.split('\\n').slice(1)\n\n  // Get the first frame that doesn't reference the library's internal trace.\n  // Assume that frame is the invocation frame.\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame))\n  })\n\n  if (!declarationFrame) {\n    return\n  }\n\n  // Extract file reference from the stack frame.\n  const declarationPath = declarationFrame\n    .replace(/\\s*at [^()]*\\(([^)]+)\\)/, '$1')\n    .replace(/^@/, '')\n  return declarationPath\n}\n"],"names":[],"mappings":";;;;AACA,MAAM,eAAe;AAErB,MAAM,cACJ;AAKK,SAAS,aAAa,KAAA,EAAc;IAEzC,MAAM,QAAQ,MAAM,KAAA;IAEpB,IAAI,CAAC,OAAO;QACV;IACF;IAEA,MAAM,SAAmB,MAAM,KAAA,CAAM,IAAI,EAAE,KAAA,CAAM,CAAC;IAIlD,MAAM,mBAAmB,OAAO,IAAA,CAAK,CAAC,UAAU;QAC9C,OAAO,CAAA,CAAE,aAAa,IAAA,CAAK,KAAK,KAAK,YAAY,IAAA,CAAK,KAAK,CAAA;IAC7D,CAAC;IAED,IAAI,CAAC,kBAAkB;QACrB;IACF;IAGA,MAAM,kBAAkB,iBACrB,OAAA,CAAQ,2BAA2B,IAAI,EACvC,OAAA,CAAQ,MAAM,EAAE;IACnB,OAAO;AACT"}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/internal/isIterable.ts"],"sourcesContent":["/**\n * This is the same as TypeScript's `Iterable`, but with all three type parameters.\n * @todo Remove once TypeScript 5.6 is the minimum.\n */\nexport interface Iterable<T, TReturn, TNext> {\n  [Symbol.iterator](): Iterator<T, TReturn, TNext>\n}\n\n/**\n * This is the same as TypeScript's `AsyncIterable`, but with all three type parameters.\n * @todo Remove once TypeScript 5.6 is the minimum.\n */\nexport interface AsyncIterable<T, TReturn, TNext> {\n  [Symbol.asyncIterator](): AsyncIterator<T, TReturn, TNext>\n}\n\n/**\n * Determines if the given function is an iterator.\n */\nexport function isIterable<IteratorType>(\n  fn: any,\n): fn is\n  | Iterable<IteratorType, IteratorType, IteratorType>\n  | AsyncIterable<IteratorType, IteratorType, IteratorType> {\n  if (!fn) {\n    return false\n  }\n\n  return (\n    Reflect.has(fn, Symbol.iterator) || Reflect.has(fn, Symbol.asyncIterator)\n  )\n}\n"],"names":[],"mappings":";;;;AAmBO,SAAS,WACd,EAAA,EAG0D;IAC1D,IAAI,CAAC,IAAI;QACP,OAAO;IACT;IAEA,OACE,QAAQ,GAAA,CAAI,IAAI,OAAO,QAAQ,KAAK,QAAQ,GAAA,CAAI,IAAI,OAAO,aAAa;AAE5E"}},
    {"offset": {"line": 83, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/handlers/RequestHandler.ts"],"sourcesContent":["import { getCallFrame } from '../utils/internal/getCallFrame'\nimport {\n  AsyncIterable,\n  Iterable,\n  isIterable,\n} from '../utils/internal/isIterable'\nimport type { ResponseResolutionContext } from '../utils/executeHandlers'\nimport type { MaybePromise } from '../typeUtils'\nimport {\n  StrictRequest,\n  HttpResponse,\n  DefaultUnsafeFetchResponse,\n} from '../HttpResponse'\nimport type { HandlerKind } from './common'\nimport type { GraphQLRequestBody } from './GraphQLHandler'\n\nexport type DefaultRequestMultipartBody = Record<\n  string,\n  string | File | Array<string | File>\n>\n\nexport type DefaultBodyType =\n  | Record<string, any>\n  | DefaultRequestMultipartBody\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n\nexport type JsonBodyType =\n  | Record<string, any>\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n\nexport interface RequestHandlerDefaultInfo {\n  header: string\n}\n\nexport interface RequestHandlerInternalInfo {\n  callFrame?: string\n}\n\nexport type ResponseResolverReturnType<\n  ResponseBodyType extends DefaultBodyType = undefined,\n> =\n  // If ResponseBodyType is a union and one of the types is `undefined`,\n  // allow plain Response as the type.\n  | ([ResponseBodyType] extends [undefined]\n      ? Response\n      : /**\n         * Treat GraphQL response body type as a special case.\n         * For esome reason, making the default HttpResponse<T> | DefaultUnsafeFetchResponse\n         * union breaks the body type inference for HTTP requests.\n         * @see https://github.com/mswjs/msw/issues/2130\n         */\n        ResponseBodyType extends GraphQLRequestBody<any>\n        ? HttpResponse<ResponseBodyType> | DefaultUnsafeFetchResponse\n        : HttpResponse<ResponseBodyType>)\n  | undefined\n  | void\n\nexport type MaybeAsyncResponseResolverReturnType<\n  ResponseBodyType extends DefaultBodyType,\n> = MaybePromise<ResponseResolverReturnType<ResponseBodyType>>\n\nexport type AsyncResponseResolverReturnType<\n  ResponseBodyType extends DefaultBodyType,\n> = MaybePromise<\n  | ResponseResolverReturnType<ResponseBodyType>\n  | Iterable<\n      MaybeAsyncResponseResolverReturnType<ResponseBodyType>,\n      MaybeAsyncResponseResolverReturnType<ResponseBodyType>,\n      MaybeAsyncResponseResolverReturnType<ResponseBodyType>\n    >\n  | AsyncIterable<\n      MaybeAsyncResponseResolverReturnType<ResponseBodyType>,\n      MaybeAsyncResponseResolverReturnType<ResponseBodyType>,\n      MaybeAsyncResponseResolverReturnType<ResponseBodyType>\n    >\n>\n\nexport type ResponseResolverInfo<\n  ResolverExtraInfo extends Record<string, unknown>,\n  RequestBodyType extends DefaultBodyType = DefaultBodyType,\n> = {\n  request: StrictRequest<RequestBodyType>\n  requestId: string\n} & ResolverExtraInfo\n\nexport type ResponseResolver<\n  ResolverExtraInfo extends Record<string, unknown> = Record<string, unknown>,\n  RequestBodyType extends DefaultBodyType = DefaultBodyType,\n  ResponseBodyType extends DefaultBodyType = undefined,\n> = (\n  info: ResponseResolverInfo<ResolverExtraInfo, RequestBodyType>,\n) => AsyncResponseResolverReturnType<ResponseBodyType>\n\nexport interface RequestHandlerArgs<\n  HandlerInfo,\n  HandlerOptions extends RequestHandlerOptions,\n> {\n  info: HandlerInfo\n  resolver: ResponseResolver<any>\n  options?: HandlerOptions\n}\n\nexport interface RequestHandlerOptions {\n  once?: boolean\n}\n\nexport interface RequestHandlerExecutionResult<\n  ParsedResult extends Record<string, unknown> | undefined,\n> {\n  handler: RequestHandler\n  parsedResult?: ParsedResult\n  request: Request\n  requestId: string\n  response?: Response\n}\n\nexport abstract class RequestHandler<\n  HandlerInfo extends RequestHandlerDefaultInfo = RequestHandlerDefaultInfo,\n  ParsedResult extends Record<string, any> | undefined = any,\n  ResolverExtras extends Record<string, unknown> = any,\n  HandlerOptions extends RequestHandlerOptions = RequestHandlerOptions,\n> {\n  static cache = new WeakMap<\n    StrictRequest<DefaultBodyType>,\n    StrictRequest<DefaultBodyType>\n  >()\n\n  private readonly __kind: HandlerKind\n\n  public info: HandlerInfo & RequestHandlerInternalInfo\n  /**\n   * Indicates whether this request handler has been used\n   * (its resolver has successfully executed).\n   */\n  public isUsed: boolean\n\n  protected resolver: ResponseResolver<ResolverExtras, any, any>\n  private resolverIterator?:\n    | Iterator<\n        MaybeAsyncResponseResolverReturnType<any>,\n        MaybeAsyncResponseResolverReturnType<any>,\n        MaybeAsyncResponseResolverReturnType<any>\n      >\n    | AsyncIterator<\n        MaybeAsyncResponseResolverReturnType<any>,\n        MaybeAsyncResponseResolverReturnType<any>,\n        MaybeAsyncResponseResolverReturnType<any>\n      >\n  private resolverIteratorResult?: Response | HttpResponse<any>\n  private options?: HandlerOptions\n\n  constructor(args: RequestHandlerArgs<HandlerInfo, HandlerOptions>) {\n    this.resolver = args.resolver\n    this.options = args.options\n\n    const callFrame = getCallFrame(new Error())\n\n    this.info = {\n      ...args.info,\n      callFrame,\n    }\n\n    this.isUsed = false\n    this.__kind = 'RequestHandler'\n  }\n\n  /**\n   * Determine if the intercepted request should be mocked.\n   */\n  abstract predicate(args: {\n    request: Request\n    parsedResult: ParsedResult\n    resolutionContext?: ResponseResolutionContext\n  }): boolean | Promise<boolean>\n\n  /**\n   * Print out the successfully handled request.\n   */\n  abstract log(args: {\n    request: Request\n    response: Response\n    parsedResult: ParsedResult\n  }): void\n\n  /**\n   * Parse the intercepted request to extract additional information from it.\n   * Parsed result is then exposed to other methods of this request handler.\n   */\n  async parse(_args: {\n    request: Request\n    resolutionContext?: ResponseResolutionContext\n  }): Promise<ParsedResult> {\n    return {} as ParsedResult\n  }\n\n  /**\n   * Test if this handler matches the given request.\n   *\n   * This method is not used internally but is exposed\n   * as a convenience method for consumers writing custom\n   * handlers.\n   */\n  public async test(args: {\n    request: Request\n    resolutionContext?: ResponseResolutionContext\n  }): Promise<boolean> {\n    const parsedResult = await this.parse({\n      request: args.request,\n      resolutionContext: args.resolutionContext,\n    })\n\n    return this.predicate({\n      request: args.request,\n      parsedResult,\n      resolutionContext: args.resolutionContext,\n    })\n  }\n\n  protected extendResolverArgs(_args: {\n    request: Request\n    parsedResult: ParsedResult\n  }): ResolverExtras {\n    return {} as ResolverExtras\n  }\n\n  // Clone the request instance before it's passed to the handler phases\n  // and the response resolver so we can always read it for logging.\n  // We only clone it once per request to avoid unnecessary overhead.\n  private cloneRequestOrGetFromCache(\n    request: StrictRequest<DefaultBodyType>,\n  ): StrictRequest<DefaultBodyType> {\n    const existingClone = RequestHandler.cache.get(request)\n\n    if (typeof existingClone !== 'undefined') {\n      return existingClone\n    }\n\n    const clonedRequest = request.clone()\n    RequestHandler.cache.set(request, clonedRequest)\n\n    return clonedRequest\n  }\n\n  /**\n   * Execute this request handler and produce a mocked response\n   * using the given resolver function.\n   */\n  public async run(args: {\n    request: StrictRequest<any>\n    requestId: string\n    resolutionContext?: ResponseResolutionContext\n  }): Promise<RequestHandlerExecutionResult<ParsedResult> | null> {\n    if (this.isUsed && this.options?.once) {\n      return null\n    }\n\n    // Clone the request.\n    // If this is the first time MSW handles this request, a fresh clone\n    // will be created and cached. Upon further handling of the same request,\n    // the request clone from the cache will be reused to prevent abundant\n    // \"abort\" listeners and save up resources on cloning.\n    const requestClone = this.cloneRequestOrGetFromCache(args.request)\n\n    const parsedResult = await this.parse({\n      request: args.request,\n      resolutionContext: args.resolutionContext,\n    })\n    const shouldInterceptRequest = await this.predicate({\n      request: args.request,\n      parsedResult,\n      resolutionContext: args.resolutionContext,\n    })\n\n    if (!shouldInterceptRequest) {\n      return null\n    }\n\n    // Re-check isUsed, in case another request hit this handler while we were\n    // asynchronously parsing the request.\n    if (this.isUsed && this.options?.once) {\n      return null\n    }\n\n    // Preemptively mark the handler as used.\n    // Generators will undo this because only when the resolver reaches the\n    // \"done\" state of the generator that it considers the handler used.\n    this.isUsed = true\n\n    // Create a response extraction wrapper around the resolver\n    // since it can be both an async function and a generator.\n    const executeResolver = this.wrapResolver(this.resolver)\n\n    const resolverExtras = this.extendResolverArgs({\n      request: args.request,\n      parsedResult,\n    })\n\n    const mockedResponsePromise = (\n      executeResolver({\n        ...resolverExtras,\n        requestId: args.requestId,\n        request: args.request,\n      }) as Promise<Response>\n    ).catch((errorOrResponse) => {\n      // Allow throwing a Response instance in a response resolver.\n      if (errorOrResponse instanceof Response) {\n        return errorOrResponse\n      }\n\n      // Otherwise, throw the error as-is.\n      throw errorOrResponse\n    })\n\n    const mockedResponse = await mockedResponsePromise\n\n    const executionResult = this.createExecutionResult({\n      // Pass the cloned request to the result so that logging\n      // and other consumers could read its body once more.\n      request: requestClone,\n      requestId: args.requestId,\n      response: mockedResponse,\n      parsedResult,\n    })\n\n    return executionResult\n  }\n\n  private wrapResolver(\n    resolver: ResponseResolver<ResolverExtras>,\n  ): ResponseResolver<ResolverExtras> {\n    return async (info): Promise<ResponseResolverReturnType<any>> => {\n      if (!this.resolverIterator) {\n        const result = await resolver(info)\n\n        if (!isIterable(result)) {\n          return result\n        }\n\n        this.resolverIterator =\n          Symbol.iterator in result\n            ? result[Symbol.iterator]()\n            : result[Symbol.asyncIterator]()\n      }\n\n      // Opt-out from marking this handler as used.\n      this.isUsed = false\n\n      const { done, value } = await this.resolverIterator.next()\n      const nextResponse = await value\n\n      if (nextResponse) {\n        this.resolverIteratorResult = nextResponse.clone()\n      }\n\n      if (done) {\n        // A one-time generator resolver stops affecting the network\n        // only after it's been completely exhausted.\n        this.isUsed = true\n\n        // Clone the previously stored response so it can be read\n        // when receiving it repeatedly from the \"done\" generator.\n        return this.resolverIteratorResult?.clone()\n      }\n\n      return nextResponse\n    }\n  }\n\n  private createExecutionResult(args: {\n    request: Request\n    requestId: string\n    parsedResult: ParsedResult\n    response?: Response\n  }): RequestHandlerExecutionResult<ParsedResult> {\n    return {\n      handler: this,\n      request: args.request,\n      requestId: args.requestId,\n      response: args.response,\n      parsedResult: args.parsedResult,\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 240, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/executeHandlers.ts"],"sourcesContent":["import {\n  RequestHandler,\n  type RequestHandlerExecutionResult,\n} from '../handlers/RequestHandler'\n\nexport interface HandlersExecutionResult {\n  handler: RequestHandler\n  parsedResult?: any\n  response?: Response\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string\n}\n\n/**\n * Executes the list of request handlers against the given request.\n * Returns the execution result object containing any matching request\n * handler and any mocked response it returned.\n */\nexport const executeHandlers = async <Handlers extends Array<RequestHandler>>({\n  request,\n  requestId,\n  handlers,\n  resolutionContext,\n}: {\n  request: Request\n  requestId: string\n  handlers: Handlers\n  resolutionContext?: ResponseResolutionContext\n}): Promise<HandlersExecutionResult | null> => {\n  let matchingHandler: RequestHandler | null = null\n  let result: RequestHandlerExecutionResult<any> | null = null\n\n  for (const handler of handlers) {\n    result = await handler.run({ request, requestId, resolutionContext })\n\n    // If the handler produces some result for this request,\n    // it automatically becomes matching.\n    if (result !== null) {\n      matchingHandler = handler\n    }\n\n    // Stop the lookup if this handler returns a mocked response.\n    // If it doesn't, it will still be considered the last matching\n    // handler until any of them returns a response. This way we can\n    // distinguish between fallthrough handlers without responses\n    // and the lack of a matching handler.\n    if (result?.response) {\n      break\n    }\n  }\n\n  if (matchingHandler) {\n    return {\n      handler: matchingHandler,\n      parsedResult: result?.parsedResult,\n      response: result?.response,\n    }\n  }\n\n  return null\n}\n"],"names":[],"mappings":";;;;AAoBO,MAAM,kBAAkB,OAA+C,EAC5E,OAAA,EACA,SAAA,EACA,QAAA,EACA,iBAAA,EACF,KAK+C;IAC7C,IAAI,kBAAyC;IAC7C,IAAI,SAAoD;IAExD,KAAA,MAAW,WAAW,SAAU;QAC9B,SAAS,MAAM,QAAQ,GAAA,CAAI;YAAE;YAAS;YAAW;QAAkB,CAAC;QAIpE,IAAI,WAAW,MAAM;YACnB,kBAAkB;QACpB;QAOA,IAAI,QAAQ,UAAU;YACpB;QACF;IACF;IAEA,IAAI,iBAAiB;QACnB,OAAO;YACL,SAAS;YACT,cAAc,QAAQ;YACtB,UAAU,QAAQ;QACpB;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 275, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/request/toPublicUrl.ts"],"sourcesContent":["/**\n * Returns a relative URL if the given request URL is relative\n * to the current origin. Otherwise returns an absolute URL.\n */\nexport function toPublicUrl(url: string | URL): string {\n  if (typeof location === 'undefined') {\n    return url.toString()\n  }\n\n  const urlInstance = url instanceof URL ? url : new URL(url)\n\n  return urlInstance.origin === location.origin\n    ? urlInstance.pathname\n    : urlInstance.origin + urlInstance.pathname\n}\n"],"names":[],"mappings":";;;;AAIO,SAAS,YAAY,GAAA,EAA2B;IACrD,IAAI,OAAO,aAAa,aAAa;QACnC,OAAO,IAAI,QAAA,CAAS;IACtB;IAEA,MAAM,cAAc,eAAe,MAAM,MAAM,IAAI,IAAI,GAAG;IAE1D,OAAO,YAAY,MAAA,KAAW,SAAS,MAAA,GACnC,YAAY,QAAA,GACZ,YAAY,MAAA,GAAS,YAAY,QAAA;AACvC"}},
    {"offset": {"line": 292, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/isCommonAssetRequest.ts"],"sourcesContent":["/**\n * Determines if the given request is a static asset request.\n * Useful when deciding which unhandled requests to ignore.\n * @note Despite being ignored, you can still intercept and mock\n * static assets by creating request handlers for them.\n *\n * @example\n * import { isCommonAssetRequest } from 'msw'\n *\n * await worker.start({\n *   onUnhandledRequest(request, print) {\n *     if (!isCommonAssetRequest(request)) {\n *       print.warning()\n *     }\n *   }\n * })\n */\nexport function isCommonAssetRequest(request: Request): boolean {\n  const url = new URL(request.url)\n\n  // Ignore certain protocols.\n  if (url.protocol === 'file:') {\n    return true\n  }\n\n  // Ignore static assets hosts.\n  if (/(fonts\\.googleapis\\.com)/.test(url.hostname)) {\n    return true\n  }\n\n  // Ignore node modules served over HTTP.\n  if (/node_modules/.test(url.pathname)) {\n    return true\n  }\n\n  // Ignore internal Vite requests, like \"/@vite/client\".\n  if (url.pathname.includes('@vite')) {\n    return true\n  }\n\n  // Ignore common static assets.\n  return /\\.(s?css|less|m?jsx?|m?tsx?|html|ttf|otf|woff|woff2|eot|gif|jpe?g|png|avif|webp|svg|mp4|webm|ogg|mov|mp3|wav|ogg|flac|aac|pdf|txt|csv|json|xml|md|zip|tar|gz|rar|7z)$/i.test(\n    url.pathname,\n  )\n}\n"],"names":[],"mappings":";;;;AAiBO,SAAS,qBAAqB,OAAA,EAA2B;IAC9D,MAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;IAG/B,IAAI,IAAI,QAAA,KAAa,SAAS;QAC5B,OAAO;IACT;IAGA,IAAI,2BAA2B,IAAA,CAAK,IAAI,QAAQ,GAAG;QACjD,OAAO;IACT;IAGA,IAAI,eAAe,IAAA,CAAK,IAAI,QAAQ,GAAG;QACrC,OAAO;IACT;IAGA,IAAI,IAAI,QAAA,CAAS,QAAA,CAAS,OAAO,GAAG;QAClC,OAAO;IACT;IAGA,OAAO,yKAAyK,IAAA,CAC9K,IAAI,QAAA;AAER"}},
    {"offset": {"line": 318, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/request/onUnhandledRequest.ts"],"sourcesContent":["import { toPublicUrl } from './toPublicUrl'\nimport { InternalError, devUtils } from '../internal/devUtils'\nimport { isCommonAssetRequest } from '../../isCommonAssetRequest'\n\nexport interface UnhandledRequestPrint {\n  warning(): void\n  error(): void\n}\n\nexport type UnhandledRequestCallback = (\n  request: Request,\n  print: UnhandledRequestPrint,\n) => void\n\nexport type UnhandledRequestStrategy =\n  | 'bypass'\n  | 'warn'\n  | 'error'\n  | UnhandledRequestCallback\n\nexport async function onUnhandledRequest(\n  request: Request,\n  strategy: UnhandledRequestStrategy = 'warn',\n): Promise<void> {\n  const url = new URL(request.url)\n  const publicUrl = toPublicUrl(url) + url.search\n\n  const requestBody =\n    request.method === 'HEAD' || request.method === 'GET'\n      ? null\n      : await request.clone().text()\n  const messageDetails = `\\n\\n  \\u2022 ${request.method} ${publicUrl}\\n\\n${requestBody ? `  \\u2022 Request body: ${requestBody}\\n\\n` : ''}`\n  const unhandledRequestMessage = `intercepted a request without a matching request handler:${messageDetails}If you still wish to intercept this unhandled request, please create a request handler for it.\\nRead more: https://mswjs.io/docs/http/intercepting-requests`\n\n  function applyStrategy(strategy: UnhandledRequestStrategy) {\n    switch (strategy) {\n      case 'error': {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', unhandledRequestMessage)\n\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new InternalError(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.',\n          ),\n        )\n      }\n\n      case 'warn': {\n        devUtils.warn('Warning: %s', unhandledRequestMessage)\n        break\n      }\n\n      case 'bypass':\n        break\n\n      default:\n        throw new InternalError(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy,\n          ),\n        )\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error'),\n    })\n    return\n  }\n\n  // Ignore common static asset requests when using a built-in strategy.\n  // There's a slight overhead here because this utility will create a request URL\n  // instance again despite us having done so previously in this function.\n  if (!isCommonAssetRequest(request)) {\n    applyStrategy(strategy)\n  }\n}\n"],"names":["strategy"],"mappings":";;;;AAAA,SAAS,mBAAmB;AAC5B,SAAS,eAAe,gBAAgB;AACxC,SAAS,4BAA4B;;;;AAkBrC,eAAsB,mBACpB,OAAA,EACA,WAAqC,MAAA,EACtB;IACf,MAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;IAC/B,MAAM,gBAAY,iLAAA,EAAY,GAAG,IAAI,IAAI,MAAA;IAEzC,MAAM,cACJ,QAAQ,MAAA,KAAW,UAAU,QAAQ,MAAA,KAAW,QAC5C,OACA,MAAM,QAAQ,KAAA,CAAM,EAAE,IAAA,CAAK;IACjC,MAAM,iBAAiB,CAAA;;SAAA,EAAgB,QAAQ,MAAM,CAAA,CAAA,EAAI,SAAS,CAAA;;AAAA,EAAO,cAAc,CAAA,uBAAA,EAA0B,WAAW,CAAA;;AAAA,CAAA,GAAS,EAAE,EAAA;IACvI,MAAM,0BAA0B,CAAA,yDAAA,EAA4D,cAAc,CAAA;2DAAA,CAAA;IAE1G,SAAS,cAAcA,SAAAA,EAAoC;QACzD,OAAQA,WAAU;YAChB,KAAK;gBAAS;oBAEZ,4KAAA,CAAS,KAAA,CAAM,aAAa,uBAAuB;oBAGnD,MAAM,IAAI,iLAAA,CACR,4KAAA,CAAS,aAAA,CACP;gBAGN;YAEA,KAAK;gBAAQ;oBACX,4KAAA,CAAS,IAAA,CAAK,eAAe,uBAAuB;oBACpD;gBACF;YAEA,KAAK;gBACH;YAEF;gBACE,MAAM,IAAI,iLAAA,CACR,4KAAA,CAAS,aAAA,CACP,6NACAA;QAGR;IACF;IAEA,IAAI,OAAO,aAAa,YAAY;QAClC,SAAS,SAAS;YAChB,SAAS,cAAc,IAAA,CAAK,MAAM,MAAM;YACxC,OAAO,cAAc,IAAA,CAAK,MAAM,OAAO;QACzC,CAAC;QACD;IACF;IAKA,IAAI,KAAC,+KAAA,EAAqB,OAAO,GAAG;QAClC,cAAc,QAAQ;IACxB;AACF"}},
    {"offset": {"line": 376, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/internal/jsonParse.ts"],"sourcesContent":["/**\n * Parses a given value into a JSON.\n * Does not throw an exception on an invalid JSON string.\n */\nexport function jsonParse<ValueType extends Record<string, any>>(\n  value: any,\n): ValueType | undefined {\n  try {\n    return JSON.parse(value)\n  } catch {\n    return undefined\n  }\n}\n"],"names":[],"mappings":";;;;AAIO,SAAS,UACd,KAAA,EACuB;IACvB,IAAI;QACF,OAAO,KAAK,KAAA,CAAM,KAAK;IACzB,EAAA,OAAQ;QACN,OAAO,KAAA;IACT;AACF"}},
    {"offset": {"line": 393, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/cookieStore.ts"],"sourcesContent":["import { isNodeProcess } from 'is-node-process'\nimport { invariant } from 'outvariant'\nimport {\n  Cookie,\n  CookieJar,\n  MemoryCookieStore,\n  type MemoryCookieStoreIndex,\n} from 'tough-cookie'\nimport { jsonParse } from './internal/jsonParse'\n\nclass CookieStore {\n  #storageKey = '__msw-cookie-store__'\n  #jar: CookieJar\n  #memoryStore: MemoryCookieStore\n\n  constructor() {\n    if (!isNodeProcess()) {\n      invariant(\n        typeof localStorage !== 'undefined',\n        'Failed to create a CookieStore: `localStorage` is not available in this environment. This is likely an issue with your environment, which has been detected as browser (or browser-like) environment and must implement global browser APIs correctly.',\n      )\n    }\n\n    this.#memoryStore = new MemoryCookieStore()\n    this.#memoryStore.idx = this.getCookieStoreIndex()\n    this.#jar = new CookieJar(this.#memoryStore)\n  }\n\n  public getCookies(url: string): Array<Cookie> {\n    return this.#jar.getCookiesSync(url)\n  }\n\n  public async setCookie(cookieName: string, url: string): Promise<void> {\n    await this.#jar.setCookie(cookieName, url)\n    this.persist()\n  }\n\n  private getCookieStoreIndex(): MemoryCookieStoreIndex {\n    if (typeof localStorage === 'undefined') {\n      return {}\n    }\n\n    const cookiesString = localStorage.getItem(this.#storageKey)\n    if (cookiesString == null) {\n      return {}\n    }\n\n    const rawCookies = jsonParse<Array<Record<string, unknown>>>(cookiesString)\n    if (rawCookies == null) {\n      return {}\n    }\n\n    const cookies: MemoryCookieStoreIndex = {}\n\n    for (const rawCookie of rawCookies) {\n      const cookie = Cookie.fromJSON(rawCookie)\n\n      if (cookie != null && cookie.domain != null && cookie.path != null) {\n        cookies[cookie.domain] ||= {}\n        cookies[cookie.domain][cookie.path] ||= {}\n        cookies[cookie.domain][cookie.path][cookie.key] = cookie\n      }\n    }\n\n    return cookies\n  }\n\n  private persist(): void {\n    if (typeof localStorage === 'undefined') {\n      return\n    }\n\n    const data = []\n    const { idx } = this.#memoryStore\n\n    for (const domain in idx) {\n      for (const path in idx[domain]) {\n        for (const key in idx[domain][path]) {\n          data.push(idx[domain][path][key].toJSON())\n        }\n      }\n    }\n\n    localStorage.setItem(this.#storageKey, JSON.stringify(data))\n  }\n}\n\nexport const cookieStore = new CookieStore()\n"],"names":[],"mappings":";;;;AAAA,SAAS,qBAAqB;AAC9B,SAAS,iBAAiB;AAC1B;AAMA,SAAS,iBAAiB;;;;;AAE1B,MAAM,YAAY;KAChB,UAAA,GAAc,uBAAA;KACd,GAAA,CAAA;KACA,WAAA,CAAA;IAEA,aAAc;QACZ,IAAI,KAAC,mKAAA,CAAc,IAAG;YACpB,IAAA,oJAAA,EACE,OAAO,iBAAiB,aACxB;QAEJ;QAEA,IAAA,EAAK,WAAA,GAAe,IAAI,wLAAA,CAAkB;QAC1C,IAAA,EAAK,WAAA,CAAa,GAAA,GAAM,IAAA,CAAK,mBAAA,CAAoB;QACjD,IAAA,EAAK,GAAA,GAAO,IAAI,gLAAA,CAAU,IAAA,EAAK,WAAY;IAC7C;IAEO,WAAW,GAAA,EAA4B;QAC5C,OAAO,IAAA,EAAK,GAAA,CAAK,cAAA,CAAe,GAAG;IACrC;IAEA,MAAa,UAAU,UAAA,EAAoB,GAAA,EAA4B;QACrE,MAAM,IAAA,EAAK,GAAA,CAAK,SAAA,CAAU,YAAY,GAAG;QACzC,IAAA,CAAK,OAAA,CAAQ;IACf;IAEQ,sBAA8C;QACpD,IAAI,OAAO,iBAAiB,aAAa;YACvC,OAAO,CAAC;QACV;QAEA,MAAM,gBAAgB,aAAa,OAAA,CAAQ,IAAA,EAAK,UAAW;QAC3D,IAAI,iBAAiB,MAAM;YACzB,OAAO,CAAC;QACV;QAEA,MAAM,iBAAa,8KAAA,EAA0C,aAAa;QAC1E,IAAI,cAAc,MAAM;YACtB,OAAO,CAAC;QACV;QAEA,MAAM,UAAkC,CAAC;QAEzC,KAAA,MAAW,aAAa,WAAY;YAClC,MAAM,SAAS,6KAAA,CAAO,QAAA,CAAS,SAAS;YAExC,IAAI,UAAU,QAAQ,OAAO,MAAA,IAAU,QAAQ,OAAO,IAAA,IAAQ,MAAM;gBAClE,OAAA,CAAQ,OAAO,MAAM,CAAA,KAAM,CAAC;gBAC5B,OAAA,CAAQ,OAAO,MAAM,CAAA,CAAE,OAAO,IAAI,CAAA,KAAM,CAAC;gBACzC,OAAA,CAAQ,OAAO,MAAM,CAAA,CAAE,OAAO,IAAI,CAAA,CAAE,OAAO,GAAG,CAAA,GAAI;YACpD;QACF;QAEA,OAAO;IACT;IAEQ,UAAgB;QACtB,IAAI,OAAO,iBAAiB,aAAa;YACvC;QACF;QAEA,MAAM,OAAO,CAAC,CAAA;QACd,MAAM,EAAE,GAAA,CAAI,CAAA,GAAI,IAAA,EAAK,WAAA;QAErB,IAAA,MAAW,UAAU,IAAK;YACxB,IAAA,MAAW,QAAQ,GAAA,CAAI,MAAM,CAAA,CAAG;gBAC9B,IAAA,MAAW,OAAO,GAAA,CAAI,MAAM,CAAA,CAAE,IAAI,CAAA,CAAG;oBACnC,KAAK,IAAA,CAAK,GAAA,CAAI,MAAM,CAAA,CAAE,IAAI,CAAA,CAAE,GAAG,CAAA,CAAE,MAAA,CAAO,CAAC;gBAC3C;YACF;QACF;QAEA,aAAa,OAAA,CAAQ,IAAA,EAAK,UAAA,EAAa,KAAK,SAAA,CAAU,IAAI,CAAC;IAC7D;AACF;AAEO,MAAM,cAAc,IAAI,YAAY"}},
    {"offset": {"line": 470, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/HttpResponse/decorators.ts"],"sourcesContent":["import statuses from '@bundled-es-modules/statuses'\nimport { Headers as HeadersPolyfill } from 'headers-polyfill'\nimport type { HttpResponseInit } from '../../HttpResponse'\n\nconst { message } = statuses\n\nexport const kSetCookie = Symbol('kSetCookie')\n\nexport interface HttpResponseDecoratedInit extends HttpResponseInit {\n  status: number\n  statusText: string\n  headers: Headers\n}\n\nexport function normalizeResponseInit(\n  init: HttpResponseInit = {},\n): HttpResponseDecoratedInit {\n  const status = init?.status || 200\n  const statusText = init?.statusText || message[status] || ''\n  const headers = new Headers(init?.headers)\n\n  return {\n    ...init,\n    headers,\n    status,\n    statusText,\n  }\n}\n\nexport function decorateResponse(\n  response: Response,\n  init: HttpResponseDecoratedInit,\n): Response {\n  // Allow to mock the response type.\n  if (init.type) {\n    Object.defineProperty(response, 'type', {\n      value: init.type,\n      enumerable: true,\n      writable: false,\n    })\n  }\n\n  const responseCookies = init.headers.get('set-cookie')\n\n  if (responseCookies) {\n    // Record the raw \"Set-Cookie\" response header provided\n    // in the HeadersInit. This is later used to store these cookies\n    // in cookie jar and return the right cookies in the \"cookies\"\n    // response resolver argument.\n    Object.defineProperty(response, kSetCookie, {\n      value: responseCookies,\n      enumerable: false,\n      writable: false,\n    })\n\n    // Cookie forwarding is only relevant in the browser.\n    if (typeof document !== 'undefined') {\n      // Write the mocked response cookies to the document.\n      // Use `headers-polyfill` to get the Set-Cookie header value correctly.\n      // This is an alternative until TypeScript 5.2\n      // and Node.js v20 become the minimum supported version\n      // and getSetCookie in Headers can be used directly.\n      const responseCookiePairs = HeadersPolyfill.prototype.getSetCookie.call(\n        init.headers,\n      )\n\n      for (const cookieString of responseCookiePairs) {\n        // No need to parse the cookie headers because it's defined\n        // as the valid cookie string to begin with.\n        document.cookie = cookieString\n      }\n    }\n  }\n\n  return response\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,OAAO,cAAc;AACrB,SAAS,WAAW,uBAAuB;;;AAG3C,MAAM,EAAE,OAAA,CAAQ,CAAA,GAAI,6KAAA;AAEb,MAAM,aAAa,OAAO,YAAY;AAQtC,SAAS,sBACd,OAAyB,CAAC,CAAA,EACC;IAC3B,MAAM,SAAS,MAAM,UAAU;IAC/B,MAAM,aAAa,MAAM,cAAc,OAAA,CAAQ,MAAM,CAAA,IAAK;IAC1D,MAAM,UAAU,IAAI,QAAQ,MAAM,OAAO;IAEzC,OAAO;QACL,GAAG,IAAA;QACH;QACA;QACA;IACF;AACF;AAEO,SAAS,iBACd,QAAA,EACA,IAAA,EACU;IAEV,IAAI,KAAK,IAAA,EAAM;QACb,OAAO,cAAA,CAAe,UAAU,QAAQ;YACtC,OAAO,KAAK,IAAA;YACZ,YAAY;YACZ,UAAU;QACZ,CAAC;IACH;IAEA,MAAM,kBAAkB,KAAK,OAAA,CAAQ,GAAA,CAAI,YAAY;IAErD,IAAI,iBAAiB;QAKnB,OAAO,cAAA,CAAe,UAAU,YAAY;YAC1C,OAAO;YACP,YAAY;YACZ,UAAU;QACZ,CAAC;QAGD,IAAI,OAAO,aAAa,aAAa;YAMnC,MAAM,sBAAsB,2JAAA,CAAgB,SAAA,CAAU,YAAA,CAAa,IAAA,CACjE,KAAK,OAAA;YAGP,KAAA,MAAW,gBAAgB,oBAAqB;gBAG9C,SAAS,MAAA,GAAS;YACpB;QACF;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 525, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/request/storeResponseCookies.ts"],"sourcesContent":["import { cookieStore } from '../cookieStore'\nimport { kSetCookie } from '../HttpResponse/decorators'\n\nexport async function storeResponseCookies(\n  request: Request,\n  response: Response,\n): Promise<void> {\n  // Grab the raw \"Set-Cookie\" response header provided\n  // in the HeadersInit for this mocked response.\n  const responseCookies = Reflect.get(response, kSetCookie) as\n    | string\n    | undefined\n\n  if (responseCookies) {\n    await cookieStore.setCookie(responseCookies, request.url)\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,mBAAmB;AAC5B,SAAS,kBAAkB;;;AAE3B,eAAsB,qBACpB,OAAA,EACA,QAAA,EACe;IAGf,MAAM,kBAAkB,QAAQ,GAAA,CAAI,UAAU,oLAAU;IAIxD,IAAI,iBAAiB;QACnB,MAAM,sKAAA,CAAY,SAAA,CAAU,iBAAiB,QAAQ,GAAG;IAC1D;AACF"}},
    {"offset": {"line": 545, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/handleRequest.ts"],"sourcesContent":["import { until } from '@open-draft/until'\nimport { Emitter } from 'strict-event-emitter'\nimport { LifeCycleEventsMap, SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport type { RequestHandler } from '../handlers/RequestHandler'\nimport { HandlersExecutionResult, executeHandlers } from './executeHandlers'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { storeResponseCookies } from './request/storeResponseCookies'\n\nexport interface HandleRequestOptions {\n  /**\n   * `resolutionContext` is not part of the general public api\n   * but is exposed to aid in creating extensions like\n   * `@mswjs/http-middleware`.\n   */\n  resolutionContext?: {\n    /**\n     * A base url to use when resolving relative urls.\n     * @note This is primarily used by the `@mswjs/http-middleware`\n     * to resolve relative urls in the context of the running server\n     */\n    baseUrl?: string\n  }\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: Request): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: Response,\n    handler: RequiredDeep<HandlersExecutionResult>,\n  ): void\n}\n\nexport async function handleRequest(\n  request: Request,\n  requestId: string,\n  handlers: Array<RequestHandler>,\n  options: RequiredDeep<SharedOptions>,\n  emitter: Emitter<LifeCycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions,\n): Promise<Response | undefined> {\n  emitter.emit('request:start', { request, requestId })\n\n  // Perform requests wrapped in \"bypass()\" as-is.\n  if (request.headers.get('accept')?.includes('msw/passthrough')) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const lookupResult = await until(() => {\n    return executeHandlers({\n      request,\n      requestId,\n      handlers,\n      resolutionContext: handleRequestOptions?.resolutionContext,\n    })\n  })\n\n  if (lookupResult.error) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', {\n      error: lookupResult.error,\n      request,\n      requestId,\n    })\n    throw lookupResult.error\n  }\n\n  // If the handler lookup returned nothing, no request handler was found\n  // matching this request. Report the request as unhandled.\n  if (!lookupResult.data) {\n    await onUnhandledRequest(request, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', { request, requestId })\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  const { response } = lookupResult.data\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Perform the request as-is when the developer explicitly returned \"req.passthrough()\".\n  // This produces no warning as the request was handled.\n  if (\n    response.status === 302 &&\n    response.headers.get('x-msw-intention') === 'passthrough'\n  ) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the cookie jar.\n  await storeResponseCookies(request, response)\n\n  emitter.emit('request:match', { request, requestId })\n\n  const requiredLookupResult =\n    lookupResult.data as RequiredDeep<HandlersExecutionResult>\n\n  handleRequestOptions?.onMockedResponse?.(response, requiredLookupResult)\n\n  emitter.emit('request:end', { request, requestId })\n\n  return response\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,aAAa;AAKtB,SAAkC,uBAAuB;AACzD,SAAS,0BAA0B;AACnC,SAAS,4BAA4B;;;;;AA+BrC,eAAsB,cACpB,OAAA,EACA,SAAA,EACA,QAAA,EACA,OAAA,EACA,OAAA,EACA,oBAAA,EAC+B;IAC/B,QAAQ,IAAA,CAAK,iBAAiB;QAAE;QAAS;IAAU,CAAC;IAGpD,IAAI,QAAQ,OAAA,CAAQ,GAAA,CAAI,QAAQ,GAAG,SAAS,iBAAiB,GAAG;QAC9D,QAAQ,IAAA,CAAK,eAAe;YAAE;YAAS;QAAU,CAAC;QAClD,sBAAsB,wBAAwB,OAAO;QACrD;IACF;IAGA,MAAM,eAAe,UAAM,8JAAA,EAAM,MAAM;QACrC,WAAO,8KAAA,EAAgB;YACrB;YACA;YACA;YACA,mBAAmB,sBAAsB;QAC3C,CAAC;IACH,CAAC;IAED,IAAI,aAAa,KAAA,EAAO;QAEtB,QAAQ,IAAA,CAAK,sBAAsB;YACjC,OAAO,aAAa,KAAA;YACpB;YACA;QACF,CAAC;QACD,MAAM,aAAa,KAAA;IACrB;IAIA,IAAI,CAAC,aAAa,IAAA,EAAM;QACtB,UAAM,+LAAA,EAAmB,SAAS,QAAQ,kBAAkB;QAC5D,QAAQ,IAAA,CAAK,qBAAqB;YAAE;YAAS;QAAU,CAAC;QACxD,QAAQ,IAAA,CAAK,eAAe;YAAE;YAAS;QAAU,CAAC;QAClD,sBAAsB,wBAAwB,OAAO;QACrD;IACF;IAEA,MAAM,EAAE,QAAA,CAAS,CAAA,GAAI,aAAa,IAAA;IAIlC,IAAI,CAAC,UAAU;QACb,QAAQ,IAAA,CAAK,eAAe;YAAE;YAAS;QAAU,CAAC;QAClD,sBAAsB,wBAAwB,OAAO;QACrD;IACF;IAIA,IACE,SAAS,MAAA,KAAW,OACpB,SAAS,OAAA,CAAQ,GAAA,CAAI,iBAAiB,MAAM,eAC5C;QACA,QAAQ,IAAA,CAAK,eAAe;YAAE;YAAS;QAAU,CAAC;QAClD,sBAAsB,wBAAwB,OAAO;QACrD;IACF;IAGA,UAAM,mMAAA,EAAqB,SAAS,QAAQ;IAE5C,QAAQ,IAAA,CAAK,iBAAiB;QAAE;QAAS;IAAU,CAAC;IAEpD,MAAM,uBACJ,aAAa,IAAA;IAEf,sBAAsB,mBAAmB,UAAU,oBAAoB;IAEvE,QAAQ,IAAA,CAAK,eAAe;QAAE;QAAS;IAAU,CAAC;IAElD,OAAO;AACT"}},
    {"offset": {"line": 635, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/toResponseInit.ts"],"sourcesContent":["export function toResponseInit(response: Response): ResponseInit {\n  return {\n    status: response.status,\n    statusText: response.statusText,\n    headers: Object.fromEntries(response.headers.entries()),\n  }\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,eAAe,QAAA,EAAkC;IAC/D,OAAO;QACL,QAAQ,SAAS,MAAA;QACjB,YAAY,SAAS,UAAA;QACrB,SAAS,OAAO,WAAA,CAAY,SAAS,OAAA,CAAQ,OAAA,CAAQ,CAAC;IACxD;AACF"}},
    {"offset": {"line": 652, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/internal/isHandlerKind.ts"],"sourcesContent":["import type { HandlerKind } from '../../handlers/common'\nimport type { RequestHandler } from '../../handlers/RequestHandler'\nimport type { WebSocketHandler } from '../../handlers/WebSocketHandler'\n\n/**\n * A filter function that ensures that the provided argument\n * is a handler of the given kind. This helps differentiate\n * between different kinds of handlers, e.g. request and event handlers.\n */\nexport function isHandlerKind<K extends HandlerKind>(kind: K) {\n  return (\n    input: unknown,\n  ): input is K extends 'EventHandler' ? WebSocketHandler : RequestHandler => {\n    return (\n      input != null &&\n      typeof input === 'object' &&\n      '__kind' in input &&\n      input.__kind === kind\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AASO,SAAS,cAAqC,IAAA,EAAS;IAC5D,OAAO,CACL,UAC0E;QAC1E,OACE,SAAS,QACT,OAAO,UAAU,YACjB,YAAY,SACZ,MAAM,MAAA,KAAW;IAErB;AACF"}},
    {"offset": {"line": 667, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/internal/pipeEvents.ts"],"sourcesContent":["import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Pipes all emitted events from one emitter to another.\n */\nexport function pipeEvents<Events extends EventMap>(\n  source: Emitter<Events>,\n  destination: Emitter<Events>,\n): void {\n  const rawEmit: typeof source.emit & { _isPiped?: boolean } = source.emit\n\n  if (rawEmit._isPiped) {\n    return\n  }\n\n  const sourceEmit: typeof source.emit & { _isPiped?: boolean } =\n    function sourceEmit(this: typeof source, event, ...data) {\n      destination.emit(event, ...data)\n      return rawEmit.call(this, event, ...data)\n    }\n\n  sourceEmit._isPiped = true\n\n  source.emit = sourceEmit\n}\n"],"names":["sourceEmit"],"mappings":";;;;AAKO,SAAS,WACd,MAAA,EACA,WAAA,EACM;IACN,MAAM,UAAuD,OAAO,IAAA;IAEpE,IAAI,QAAQ,QAAA,EAAU;QACpB;IACF;IAEA,MAAM,aACJ,SAASA,YAAgC,KAAA,EAAA,GAAU,IAAA,EAAM;QACvD,YAAY,IAAA,CAAK,OAAO,GAAG,IAAI;QAC/B,OAAO,QAAQ,IAAA,CAAK,IAAA,EAAM,OAAO,GAAG,IAAI;IAC1C;IAEF,WAAW,QAAA,GAAW;IAEtB,OAAO,IAAA,GAAO;AAChB"}},
    {"offset": {"line": 689, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/internal/toReadonlyArray.ts"],"sourcesContent":["/**\n * Creates an immutable copy of the given array.\n */\nexport function toReadonlyArray<T>(source: Array<T>): ReadonlyArray<T> {\n  const clone = [...source] as Array<T>\n  Object.freeze(clone)\n  return clone\n}\n"],"names":[],"mappings":";;;;AAGO,SAAS,gBAAmB,MAAA,EAAoC;IACrE,MAAM,QAAQ,CAAC;WAAG,MAAM;KAAA;IACxB,OAAO,MAAA,CAAO,KAAK;IACnB,OAAO;AACT"}},
    {"offset": {"line": 706, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/internal/Disposable.ts"],"sourcesContent":["export type DisposableSubscription = () => void\n\nexport class Disposable {\n  protected subscriptions: Array<DisposableSubscription> = []\n\n  public dispose() {\n    let subscription: DisposableSubscription | undefined\n    while ((subscription = this.subscriptions.shift())) {\n      subscription()\n    }\n  }\n}\n"],"names":[],"mappings":";;;;AAEO,MAAM,WAAW;IACZ,gBAA+C,CAAC,CAAA,CAAA;IAEnD,UAAU;QACf,IAAI;QACJ,MAAQ,eAAe,IAAA,CAAK,aAAA,CAAc,KAAA,CAAM,EAAI;YAClD,aAAa;QACf;IACF;AACF"}},
    {"offset": {"line": 725, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/SetupApi.ts"],"sourcesContent":["import { invariant } from 'outvariant'\nimport { EventMap, Emitter } from 'strict-event-emitter'\nimport { RequestHandler } from './handlers/RequestHandler'\nimport { LifeCycleEventEmitter } from './sharedOptions'\nimport { devUtils } from './utils/internal/devUtils'\nimport { pipeEvents } from './utils/internal/pipeEvents'\nimport { toReadonlyArray } from './utils/internal/toReadonlyArray'\nimport { Disposable } from './utils/internal/Disposable'\nimport type { WebSocketHandler } from './handlers/WebSocketHandler'\n\nexport abstract class HandlersController {\n  abstract prepend(\n    runtimeHandlers: Array<RequestHandler | WebSocketHandler>,\n  ): void\n  abstract reset(nextHandles: Array<RequestHandler | WebSocketHandler>): void\n  abstract currentHandlers(): Array<RequestHandler | WebSocketHandler>\n}\n\nexport class InMemoryHandlersController implements HandlersController {\n  private handlers: Array<RequestHandler | WebSocketHandler>\n\n  constructor(\n    private initialHandlers: Array<RequestHandler | WebSocketHandler>,\n  ) {\n    this.handlers = [...initialHandlers]\n  }\n\n  public prepend(\n    runtimeHandles: Array<RequestHandler | WebSocketHandler>,\n  ): void {\n    this.handlers.unshift(...runtimeHandles)\n  }\n\n  public reset(nextHandlers: Array<RequestHandler | WebSocketHandler>): void {\n    this.handlers =\n      nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers]\n  }\n\n  public currentHandlers(): Array<RequestHandler | WebSocketHandler> {\n    return this.handlers\n  }\n}\n\n/**\n * Generic class for the mock API setup.\n */\nexport abstract class SetupApi<EventsMap extends EventMap> extends Disposable {\n  protected handlersController: HandlersController\n  protected readonly emitter: Emitter<EventsMap>\n  protected readonly publicEmitter: Emitter<EventsMap>\n\n  public readonly events: LifeCycleEventEmitter<EventsMap>\n\n  constructor(...initialHandlers: Array<RequestHandler | WebSocketHandler>) {\n    super()\n\n    invariant(\n      this.validateHandlers(initialHandlers),\n      devUtils.formatMessage(\n        `Failed to apply given request handlers: invalid input. Did you forget to spread the request handlers Array?`,\n      ),\n    )\n\n    this.handlersController = new InMemoryHandlersController(initialHandlers)\n\n    this.emitter = new Emitter<EventsMap>()\n    this.publicEmitter = new Emitter<EventsMap>()\n    pipeEvents(this.emitter, this.publicEmitter)\n\n    this.events = this.createLifeCycleEvents()\n\n    this.subscriptions.push(() => {\n      this.emitter.removeAllListeners()\n      this.publicEmitter.removeAllListeners()\n    })\n  }\n\n  private validateHandlers(handlers: ReadonlyArray<unknown>): boolean {\n    // Guard against incorrect call signature of the setup API.\n    return handlers.every((handler) => !Array.isArray(handler))\n  }\n\n  public use(\n    ...runtimeHandlers: Array<RequestHandler | WebSocketHandler>\n  ): void {\n    invariant(\n      this.validateHandlers(runtimeHandlers),\n      devUtils.formatMessage(\n        `Failed to call \"use()\" with the given request handlers: invalid input. Did you forget to spread the array of request handlers?`,\n      ),\n    )\n\n    this.handlersController.prepend(runtimeHandlers)\n  }\n\n  public restoreHandlers(): void {\n    this.handlersController.currentHandlers().forEach((handler) => {\n      if ('isUsed' in handler) {\n        handler.isUsed = false\n      }\n    })\n  }\n\n  public resetHandlers(\n    ...nextHandlers: Array<RequestHandler | WebSocketHandler>\n  ): void {\n    this.handlersController.reset(nextHandlers)\n  }\n\n  public listHandlers(): ReadonlyArray<RequestHandler | WebSocketHandler> {\n    return toReadonlyArray(this.handlersController.currentHandlers())\n  }\n\n  private createLifeCycleEvents(): LifeCycleEventEmitter<EventsMap> {\n    return {\n      on: (...args: any[]) => {\n        return (this.publicEmitter.on as any)(...args)\n      },\n      removeListener: (...args: any[]) => {\n        return (this.publicEmitter.removeListener as any)(...args)\n      },\n      removeAllListeners: (...args: any[]) => {\n        return this.publicEmitter.removeAllListeners(...args)\n      },\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,SAAS,iBAAiB;AAC1B,SAAmB,eAAe;AAGlC,SAAS,gBAAgB;AACzB,SAAS,kBAAkB;AAC3B,SAAS,uBAAuB;AAChC,SAAS,kBAAkB;;;;;;;AAGpB,MAAe,mBAAmB;AAMzC;AAEO,MAAM,2BAAyD;IAGpE,YACU,eAAA,CACR;QADQ,IAAA,CAAA,eAAA,GAAA;QAER,IAAA,CAAK,QAAA,GAAW,CAAC;eAAG,eAAe;SAAA;IACrC;IANQ,SAAA;IAQD,QACL,cAAA,EACM;QACN,IAAA,CAAK,QAAA,CAAS,OAAA,CAAQ,GAAG,cAAc;IACzC;IAEO,MAAM,YAAA,EAA8D;QACzE,IAAA,CAAK,QAAA,GACH,aAAa,MAAA,GAAS,IAAI,CAAC;eAAG,YAAY;SAAA,GAAI,CAAC;eAAG,IAAA,CAAK,eAAe;SAAA;IAC1E;IAEO,kBAA4D;QACjE,OAAO,IAAA,CAAK,QAAA;IACd;AACF;AAKO,MAAe,iBAA6C,gLAAA,CAAW;IAClE,mBAAA;IACS,QAAA;IACA,cAAA;IAEH,OAAA;IAEhB,YAAA,GAAe,eAAA,CAA2D;QACxE,KAAA,CAAM;QAEN,IAAA,oJAAA,EACE,IAAA,CAAK,gBAAA,CAAiB,eAAe,GACrC,4KAAA,CAAS,aAAA,CACP,CAAA,2GAAA,CAAA;QAIJ,IAAA,CAAK,kBAAA,GAAqB,IAAI,2BAA2B,eAAe;QAExE,IAAA,CAAK,OAAA,GAAU,IAAI,kKAAA,CAAmB;QACtC,IAAA,CAAK,aAAA,GAAgB,IAAI,kKAAA,CAAmB;QAC5C,IAAA,gLAAA,EAAW,IAAA,CAAK,OAAA,EAAS,IAAA,CAAK,aAAa;QAE3C,IAAA,CAAK,MAAA,GAAS,IAAA,CAAK,qBAAA,CAAsB;QAEzC,IAAA,CAAK,aAAA,CAAc,IAAA,CAAK,MAAM;YAC5B,IAAA,CAAK,OAAA,CAAQ,kBAAA,CAAmB;YAChC,IAAA,CAAK,aAAA,CAAc,kBAAA,CAAmB;QACxC,CAAC;IACH;IAEQ,iBAAiB,QAAA,EAA2C;QAElE,OAAO,SAAS,KAAA,CAAM,CAAC,UAAY,CAAC,MAAM,OAAA,CAAQ,OAAO,CAAC;IAC5D;IAEO,IAAA,GACF,eAAA,EACG;QACN,IAAA,oJAAA,EACE,IAAA,CAAK,gBAAA,CAAiB,eAAe,GACrC,4KAAA,CAAS,aAAA,CACP,CAAA,8HAAA,CAAA;QAIJ,IAAA,CAAK,kBAAA,CAAmB,OAAA,CAAQ,eAAe;IACjD;IAEO,kBAAwB;QAC7B,IAAA,CAAK,kBAAA,CAAmB,eAAA,CAAgB,EAAE,OAAA,CAAQ,CAAC,YAAY;YAC7D,IAAI,YAAY,SAAS;gBACvB,QAAQ,MAAA,GAAS;YACnB;QACF,CAAC;IACH;IAEO,cAAA,GACF,YAAA,EACG;QACN,IAAA,CAAK,kBAAA,CAAmB,KAAA,CAAM,YAAY;IAC5C;IAEO,eAAiE;QACtE,WAAO,0LAAA,EAAgB,IAAA,CAAK,kBAAA,CAAmB,eAAA,CAAgB,CAAC;IAClE;IAEQ,wBAA0D;QAChE,OAAO;YACL,IAAI,CAAA,GAAI,SAAgB;gBACtB,OAAQ,IAAA,CAAK,aAAA,CAAc,EAAA,CAAW,GAAG,IAAI;YAC/C;YACA,gBAAgB,CAAA,GAAI,SAAgB;gBAClC,OAAQ,IAAA,CAAK,aAAA,CAAc,cAAA,CAAuB,GAAG,IAAI;YAC3D;YACA,oBAAoB,CAAA,GAAI,SAAgB;gBACtC,OAAO,IAAA,CAAK,aAAA,CAAc,kBAAA,CAAmB,GAAG,IAAI;YACtD;QACF;IACF;AACF"}},
    {"offset": {"line": 827, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/internal/isObject.ts"],"sourcesContent":["/**\n * Determines if the given value is an object.\n */\nexport function isObject(value: any): boolean {\n  return value != null && typeof value === 'object' && !Array.isArray(value)\n}\n"],"names":[],"mappings":";;;;AAGO,SAAS,SAAS,KAAA,EAAqB;IAC5C,OAAO,SAAS,QAAQ,OAAO,UAAU,YAAY,CAAC,MAAM,OAAA,CAAQ,KAAK;AAC3E"}},
    {"offset": {"line": 840, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/internal/mergeRight.ts"],"sourcesContent":["import { isObject } from './isObject'\n\n/**\n * Deeply merges two given objects with the right one\n * having a priority during property assignment.\n */\nexport function mergeRight(\n  left: Record<string, any>,\n  right: Record<string, any>,\n) {\n  return Object.entries(right).reduce(\n    (result, [key, rightValue]) => {\n      const leftValue = result[key]\n\n      if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n        result[key] = leftValue.concat(rightValue)\n        return result\n      }\n\n      if (isObject(leftValue) && isObject(rightValue)) {\n        result[key] = mergeRight(leftValue, rightValue)\n        return result\n      }\n\n      result[key] = rightValue\n      return result\n    },\n    Object.assign({}, left),\n  )\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,gBAAgB;;AAMlB,SAAS,WACd,IAAA,EACA,KAAA,EACA;IACA,OAAO,OAAO,OAAA,CAAQ,KAAK,EAAE,MAAA,CAC3B,CAAC,QAAQ,CAAC,KAAK,UAAU,CAAA,KAAM;QAC7B,MAAM,YAAY,MAAA,CAAO,GAAG,CAAA;QAE5B,IAAI,MAAM,OAAA,CAAQ,SAAS,KAAK,MAAM,OAAA,CAAQ,UAAU,GAAG;YACzD,MAAA,CAAO,GAAG,CAAA,GAAI,UAAU,MAAA,CAAO,UAAU;YACzC,OAAO;QACT;QAEA,QAAI,4KAAA,EAAS,SAAS,SAAK,4KAAA,EAAS,UAAU,GAAG;YAC/C,MAAA,CAAO,GAAG,CAAA,GAAI,WAAW,WAAW,UAAU;YAC9C,OAAO;QACT;QAEA,MAAA,CAAO,GAAG,CAAA,GAAI;QACd,OAAO;IACT,GACA,OAAO,MAAA,CAAO,CAAC,GAAG,IAAI;AAE1B"}},
    {"offset": {"line": 867, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/ws/webSocketInterceptor.ts"],"sourcesContent":["import { WebSocketInterceptor } from '@mswjs/interceptors/WebSocket'\n\nexport const webSocketInterceptor = new WebSocketInterceptor()\n"],"names":[],"mappings":";;;;AAAA,SAAS,4BAA4B;;AAE9B,MAAM,uBAAuB,IAAI,oNAAA,CAAqB"}},
    {"offset": {"line": 880, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/ws/handleWebSocketEvent.ts"],"sourcesContent":["import type { WebSocketConnectionData } from '@mswjs/interceptors/lib/browser/interceptors/WebSocket'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { WebSocketHandler } from '../handlers/WebSocketHandler'\nimport { webSocketInterceptor } from './webSocketInterceptor'\nimport {\n  onUnhandledRequest,\n  UnhandledRequestStrategy,\n} from '../utils/request/onUnhandledRequest'\nimport { isHandlerKind } from '../utils/internal/isHandlerKind'\n\ninterface HandleWebSocketEventOptions {\n  getUnhandledRequestStrategy: () => UnhandledRequestStrategy\n  getHandlers: () => Array<RequestHandler | WebSocketHandler>\n  onMockedConnection: (connection: WebSocketConnectionData) => void\n  onPassthroughConnection: (onnection: WebSocketConnectionData) => void\n}\n\nexport function handleWebSocketEvent(options: HandleWebSocketEventOptions) {\n  webSocketInterceptor.on('connection', async (connection) => {\n    const handlers = options.getHandlers().filter(isHandlerKind('EventHandler'))\n\n    // Ignore this connection if the user hasn't defined any handlers.\n    if (handlers.length > 0) {\n      options?.onMockedConnection(connection)\n\n      await Promise.all(\n        handlers.map((handler) => {\n          // Iterate over the handlers and forward the connection\n          // event to WebSocket event handlers. This is equivalent\n          // to dispatching that event onto multiple listeners.\n          return handler.run(connection)\n        }),\n      )\n\n      return\n    }\n\n    // Construct a request representing this WebSocket connection.\n    const request = new Request(connection.client.url, {\n      headers: {\n        upgrade: 'websocket',\n        connection: 'upgrade',\n      },\n    })\n    await onUnhandledRequest(\n      request,\n      options.getUnhandledRequestStrategy(),\n    ).catch((error) => {\n      const errorEvent = new Event('error')\n      Object.defineProperty(errorEvent, 'cause', {\n        enumerable: true,\n        configurable: false,\n        value: error,\n      })\n      connection.client.socket.dispatchEvent(errorEvent)\n    })\n\n    options?.onPassthroughConnection(connection)\n\n    // If none of the \"ws\" handlers matched,\n    // establish the WebSocket connection as-is.\n    connection.server.connect()\n  })\n}\n"],"names":[],"mappings":";;;;AAGA,SAAS,4BAA4B;AACrC;AAIA,SAAS,qBAAqB;;;;AASvB,SAAS,qBAAqB,OAAA,EAAsC;IACzE,qLAAA,CAAqB,EAAA,CAAG,cAAc,OAAO,eAAe;QAC1D,MAAM,WAAW,QAAQ,WAAA,CAAY,EAAE,MAAA,KAAO,sLAAA,EAAc,cAAc,CAAC;QAG3E,IAAI,SAAS,MAAA,GAAS,GAAG;YACvB,SAAS,mBAAmB,UAAU;YAEtC,MAAM,QAAQ,GAAA,CACZ,SAAS,GAAA,CAAI,CAAC,YAAY;gBAIxB,OAAO,QAAQ,GAAA,CAAI,UAAU;YAC/B,CAAC;YAGH;QACF;QAGA,MAAM,UAAU,IAAI,QAAQ,WAAW,MAAA,CAAO,GAAA,EAAK;YACjD,SAAS;gBACP,SAAS;gBACT,YAAY;YACd;QACF,CAAC;QACD,UAAM,+LAAA,EACJ,SACA,QAAQ,2BAAA,CAA4B,GACpC,KAAA,CAAM,CAAC,UAAU;YACjB,MAAM,aAAa,IAAI,MAAM,OAAO;YACpC,OAAO,cAAA,CAAe,YAAY,SAAS;gBACzC,YAAY;gBACZ,cAAc;gBACd,OAAO;YACT,CAAC;YACD,WAAW,MAAA,CAAO,MAAA,CAAO,aAAA,CAAc,UAAU;QACnD,CAAC;QAED,SAAS,wBAAwB,UAAU;QAI3C,WAAW,MAAA,CAAO,OAAA,CAAQ;IAC5B,CAAC;AACH"}},
    {"offset": {"line": 925, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/logging/getTimestamp.ts"],"sourcesContent":["interface GetTimestampOptions {\n  milliseconds?: boolean\n}\n\n/**\n * Returns a timestamp string in a \"HH:MM:SS\" format.\n */\nexport function getTimestamp(options?: GetTimestampOptions): string {\n  const now = new Date()\n  const timestamp = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`\n\n  if (options?.milliseconds) {\n    return `${timestamp}.${now.getMilliseconds().toString().padStart(3, '0')}`\n  }\n\n  return timestamp\n}\n"],"names":[],"mappings":";;;;AAOO,SAAS,aAAa,OAAA,EAAuC;IAClE,MAAM,MAAM,aAAA,GAAA,IAAI,KAAK;IACrB,MAAM,YAAY,GAAG,IAAI,QAAA,CAAS,EAAE,QAAA,CAAS,EAAE,QAAA,CAAS,GAAG,GAAG,CAAC,CAAA,CAAA,EAAI,IAAI,UAAA,CAAW,EAAE,QAAA,CAAS,EAAE,QAAA,CAAS,GAAG,GAAG,CAAC,CAAA,CAAA,EAAI,IAAI,UAAA,CAAW,EAAE,QAAA,CAAS,EAAE,QAAA,CAAS,GAAG,GAAG,CAAC,EAAA;IAE/J,IAAI,SAAS,cAAc;QACzB,OAAO,GAAG,SAAS,CAAA,CAAA,EAAI,IAAI,eAAA,CAAgB,EAAE,QAAA,CAAS,EAAE,QAAA,CAAS,GAAG,GAAG,CAAC,EAAA;IAC1E;IAEA,OAAO;AACT"}},
    {"offset": {"line": 943, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/ws/utils/getMessageLength.ts"],"sourcesContent":["import type { WebSocketData } from '@mswjs/interceptors/lib/browser/interceptors/WebSocket'\n\n/**\n * Returns the byte length of the given WebSocket message.\n * @example\n * getMessageLength('hello') // 5\n * getMessageLength(new Blob(['hello'])) // 5\n */\nexport function getMessageLength(data: WebSocketData): number {\n  if (data instanceof Blob) {\n    return data.size\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data.byteLength\n  }\n\n  return new Blob([data as any]).size\n}\n"],"names":[],"mappings":";;;;AAQO,SAAS,iBAAiB,IAAA,EAA6B;IAC5D,IAAI,gBAAgB,MAAM;QACxB,OAAO,KAAK,IAAA;IACd;IAEA,IAAI,gBAAgB,aAAa;QAC/B,OAAO,KAAK,UAAA;IACd;IAEA,OAAO,IAAI,KAAK;QAAC,IAAW;KAAC,EAAE,IAAA;AACjC"}},
    {"offset": {"line": 964, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/ws/utils/truncateMessage.ts"],"sourcesContent":["const MAX_LENGTH = 24\n\nexport function truncateMessage(message: string): string {\n  if (message.length <= MAX_LENGTH) {\n    return message\n  }\n\n  return `${message.slice(0, MAX_LENGTH)}`\n}\n"],"names":[],"mappings":";;;;AAAA,MAAM,aAAa;AAEZ,SAAS,gBAAgB,OAAA,EAAyB;IACvD,IAAI,QAAQ,MAAA,IAAU,YAAY;QAChC,OAAO;IACT;IAEA,OAAO,GAAG,QAAQ,KAAA,CAAM,GAAG,UAAU,CAAC,CAAA,MAAA,CAAA;AACxC"}},
    {"offset": {"line": 981, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/ws/utils/getPublicData.ts"],"sourcesContent":["import { WebSocketData } from '@mswjs/interceptors/WebSocket'\nimport { truncateMessage } from './truncateMessage'\n\nexport async function getPublicData(data: WebSocketData): Promise<string> {\n  if (data instanceof Blob) {\n    const text = await data.text()\n    return `Blob(${truncateMessage(text)})`\n  }\n\n  // Handle all ArrayBuffer-like objects.\n  if (typeof data === 'object' && 'byteLength' in data) {\n    const text = new TextDecoder().decode(data as ArrayBuffer)\n    return `ArrayBuffer(${truncateMessage(text)})`\n  }\n\n  return truncateMessage(data)\n}\n"],"names":[],"mappings":";;;;AACA,SAAS,uBAAuB;;AAEhC,eAAsB,cAAc,IAAA,EAAsC;IACxE,IAAI,gBAAgB,MAAM;QACxB,MAAM,OAAO,MAAM,KAAK,IAAA,CAAK;QAC7B,OAAO,CAAA,KAAA,MAAQ,oLAAA,EAAgB,IAAI,CAAC,CAAA,CAAA,CAAA;IACtC;IAGA,IAAI,OAAO,SAAS,YAAY,gBAAgB,MAAM;QACpD,MAAM,OAAO,IAAI,YAAY,EAAE,MAAA,CAAO,IAAmB;QACzD,OAAO,CAAA,YAAA,MAAe,oLAAA,EAAgB,IAAI,CAAC,CAAA,CAAA,CAAA;IAC7C;IAEA,WAAO,oLAAA,EAAgB,IAAI;AAC7B"}},
    {"offset": {"line": 1004, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/ws/utils/attachWebSocketLogger.ts"],"sourcesContent":["import type {\n  WebSocketClientConnection,\n  WebSocketConnectionData,\n  WebSocketData,\n} from '@mswjs/interceptors/WebSocket'\nimport { devUtils } from '../../utils/internal/devUtils'\nimport { getTimestamp } from '../../utils/logging/getTimestamp'\nimport { toPublicUrl } from '../../utils/request/toPublicUrl'\nimport { getMessageLength } from './getMessageLength'\nimport { getPublicData } from './getPublicData'\n\nconst colors = {\n  system: '#3b82f6',\n  outgoing: '#22c55e',\n  incoming: '#ef4444',\n  mocked: '#ff6a33',\n}\n\nexport function attachWebSocketLogger(\n  connection: WebSocketConnectionData,\n): void {\n  const { client, server } = connection\n\n  logConnectionOpen(client)\n\n  // Log the events sent from the WebSocket client.\n  // WebSocket client connection object is written from the\n  // server's perspective so these message events are outgoing.\n  /**\n   * @todo Provide the reference to the exact event handler\n   * that called this `client.send()`.\n   */\n  client.addEventListener('message', (event) => {\n    logOutgoingClientMessage(event)\n  })\n\n  client.addEventListener('close', (event) => {\n    logConnectionClose(event)\n  })\n\n  // Log client errors (connection closures due to errors).\n  client.socket.addEventListener('error', (event) => {\n    logClientError(event)\n  })\n\n  client.send = new Proxy(client.send, {\n    apply(target, thisArg, args) {\n      const [data] = args\n      const messageEvent = new MessageEvent('message', { data })\n      Object.defineProperties(messageEvent, {\n        currentTarget: {\n          enumerable: true,\n          writable: false,\n          value: client.socket,\n        },\n        target: {\n          enumerable: true,\n          writable: false,\n          value: client.socket,\n        },\n      })\n\n      queueMicrotask(() => {\n        logIncomingMockedClientMessage(messageEvent)\n      })\n\n      return Reflect.apply(target, thisArg, args)\n    },\n  })\n\n  server.addEventListener(\n    'open',\n    () => {\n      server.addEventListener('message', (event) => {\n        logIncomingServerMessage(event)\n      })\n    },\n    { once: true },\n  )\n\n  // Log outgoing client events initiated by the event handler.\n  // The actual client never sent these but the handler did.\n  server.send = new Proxy(server.send, {\n    apply(target, thisArg, args) {\n      const [data] = args\n      const messageEvent = new MessageEvent('message', { data })\n      Object.defineProperties(messageEvent, {\n        currentTarget: {\n          enumerable: true,\n          writable: false,\n          value: server.socket,\n        },\n        target: {\n          enumerable: true,\n          writable: false,\n          value: server.socket,\n        },\n      })\n\n      logOutgoingMockedClientMessage(messageEvent)\n\n      return Reflect.apply(target, thisArg, args)\n    },\n  })\n}\n\n/**\n * Prints the WebSocket connection.\n * This is meant to be logged by every WebSocket handler\n * that intercepted this connection. This helps you see\n * what handlers observe this connection.\n */\nexport function logConnectionOpen(client: WebSocketClientConnection) {\n  const publicUrl = toPublicUrl(client.url)\n\n  console.groupCollapsed(\n    devUtils.formatMessage(`${getTimestamp()} %c%c ${publicUrl}`),\n    `color:${colors.system}`,\n    'color:inherit',\n  )\n  // eslint-disable-next-line no-console\n  console.log('Client:', client.socket)\n  console.groupEnd()\n}\n\nfunction logConnectionClose(event: CloseEvent) {\n  const target = event.target as WebSocket\n  const publicUrl = toPublicUrl(target.url)\n\n  console.groupCollapsed(\n    devUtils.formatMessage(\n      `${getTimestamp({ milliseconds: true })} %c%c ${publicUrl}`,\n    ),\n    `color:${colors.system}`,\n    'color:inherit',\n  )\n  // eslint-disable-next-line no-console\n  console.log(event)\n  console.groupEnd()\n}\n\nfunction logClientError(event: Event) {\n  const socket = event.target as WebSocket\n  const publicUrl = toPublicUrl(socket.url)\n\n  console.groupCollapsed(\n    devUtils.formatMessage(\n      `${getTimestamp({ milliseconds: true })} %c\\u00D7%c ${publicUrl}`,\n    ),\n    `color:${colors.system}`,\n    'color:inherit',\n  )\n  // eslint-disable-next-line no-console\n  console.log(event)\n  console.groupEnd()\n}\n\n/**\n * Prints the outgoing client message.\n */\nasync function logOutgoingClientMessage(event: MessageEvent<WebSocketData>) {\n  const byteLength = getMessageLength(event.data)\n  const publicData = await getPublicData(event.data)\n  const arrow = event.defaultPrevented ? '' : ''\n\n  console.groupCollapsed(\n    devUtils.formatMessage(\n      `${getTimestamp({ milliseconds: true })} %c${arrow}%c ${publicData} %c${byteLength}%c`,\n    ),\n    `color:${colors.outgoing}`,\n    'color:inherit',\n    'color:gray;font-weight:normal',\n    'color:inherit;font-weight:inherit',\n  )\n  // eslint-disable-next-line no-console\n  console.log(event)\n  console.groupEnd()\n}\n\n/**\n * Prints the outgoing client message initiated\n * by `server.send()` in the event handler.\n */\nasync function logOutgoingMockedClientMessage(\n  event: MessageEvent<WebSocketData>,\n) {\n  const byteLength = getMessageLength(event.data)\n  const publicData = await getPublicData(event.data)\n\n  console.groupCollapsed(\n    devUtils.formatMessage(\n      `${getTimestamp({ milliseconds: true })} %c%c ${publicData} %c${byteLength}%c`,\n    ),\n    `color:${colors.mocked}`,\n    'color:inherit',\n    'color:gray;font-weight:normal',\n    'color:inherit;font-weight:inherit',\n  )\n  // eslint-disable-next-line no-console\n  console.log(event)\n  console.groupEnd()\n}\n\n/**\n * Prints the outgoing client message initiated\n * by `client.send()` in the event handler.\n */\nasync function logIncomingMockedClientMessage(\n  event: MessageEvent<WebSocketData>,\n) {\n  const byteLength = getMessageLength(event.data)\n  const publicData = await getPublicData(event.data)\n\n  console.groupCollapsed(\n    devUtils.formatMessage(\n      `${getTimestamp({ milliseconds: true })} %c%c ${publicData} %c${byteLength}%c`,\n    ),\n    `color:${colors.mocked}`,\n    'color:inherit',\n    'color:gray;font-weight:normal',\n    'color:inherit;font-weight:inherit',\n  )\n  // eslint-disable-next-line no-console\n  console.log(event)\n  console.groupEnd()\n}\n\nasync function logIncomingServerMessage(event: MessageEvent<WebSocketData>) {\n  const byteLength = getMessageLength(event.data)\n  const publicData = await getPublicData(event.data)\n  const arrow = event.defaultPrevented ? '' : ''\n\n  console.groupCollapsed(\n    devUtils.formatMessage(\n      `${getTimestamp({ milliseconds: true })} %c${arrow}%c ${publicData} %c${byteLength}%c`,\n    ),\n    `color:${colors.incoming}`,\n    'color:inherit',\n    'color:gray;font-weight:normal',\n    'color:inherit;font-weight:inherit',\n  )\n  // eslint-disable-next-line no-console\n  console.log(event)\n  console.groupEnd()\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1160, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/outvariant%401.4.3/node_modules/outvariant/src/format.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/outvariant%401.4.3/node_modules/outvariant/src/invariant.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/is-node-process%401.2.0/node_modules/is-node-process/src/index.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/setupWorker/start/utils/prepareStartHandler.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/setupWorker/start/createStartHandler.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40open-draft%2Buntil%402.1.0/node_modules/%40open-draft/until/src/until.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/setupWorker/start/utils/getWorkerInstance.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/utils/getAbsoluteWorkerUrl.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/setupWorker/start/utils/getWorkerByRegistration.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40open-draft%2Bdeferred-promise%402.2.0/node_modules/%40open-draft/deferred-promise/src/createDeferredExecutor.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40open-draft%2Bdeferred-promise%402.2.0/node_modules/%40open-draft/deferred-promise/src/DeferredPromise.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/setupWorker/start/utils/printStartMessage.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/setupWorker/start/utils/enableMocking.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/utils/pruneGetRequestBody.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/utils/deserializeRequest.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/setupWorker/start/createRequestListener.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/utils/checkWorkerIntegrity.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/utils/bufferUtils.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/glossary.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/utils/canParseUrl.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/utils/getValueBySymbol.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/utils/fetchUtils.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/getRawRequest.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40open-draft%2Blogger%400.3.0/node_modules/%40open-draft/logger/lib/index.mjs","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/strict-event-emitter%400.5.1/node_modules/strict-event-emitter/src/MemoryLeakError.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/strict-event-emitter%400.5.1/node_modules/strict-event-emitter/src/Emitter.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/Interceptor.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/createRequestId.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/BatchInterceptor.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/utils/getCleanUrl.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/setupWorker/start/createResponseListener.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/setupWorker/start/utils/validateWorkerScope.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/setupWorker/setupWorker.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/utils/supportsReadableStreamTransfer.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/rettime%400.7.0/node_modules/rettime/src/index.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/utils/workerChannel.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/RequestController.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/InterceptorError.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/utils/emitAsync.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/utils/handleRequest.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/utils/isObject.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/utils/isPropertyAccessible.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/utils/responseUtils.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/utils/isNodeLikeError.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/utils/hasConfigurableGlobal.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/interceptors/fetch/index.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/interceptors/fetch/utils/createNetworkError.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/interceptors/fetch/utils/followRedirect.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/interceptors/fetch/utils/brotli-decompress.browser.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/interceptors/fetch/utils/decompression.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/interceptors/XMLHttpRequest/index.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/interceptors/XMLHttpRequest/XMLHttpRequestController.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/concatArrayBuffer.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/interceptors/XMLHttpRequest/polyfills/EventPolyfill.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/interceptors/XMLHttpRequest/polyfills/ProgressEventPolyfill.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/createEvent.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/utils/findPropertySource.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/utils/createProxy.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/isDomParserSupportedType.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/utils/parseJson.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/createResponse.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/getBodyByteLength.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/node_modules/.pnpm/%40mswjs%2Binterceptors%400.39.1/node_modules/%40mswjs/interceptors/src/interceptors/XMLHttpRequest/XMLHttpRequestProxy.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/setupWorker/start/createFallbackRequestListener.ts","file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/browser/setupWorker/stop/utils/printStopMessage.ts"],"sourcesContent":["const POSITIONALS_EXP = /(%?)(%([sdijo]))/g\n\nfunction serializePositional(positional: any, flag: string): any {\n  switch (flag) {\n    // Strings.\n    case 's':\n      return positional\n\n    // Digits.\n    case 'd':\n    case 'i':\n      return Number(positional)\n\n    // JSON.\n    case 'j':\n      return JSON.stringify(positional)\n\n    // Objects.\n    case 'o': {\n      // Preserve stings to prevent extra quotes around them.\n      if (typeof positional === 'string') {\n        return positional\n      }\n\n      const json = JSON.stringify(positional)\n\n      // If the positional isn't serializable, return it as-is.\n      if (json === '{}' || json === '[]' || /^\\[object .+?\\]$/.test(json)) {\n        return positional\n      }\n\n      return json\n    }\n  }\n}\n\nexport function format(message: string, ...positionals: any[]): string {\n  if (positionals.length === 0) {\n    return message\n  }\n\n  let positionalIndex = 0\n  let formattedMessage = message.replace(\n    POSITIONALS_EXP,\n    (match, isEscaped, _, flag) => {\n      const positional = positionals[positionalIndex]\n      const value = serializePositional(positional, flag)\n\n      if (!isEscaped) {\n        positionalIndex++\n        return value\n      }\n\n      return match\n    }\n  )\n\n  // Append unresolved positionals to string as-is.\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(' ')}`\n  }\n\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, '%')\n\n  return formattedMessage\n}\n","import { format } from './format'\n\nconst STACK_FRAMES_TO_IGNORE = 2\n\n/**\n * Remove the \"outvariant\" package trace from the given error.\n * This scopes down the error stack to the relevant parts\n * when used in other applications.\n */\nfunction cleanErrorStack(error: Error): void {\n  if (!error.stack) {\n    return\n  }\n\n  const nextStack = error.stack.split('\\n')\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE)\n  error.stack = nextStack.join('\\n')\n}\n\nexport class InvariantError extends Error {\n  name = 'Invariant Violation'\n\n  constructor(public readonly message: string, ...positionals: any[]) {\n    super(message)\n    this.message = format(message, ...positionals)\n    cleanErrorStack(this)\n  }\n}\n\nexport interface CustomErrorConstructor {\n  new (message: string): Error\n}\n\nexport interface CustomErrorFactory {\n  (message: string): Error\n}\n\nexport type CustomError = CustomErrorConstructor | CustomErrorFactory\n\ntype Invariant = {\n  (\n    predicate: unknown,\n    message: string,\n    ...positionals: any[]\n  ): asserts predicate\n\n  as(\n    ErrorConstructor: CustomError,\n    predicate: unknown,\n    message: string,\n    ...positionals: unknown[]\n  ): asserts predicate\n}\n\nexport const invariant: Invariant = (\n  predicate,\n  message,\n  ...positionals\n): asserts predicate => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals)\n  }\n}\n\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage =\n      positionals.length === 0 ? message : format(message, ...positionals)\n    let error: Error\n\n    try {\n      error = Reflect.construct(ErrorConstructor as CustomErrorConstructor, [\n        formatMessage,\n      ])\n    } catch (err) {\n      error = (ErrorConstructor as CustomErrorFactory)(formatMessage)\n    }\n\n    throw error\n  }\n}\n","/**\n * Determines if the current process is a Node.js process.\n */\nexport function isNodeProcess(): boolean {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return true\n  }\n\n  if (typeof process !== 'undefined') {\n    // Electron (https://www.electronjs.org/docs/latest/api/process#processtype-readonly)\n    const type = (process as any).type\n    if (type === 'renderer' || type === 'worker') {\n      return false\n    }\n\n\n    return !!(\n      process.versions &&\n      process.versions.node\n    )\n  }\n\n  return false\n}\n","import { RequiredDeep } from '~/core/typeUtils'\nimport { mergeRight } from '~/core/utils/internal/mergeRight'\nimport {\n  SetupWorker,\n  SetupWorkerInternalContext,\n  StartHandler,\n  StartOptions,\n} from '../../glossary'\n\nexport const DEFAULT_START_OPTIONS: RequiredDeep<StartOptions> = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null as any,\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'warn',\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl\n  },\n}\n\n/**\n * Returns resolved worker start options, merging the default options\n * with the given custom options.\n */\nexport function resolveStartOptions(\n  initialOptions?: StartOptions,\n): RequiredDeep<StartOptions> {\n  return mergeRight(\n    DEFAULT_START_OPTIONS,\n    initialOptions || {},\n  ) as RequiredDeep<StartOptions>\n}\n\nexport function prepareStartHandler(\n  handler: StartHandler,\n  context: SetupWorkerInternalContext,\n): SetupWorker['start'] {\n  return (initialOptions) => {\n    context.startOptions = resolveStartOptions(initialOptions)\n    return handler(context.startOptions, initialOptions || {})\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport { getWorkerInstance } from './utils/getWorkerInstance'\nimport { enableMocking } from './utils/enableMocking'\nimport type { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { createRequestListener } from './createRequestListener'\nimport { checkWorkerIntegrity } from '../../utils/checkWorkerIntegrity'\nimport { createResponseListener } from './createResponseListener'\nimport { validateWorkerScope } from './utils/validateWorkerScope'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\n\nexport const createStartHandler = (\n  context: SetupWorkerInternalContext,\n): StartHandler => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      // Remove all previously existing event listeners.\n      // This way none of the listeners persists between Fast refresh\n      // of the application's code.\n      context.workerChannel.removeAllListeners()\n\n      // Handle requests signaled by the worker.\n      context.workerChannel.on(\n        'REQUEST',\n        createRequestListener(context, options),\n      )\n\n      // Handle responses signaled by the worker.\n      context.workerChannel.on('RESPONSE', createResponseListener(context))\n\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker,\n      )\n\n      const [worker, registration] = instance\n\n      if (!worker) {\n        const missingWorkerMessage = customOptions?.findWorker\n          ? devUtils.formatMessage(\n              `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n              options.serviceWorker.url,\n            )\n          : devUtils.formatMessage(\n              `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n              options.serviceWorker.url,\n              location.host,\n            )\n\n        throw new Error(missingWorkerMessage)\n      }\n\n      context.workerPromise.resolve(worker)\n      context.registration = registration\n\n      window.addEventListener('beforeunload', () => {\n        if (worker.state !== 'redundant') {\n          // Notify the Service Worker that this client has closed.\n          // Internally, it's similar to disabling the mocking, only\n          // client close event has a handler that self-terminates\n          // the Service Worker when there are no open clients.\n          context.workerChannel.postMessage('CLIENT_CLOSED')\n        }\n\n        // Make sure we're always clearing the interval - there are reports that not doing this can\n        // cause memory leaks in headless browser environments.\n        window.clearInterval(context.keepAliveInterval)\n\n        // Notify others about this client disconnecting.\n        // E.g. this will purge the in-memory WebSocket clients since\n        // starting the worker again will assign them new IDs.\n        window.postMessage({ type: 'msw/worker:stop' })\n      })\n\n      // Check if the active Service Worker has been generated\n      // by the currently installed version of MSW.\n      await checkWorkerIntegrity(context).catch((error) => {\n        devUtils.error(\n          'Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues) and include the original error below.',\n        )\n        console.error(error)\n      })\n\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.postMessage('KEEPALIVE_REQUEST'),\n        5000,\n      )\n\n      // Warn the user when loading the page that lies outside\n      // of the worker's scope.\n      validateWorkerScope(registration, context.startOptions)\n\n      return registration\n    }\n\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting\n\n        if (pendingInstance) {\n          const activationPromise = new DeferredPromise<void>()\n\n          pendingInstance.addEventListener('statechange', () => {\n            if (pendingInstance.state === 'activated') {\n              activationPromise.resolve()\n            }\n          })\n\n          // Wait until the worker is activated.\n          // Assume the worker is already activated if there's no pending registration\n          // (i.e. when reloading the page after a successful activation).\n          await activationPromise\n        }\n\n        // Print the activation message only after the worker has been activated.\n        await enableMocking(context, options).catch((error) => {\n          devUtils.error(\n            'Failed to enable mocking. Please report this on GitHub (https://github.com/mswjs/msw/issues) and include the original error below.',\n          )\n          throw error\n        })\n\n        return registration\n      },\n    )\n\n    return workerRegistration\n  }\n}\n","export type AsyncTuple<\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n> =\n  | {\n      error: ErrorType\n      data: null\n    }\n  | { error: null; data: DataType }\n\n/**\n * Gracefully handles a given Promise factory.\n * @example\n * const { error, data } = await until(() => asyncAction())\n */\nexport const until = async <\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n>(\n  promise: () => Promise<DataType>,\n): Promise<AsyncTuple<ErrorType, DataType>> => {\n  try {\n    const data = await promise().catch((error) => {\n      throw error\n    })\n    return { error: null, data }\n  } catch (error) {\n    return { error, data: null }\n  }\n}\n","import { until } from '@open-draft/until'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { getAbsoluteWorkerUrl } from '../../../utils/getAbsoluteWorkerUrl'\nimport { getWorkerByRegistration } from './getWorkerByRegistration'\nimport { ServiceWorkerInstanceTuple, FindWorker } from '../../glossary'\n\n/**\n * Returns an active Service Worker instance.\n * When not found, registers a new Service Worker.\n */\nexport const getWorkerInstance = async (\n  url: string,\n  options: RegistrationOptions = {},\n  findWorker: FindWorker,\n): Promise<ServiceWorkerInstanceTuple> => {\n  // Resolve the absolute Service Worker URL.\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url)\n\n  const mockRegistrations = await navigator.serviceWorker\n    .getRegistrations()\n    .then((registrations) =>\n      registrations.filter((registration) =>\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n      ),\n    )\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    // Reload the page when it has associated workers, but no active controller.\n    // The absence of a controller can mean either:\n    // - page has no Service Worker associated with it\n    // - page has been hard-reloaded and its workers won't be used until the next reload.\n    // Since we've checked that there are registrations associated with this page,\n    // at this point we are sure it's hard reload that falls into this clause.\n    location.reload()\n  }\n\n  const [existingRegistration] = mockRegistrations\n\n  if (existingRegistration) {\n    // Schedule the worker update in the background.\n    // Update ensures the existing worker is up-to-date.\n    existingRegistration.update()\n\n    // Return the worker reference immediately.\n    return [\n      getWorkerByRegistration(\n        existingRegistration,\n        absoluteWorkerUrl,\n        findWorker,\n      ),\n      existingRegistration,\n    ]\n  }\n\n  // When the Service Worker wasn't found, register it anew and return the reference.\n  const registrationResult = await until<Error, ServiceWorkerInstanceTuple>(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options)\n      return [\n        // Compare existing worker registration by its worker URL,\n        // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration,\n      ]\n    },\n  )\n\n  // Handle Service Worker registration errors.\n  if (registrationResult.error) {\n    const isWorkerMissing = registrationResult.error.message.includes('(404)')\n\n    // Produce a custom error message when given a non-existing Service Worker url.\n    // Suggest developers to check their setup.\n    if (isWorkerMissing) {\n      const scopeUrl = new URL(options?.scope || '/', location.href)\n\n      throw new Error(\n        devUtils.formatMessage(`\\\nFailed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`),\n      )\n    }\n\n    // Fallback error message for any other registration errors.\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to register the Service Worker:\\n\\n%s',\n        registrationResult.error.message,\n      ),\n    )\n  }\n\n  return registrationResult.data\n}\n","/**\n * Returns an absolute Service Worker URL based on the given\n * relative URL (known during the registration).\n */\nexport function getAbsoluteWorkerUrl(workerUrl: string): string {\n  return new URL(workerUrl, location.href).href\n}\n","import { FindWorker } from '../../glossary'\n\n/**\n * Attempts to resolve a Service Worker instance from a given registration,\n * regardless of its state (active, installing, waiting).\n */\nexport function getWorkerByRegistration(\n  registration: ServiceWorkerRegistration,\n  absoluteWorkerUrl: string,\n  findWorker: FindWorker,\n): ServiceWorker | null {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting,\n  ]\n  const relevantStates = allStates.filter((state): state is ServiceWorker => {\n    return state != null\n  })\n  const worker = relevantStates.find((worker) => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl)\n  })\n\n  return worker || null\n}\n","export type PromiseState = 'pending' | 'fulfilled' | 'rejected'\n\nexport type Executor<Value> = ConstructorParameters<typeof Promise<Value>>[0]\nexport type ResolveFunction<Value> = Parameters<Executor<Value>>[0]\nexport type RejectFunction<Reason> = Parameters<Executor<Reason>>[1]\n\nexport type DeferredPromiseExecutor<Input = never, Output = Input> = {\n  (resolve?: ResolveFunction<Input>, reject?: RejectFunction<any>): void\n\n  resolve: ResolveFunction<Input>\n  reject: RejectFunction<any>\n  result?: Output\n  state: PromiseState\n  rejectionReason?: unknown\n}\nexport function createDeferredExecutor<\n  Input = never,\n  Output = Input\n>(): DeferredPromiseExecutor<Input, Output> {\n  const executor = <DeferredPromiseExecutor<Input, Output>>((\n    resolve,\n    reject\n  ) => {\n    executor.state = 'pending'\n\n    executor.resolve = (data) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      executor.result = data as Output\n\n      const onFulfilled = <Value>(value: Value) => {\n        executor.state = 'fulfilled'\n        return value\n      }\n\n      return resolve(\n        data instanceof Promise ? data : Promise.resolve(data).then(onFulfilled)\n      )\n    }\n\n    executor.reject = (reason) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      queueMicrotask(() => {\n        executor.state = 'rejected'\n      })\n\n      return reject((executor.rejectionReason = reason))\n    }\n  })\n\n  return executor\n}\n","import {\n  type Executor,\n  type RejectFunction,\n  type ResolveFunction,\n  type DeferredPromiseExecutor,\n  createDeferredExecutor,\n} from './createDeferredExecutor'\n\nexport class DeferredPromise<Input, Output = Input> extends Promise<Input> {\n  #executor: DeferredPromiseExecutor\n\n  public resolve: ResolveFunction<Output>\n  public reject: RejectFunction<Output>\n\n  constructor(executor: Executor<Input> | null = null) {\n    const deferredExecutor = createDeferredExecutor()\n    super((originalResolve, originalReject) => {\n      deferredExecutor(originalResolve, originalReject)\n      executor?.(deferredExecutor.resolve, deferredExecutor.reject)\n    })\n\n    this.#executor = deferredExecutor\n    this.resolve = this.#executor.resolve\n    this.reject = this.#executor.reject\n  }\n\n  public get state() {\n    return this.#executor.state\n  }\n\n  public get rejectionReason() {\n    return this.#executor.rejectionReason\n  }\n\n  public then<ThenResult = Input, CatchResult = never>(\n    onFulfilled?: (value: Input) => ThenResult | PromiseLike<ThenResult>,\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.then(onFulfilled, onRejected))\n  }\n\n  public catch<CatchResult = never>(\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.catch(onRejected))\n  }\n\n  public finally(onfinally?: () => void | Promise<any>) {\n    return this.#decorate(super.finally(onfinally))\n  }\n\n  #decorate<ChildInput>(\n    promise: Promise<ChildInput>\n  ): DeferredPromise<ChildInput, Output> {\n    return Object.defineProperties(promise, {\n      resolve: { configurable: true, value: this.resolve },\n      reject: { configurable: true, value: this.reject },\n    }) as DeferredPromise<ChildInput, Output>\n  }\n}\n","import type { ServiceWorkerIncomingEventsMap } from '../../glossary'\nimport { devUtils } from '~/core/utils/internal/devUtils'\n\ninterface PrintStartMessageArgs {\n  quiet?: boolean\n  message?: string\n  workerUrl?: string\n  workerScope?: string\n  client?: ServiceWorkerIncomingEventsMap['MOCKING_ENABLED']['client']\n}\n\n/**\n * Prints a worker activation message in the browser's console.\n */\nexport function printStartMessage(args: PrintStartMessageArgs = {}) {\n  if (args.quiet) {\n    return\n  }\n\n  const message = args.message || 'Mocking enabled.'\n\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    'color:orangered;font-weight:bold;',\n  )\n  // eslint-disable-next-line no-console\n  console.log(\n    '%cDocumentation: %chttps://mswjs.io/docs',\n    'font-weight:bold',\n    'font-weight:normal',\n  )\n  // eslint-disable-next-line no-console\n  console.log('Found an issue? https://github.com/mswjs/msw/issues')\n\n  if (args.workerUrl) {\n    // eslint-disable-next-line no-console\n    console.log('Worker script URL:', args.workerUrl)\n  }\n\n  if (args.workerScope) {\n    // eslint-disable-next-line no-console\n    console.log('Worker scope:', args.workerScope)\n  }\n\n  if (args.client) {\n    // eslint-disable-next-line no-console\n    console.log('Client ID: %s (%s)', args.client.id, args.client.frameType)\n  }\n\n  console.groupEnd()\n}\n","import { DeferredPromise } from '@open-draft/deferred-promise'\nimport type { StartOptions, SetupWorkerInternalContext } from '../../glossary'\nimport { printStartMessage } from './printStartMessage'\n\n/**\n * Signals the worker to enable the interception of requests.\n */\nexport function enableMocking(\n  context: SetupWorkerInternalContext,\n  options: StartOptions,\n): Promise<boolean> {\n  const mockingEnabledPromise = new DeferredPromise<boolean>()\n\n  context.workerChannel.postMessage('MOCK_ACTIVATE')\n  context.workerChannel.once('MOCKING_ENABLED', async (event) => {\n    context.isMockingEnabled = true\n    const worker = await context.workerPromise\n\n    printStartMessage({\n      quiet: options.quiet,\n      workerScope: context.registration?.scope,\n      workerUrl: worker.scriptURL,\n      client: event.data.client,\n    })\n\n    mockingEnabledPromise.resolve(true)\n  })\n\n  return mockingEnabledPromise\n}\n","import type { ServiceWorkerIncomingRequest } from '../setupWorker/glossary'\n\ntype Input = Pick<ServiceWorkerIncomingRequest, 'method' | 'body'>\n\n/**\n * Ensures that an empty GET request body is always represented as `undefined`.\n */\nexport function pruneGetRequestBody(\n  request: Input,\n): ServiceWorkerIncomingRequest['body'] {\n  // Force HEAD/GET request body to always be empty.\n  // The worker reads any request's body as ArrayBuffer,\n  // and you cannot re-construct a GET/HEAD Request\n  // with an ArrayBuffer, even if empty. Also note that\n  // \"request.body\" is always undefined in the worker.\n  if (['HEAD', 'GET'].includes(request.method)) {\n    return undefined\n  }\n\n  return request.body\n}\n","import { pruneGetRequestBody } from './pruneGetRequestBody'\nimport type { ServiceWorkerIncomingRequest } from '../setupWorker/glossary'\n\n/**\n * Converts a given request received from the Service Worker\n * into a Fetch `Request` instance.\n */\nexport function deserializeRequest(\n  serializedRequest: ServiceWorkerIncomingRequest,\n): Request {\n  return new Request(serializedRequest.url, {\n    ...serializedRequest,\n    body: pruneGetRequestBody(serializedRequest),\n  })\n}\n","import { Emitter } from 'rettime'\nimport { StartOptions, SetupWorkerInternalContext } from '../glossary'\nimport { deserializeRequest } from '../../utils/deserializeRequest'\nimport { RequestHandler } from '~/core/handlers/RequestHandler'\nimport { handleRequest } from '~/core/utils/handleRequest'\nimport { RequiredDeep } from '~/core/typeUtils'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { toResponseInit } from '~/core/utils/toResponseInit'\nimport { isHandlerKind } from '~/core/utils/internal/isHandlerKind'\n\nexport const createRequestListener = (\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Emitter.ListenerType<typeof context.workerChannel, 'REQUEST'> => {\n  return async (event) => {\n    // Treat any incoming requests from the worker as passthrough\n    // if `worker.stop()` has been called for this client.\n    if (\n      !context.isMockingEnabled &&\n      context.workerStoppedAt &&\n      event.data.interceptedAt > context.workerStoppedAt\n    ) {\n      event.postMessage('PASSTHROUGH')\n      return\n    }\n\n    const requestId = event.data.id\n    const request = deserializeRequest(event.data)\n    const requestCloneForLogs = request.clone()\n\n    // Make this the first request clone before the\n    // request resolution pipeline even starts.\n    // Store the clone in cache so the first matching\n    // request handler would skip the cloning phase.\n    const requestClone = request.clone()\n    RequestHandler.cache.set(request, requestClone)\n\n    try {\n      await handleRequest(\n        request,\n        requestId,\n        context.getRequestHandlers().filter(isHandlerKind('RequestHandler')),\n        options,\n        context.emitter,\n        {\n          onPassthroughResponse() {\n            event.postMessage('PASSTHROUGH')\n          },\n          async onMockedResponse(response, { handler, parsedResult }) {\n            // Clone the mocked response so its body could be read\n            // to buffer to be sent to the worker and also in the\n            // \".log()\" method of the request handler.\n            const responseClone = response.clone()\n            const responseCloneForLogs = response.clone()\n            const responseInit = toResponseInit(response)\n\n            /**\n             * @note Safari doesn't support transferring a \"ReadableStream\".\n             * Check that the browser supports that before sending it to the worker.\n             */\n            if (context.supports.readableStreamTransfer) {\n              const responseStreamOrNull = response.body\n\n              event.postMessage(\n                'MOCK_RESPONSE',\n                {\n                  ...responseInit,\n                  body: responseStreamOrNull,\n                },\n                responseStreamOrNull ? [responseStreamOrNull] : undefined,\n              )\n            } else {\n              /**\n               * @note If we are here, this means the current environment doesn't\n               * support \"ReadableStream\" as transferable. In that case,\n               * attempt to read the non-empty response body as ArrayBuffer, if it's not empty.\n               * @see https://github.com/mswjs/msw/issues/1827\n               */\n              const responseBufferOrNull =\n                response.body === null\n                  ? null\n                  : await responseClone.arrayBuffer()\n\n              event.postMessage('MOCK_RESPONSE', {\n                ...responseInit,\n                body: responseBufferOrNull,\n              })\n            }\n\n            if (!options.quiet) {\n              context.emitter.once('response:mocked', () => {\n                handler.log({\n                  request: requestCloneForLogs,\n                  response: responseCloneForLogs,\n                  parsedResult,\n                })\n              })\n            }\n          },\n        },\n      )\n    } catch (error) {\n      if (error instanceof Error) {\n        devUtils.error(\n          `Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/http/mocking-responses/error-responses`,\n          request.method,\n          request.url,\n          error.stack ?? error,\n        )\n\n        // Treat all other exceptions in a request handler as unintended,\n        // alerting that there is a problem that needs fixing.\n        event.postMessage('MOCK_RESPONSE', {\n          status: 500,\n          statusText: 'Request Handler Error',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n          }),\n        })\n      }\n    }\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport type { SetupWorkerInternalContext } from '../setupWorker/glossary'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\n\n/**\n * Check whether the registered Service Worker has been\n * generated by the installed version of the library.\n * Prints a warning message if the worker scripts mismatch.\n */\nexport function checkWorkerIntegrity(\n  context: SetupWorkerInternalContext,\n): Promise<void> {\n  const integrityCheckPromise = new DeferredPromise<void>()\n\n  // Request the integrity checksum from the registered worker.\n  context.workerChannel.postMessage('INTEGRITY_CHECK_REQUEST')\n  context.workerChannel.once('INTEGRITY_CHECK_RESPONSE', (event) => {\n    const { checksum, packageVersion } = event.data\n\n    // Compare the response from the Service Worker and the\n    // global variable set during the build.\n\n    // The integrity is validated based on the worker script's checksum\n    // that's derived from its minified content during the build.\n    // The \"SERVICE_WORKER_CHECKSUM\" global variable is injected by the build.\n    if (checksum !== SERVICE_WORKER_CHECKSUM) {\n      devUtils.warn(\n        `The currently registered Service Worker has been generated by a different version of MSW (${packageVersion}) and may not be fully compatible with the installed version.\n\nIt's recommended you update your worker script by running this command:\n\n  \\u2022 npx msw init <PUBLIC_DIR>\n\nYou can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`,\n      )\n    }\n\n    integrityCheckPromise.resolve()\n  })\n\n  return integrityCheckPromise\n}\n","const encoder = new TextEncoder()\n\nexport function encodeBuffer(text: string): Uint8Array {\n  return encoder.encode(text)\n}\n\nexport function decodeBuffer(buffer: ArrayBuffer, encoding?: string): string {\n  const decoder = new TextDecoder(encoding)\n  return decoder.decode(buffer)\n}\n\n/**\n * Create an `ArrayBuffer` from the given `Uint8Array`.\n * Takes the byte offset into account to produce the right buffer\n * in the case when the buffer is bigger than the data view.\n */\nexport function toArrayBuffer(array: Uint8Array): ArrayBuffer {\n  return array.buffer.slice(\n    array.byteOffset,\n    array.byteOffset + array.byteLength\n  )\n}\n","import type { RequestController } from './RequestController'\n\nexport const IS_PATCHED_MODULE: unique symbol = Symbol('isPatchedModule')\n\n/**\n * @note Export `RequestController` as a type only.\n * It's never meant to be created in the userland.\n */\nexport type { RequestController }\n\nexport type RequestCredentials = 'omit' | 'include' | 'same-origin'\n\nexport type HttpRequestEventMap = {\n  request: [\n    args: {\n      request: Request\n      requestId: string\n      controller: RequestController\n    }\n  ]\n  response: [\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ]\n  unhandledException: [\n    args: {\n      error: unknown\n      request: Request\n      requestId: string\n      controller: RequestController\n    }\n  ]\n}\n","/**\n * Returns a boolean indicating whether the given URL string\n * can be parsed into a `URL` instance.\n * A substitute for `URL.canParse()` for Node.js 18.\n */\nexport function canParseUrl(url: string): boolean {\n  try {\n    new URL(url)\n    return true\n  } catch (_error) {\n    return false\n  }\n}\n","/**\n * Returns the value behind the symbol with the given name.\n */\nexport function getValueBySymbol<T>(\n  symbolName: string,\n  source: object\n): T | undefined {\n  const ownSymbols = Object.getOwnPropertySymbols(source)\n\n  const symbol = ownSymbols.find((symbol) => {\n    return symbol.description === symbolName\n  })\n\n  if (symbol) {\n    return Reflect.get(source, symbol)\n  }\n\n  return\n}\n","import { canParseUrl } from './canParseUrl'\nimport { getValueBySymbol } from './getValueBySymbol'\n\nexport interface FetchResponseInit extends ResponseInit {\n  url?: string\n}\n\ninterface UndiciFetchInternalState {\n  aborted: boolean\n  rangeRequested: boolean\n  timingAllowPassed: boolean\n  requestIncludesCredentials: boolean\n  type: ResponseType\n  status: number\n  statusText: string\n  timingInfo: unknown\n  cacheState: unknown\n  headersList: Record<symbol, Map<string, unknown>>\n  urlList: Array<URL>\n  body?: {\n    stream: ReadableStream\n    source: unknown\n    length: number\n  }\n}\n\nexport class FetchResponse extends Response {\n  /**\n   * Response status codes for responses that cannot have body.\n   * @see https://fetch.spec.whatwg.org/#statuses\n   */\n  static readonly STATUS_CODES_WITHOUT_BODY = [101, 103, 204, 205, 304]\n\n  static readonly STATUS_CODES_WITH_REDIRECT = [301, 302, 303, 307, 308]\n\n  static isConfigurableStatusCode(status: number): boolean {\n    return status >= 200 && status <= 599\n  }\n\n  static isRedirectResponse(status: number): boolean {\n    return FetchResponse.STATUS_CODES_WITH_REDIRECT.includes(status)\n  }\n\n  /**\n   * Returns a boolean indicating whether the given response status\n   * code represents a response that can have a body.\n   */\n  static isResponseWithBody(status: number): boolean {\n    return !FetchResponse.STATUS_CODES_WITHOUT_BODY.includes(status)\n  }\n\n  static setUrl(url: string | undefined, response: Response): void {\n    if (!url || url === 'about:' || !canParseUrl(url)) {\n      return\n    }\n\n    const state = getValueBySymbol<UndiciFetchInternalState>('state', response)\n\n    if (state) {\n      // In Undici, push the URL to the internal list of URLs.\n      // This will respect the `response.url` getter logic correctly.\n      state.urlList.push(new URL(url))\n    } else {\n      // In other libraries, redefine the `url` property directly.\n      Object.defineProperty(response, 'url', {\n        value: url,\n        enumerable: true,\n        configurable: true,\n        writable: false,\n      })\n    }\n  }\n\n  /**\n   * Parses the given raw HTTP headers into a Fetch API `Headers` instance.\n   */\n  static parseRawHeaders(rawHeaders: Array<string>): Headers {\n    const headers = new Headers()\n    for (let line = 0; line < rawHeaders.length; line += 2) {\n      headers.append(rawHeaders[line], rawHeaders[line + 1])\n    }\n    return headers\n  }\n\n  constructor(body?: BodyInit | null, init: FetchResponseInit = {}) {\n    const status = init.status ?? 200\n    const safeStatus = FetchResponse.isConfigurableStatusCode(status)\n      ? status\n      : 200\n    const finalBody = FetchResponse.isResponseWithBody(status) ? body : null\n\n    super(finalBody, {\n      status: safeStatus,\n      statusText: init.statusText,\n      headers: init.headers,\n    })\n\n    if (status !== safeStatus) {\n      /**\n       * @note Undici keeps an internal \"Symbol(state)\" that holds\n       * the actual value of response status. Update that in Node.js.\n       */\n      const state = getValueBySymbol<UndiciFetchInternalState>('state', this)\n\n      if (state) {\n        state.status = status\n      } else {\n        Object.defineProperty(this, 'status', {\n          value: status,\n          enumerable: true,\n          configurable: true,\n          writable: false,\n        })\n      }\n    }\n\n    FetchResponse.setUrl(init.url, this)\n  }\n}\n","const kRawRequest = Symbol('kRawRequest')\n\n/**\n * Returns a raw request instance associated with this request.\n *\n * @example\n * interceptor.on('request', ({ request }) => {\n *   const rawRequest = getRawRequest(request)\n *\n *   if (rawRequest instanceof http.ClientRequest) {\n *     console.log(rawRequest.rawHeaders)\n *   }\n * })\n */\nexport function getRawRequest(request: Request): unknown | undefined {\n  return Reflect.get(request, kRawRequest)\n}\n\nexport function setRawRequest(request: Request, rawRequest: unknown): void {\n  Reflect.set(request, kRawRequest, rawRequest)\n}\n","var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/index.ts\nimport { isNodeProcess } from \"is-node-process\";\nimport { format } from \"outvariant\";\n\n// src/colors.ts\nvar colors_exports = {};\n__export(colors_exports, {\n  blue: () => blue,\n  gray: () => gray,\n  green: () => green,\n  red: () => red,\n  yellow: () => yellow\n});\nfunction yellow(text) {\n  return `\\x1B[33m${text}\\x1B[0m`;\n}\nfunction blue(text) {\n  return `\\x1B[34m${text}\\x1B[0m`;\n}\nfunction gray(text) {\n  return `\\x1B[90m${text}\\x1B[0m`;\n}\nfunction red(text) {\n  return `\\x1B[31m${text}\\x1B[0m`;\n}\nfunction green(text) {\n  return `\\x1B[32m${text}\\x1B[0m`;\n}\n\n// src/index.ts\nvar IS_NODE = isNodeProcess();\nvar Logger = class {\n  constructor(name) {\n    this.name = name;\n    this.prefix = `[${this.name}]`;\n    const LOGGER_NAME = getVariable(\"DEBUG\");\n    const LOGGER_LEVEL = getVariable(\"LOG_LEVEL\");\n    const isLoggingEnabled = LOGGER_NAME === \"1\" || LOGGER_NAME === \"true\" || typeof LOGGER_NAME !== \"undefined\" && this.name.startsWith(LOGGER_NAME);\n    if (isLoggingEnabled) {\n      this.debug = isDefinedAndNotEquals(LOGGER_LEVEL, \"debug\") ? noop : this.debug;\n      this.info = isDefinedAndNotEquals(LOGGER_LEVEL, \"info\") ? noop : this.info;\n      this.success = isDefinedAndNotEquals(LOGGER_LEVEL, \"success\") ? noop : this.success;\n      this.warning = isDefinedAndNotEquals(LOGGER_LEVEL, \"warning\") ? noop : this.warning;\n      this.error = isDefinedAndNotEquals(LOGGER_LEVEL, \"error\") ? noop : this.error;\n    } else {\n      this.info = noop;\n      this.success = noop;\n      this.warning = noop;\n      this.error = noop;\n      this.only = noop;\n    }\n  }\n  prefix;\n  extend(domain) {\n    return new Logger(`${this.name}:${domain}`);\n  }\n  /**\n   * Print a debug message.\n   * @example\n   * logger.debug('no duplicates found, creating a document...')\n   */\n  debug(message, ...positionals) {\n    this.logEntry({\n      level: \"debug\",\n      message: gray(message),\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"gray\"\n      }\n    });\n  }\n  /**\n   * Print an info message.\n   * @example\n   * logger.info('start parsing...')\n   */\n  info(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"blue\"\n      }\n    });\n    const performance2 = new PerformanceEntry();\n    return (message2, ...positionals2) => {\n      performance2.measure();\n      this.logEntry({\n        level: \"info\",\n        message: `${message2} ${gray(`${performance2.deltaTime}ms`)}`,\n        positionals: positionals2,\n        prefix: this.prefix,\n        colors: {\n          prefix: \"blue\"\n        }\n      });\n    };\n  }\n  /**\n   * Print a success message.\n   * @example\n   * logger.success('successfully created document')\n   */\n  success(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: `\\u2714 ${this.prefix}`,\n      colors: {\n        timestamp: \"green\",\n        prefix: \"green\"\n      }\n    });\n  }\n  /**\n   * Print a warning.\n   * @example\n   * logger.warning('found legacy document format')\n   */\n  warning(message, ...positionals) {\n    this.logEntry({\n      level: \"warning\",\n      message,\n      positionals,\n      prefix: `\\u26A0 ${this.prefix}`,\n      colors: {\n        timestamp: \"yellow\",\n        prefix: \"yellow\"\n      }\n    });\n  }\n  /**\n   * Print an error message.\n   * @example\n   * logger.error('something went wrong')\n   */\n  error(message, ...positionals) {\n    this.logEntry({\n      level: \"error\",\n      message,\n      positionals,\n      prefix: `\\u2716 ${this.prefix}`,\n      colors: {\n        timestamp: \"red\",\n        prefix: \"red\"\n      }\n    });\n  }\n  /**\n   * Execute the given callback only when the logging is enabled.\n   * This is skipped in its entirety and has no runtime cost otherwise.\n   * This executes regardless of the log level.\n   * @example\n   * logger.only(() => {\n   *   logger.info('additional info')\n   * })\n   */\n  only(callback) {\n    callback();\n  }\n  createEntry(level, message) {\n    return {\n      timestamp: /* @__PURE__ */ new Date(),\n      level,\n      message\n    };\n  }\n  logEntry(args) {\n    const {\n      level,\n      message,\n      prefix,\n      colors: customColors,\n      positionals = []\n    } = args;\n    const entry = this.createEntry(level, message);\n    const timestampColor = customColors?.timestamp || \"gray\";\n    const prefixColor = customColors?.prefix || \"gray\";\n    const colorize = {\n      timestamp: colors_exports[timestampColor],\n      prefix: colors_exports[prefixColor]\n    };\n    const write = this.getWriter(level);\n    write(\n      [colorize.timestamp(this.formatTimestamp(entry.timestamp))].concat(prefix != null ? colorize.prefix(prefix) : []).concat(serializeInput(message)).join(\" \"),\n      ...positionals.map(serializeInput)\n    );\n  }\n  formatTimestamp(timestamp) {\n    return `${timestamp.toLocaleTimeString(\n      \"en-GB\"\n    )}:${timestamp.getMilliseconds()}`;\n  }\n  getWriter(level) {\n    switch (level) {\n      case \"debug\":\n      case \"success\":\n      case \"info\": {\n        return log;\n      }\n      case \"warning\": {\n        return warn;\n      }\n      case \"error\": {\n        return error;\n      }\n    }\n  }\n};\nvar PerformanceEntry = class {\n  startTime;\n  endTime;\n  deltaTime;\n  constructor() {\n    this.startTime = performance.now();\n  }\n  measure() {\n    this.endTime = performance.now();\n    const deltaTime = this.endTime - this.startTime;\n    this.deltaTime = deltaTime.toFixed(2);\n  }\n};\nvar noop = () => void 0;\nfunction log(message, ...positionals) {\n  if (IS_NODE) {\n    process.stdout.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.log(message, ...positionals);\n}\nfunction warn(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.warn(message, ...positionals);\n}\nfunction error(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.error(message, ...positionals);\n}\nfunction getVariable(variableName) {\n  if (IS_NODE) {\n    return process.env[variableName];\n  }\n  return globalThis[variableName]?.toString();\n}\nfunction isDefinedAndNotEquals(value, expected) {\n  return value !== void 0 && value !== expected;\n}\nfunction serializeInput(message) {\n  if (typeof message === \"undefined\") {\n    return \"undefined\";\n  }\n  if (message === null) {\n    return \"null\";\n  }\n  if (typeof message === \"string\") {\n    return message;\n  }\n  if (typeof message === \"object\") {\n    return JSON.stringify(message);\n  }\n  return message.toString();\n}\nexport {\n  Logger\n};\n","import type { Emitter } from './Emitter'\n\nexport class MemoryLeakError extends Error {\n  constructor(\n    public readonly emitter: Emitter<any>,\n    public readonly type: string | number | symbol,\n    public readonly count: number\n  ) {\n    super(\n      `Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`\n    )\n    this.name = 'MaxListenersExceededWarning'\n  }\n}\n","import { MemoryLeakError } from './MemoryLeakError'\n\nexport type EventMap = {\n  [eventName: string]: Array<unknown>\n}\n\nexport type InternalEventNames = 'newListener' | 'removeListener'\n\nexport type InternalListener<Events extends EventMap> = Listener<\n  [eventName: keyof Events, listener: Listener<Array<unknown>>]\n>\n\nexport type Listener<Data extends Array<unknown>> = (...data: Data) => void\n\n/**\n * Node.js-compatible implementation of `EventEmitter`.\n *\n * @example\n * const emitter = new Emitter<{ hello: [string] }>()\n * emitter.on('hello', (name) => console.log(name))\n * emitter.emit('hello', 'John')\n */\nexport class Emitter<Events extends EventMap> {\n  private events: Map<keyof Events, Array<Listener<any>>>\n  private maxListeners: number\n  private hasWarnedAboutPotentialMemoryLeak: boolean\n\n  static defaultMaxListeners = 10\n\n  static listenerCount<Events extends EventMap>(\n    emitter: Emitter<EventMap>,\n    eventName: keyof Events\n  ): number {\n    return emitter.listenerCount<any>(eventName)\n  }\n\n  constructor() {\n    this.events = new Map()\n    this.maxListeners = Emitter.defaultMaxListeners\n    this.hasWarnedAboutPotentialMemoryLeak = false\n  }\n\n  private _emitInternalEvent(\n    internalEventName: InternalEventNames,\n    eventName: keyof Events,\n    listener: Listener<Array<unknown>>\n  ): void {\n    this.emit(\n      internalEventName,\n      // Anything to make TypeScript happy.\n      ...([eventName, listener] as Events['newListener'] &\n        Events['removeListener'])\n    )\n  }\n\n  private _getListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Array<unknown>>> {\n    // Always return a copy of the listeners array\n    // so they are fixed at the time of the \"_getListeners\" call.\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || []\n  }\n\n  private _removeListener<EventName extends keyof Events>(\n    listeners: Array<Listener<Events[EventName]>>,\n    listener: Listener<Events[EventName]>\n  ): Array<Listener<Events[EventName]>> {\n    const index = listeners.indexOf(listener)\n\n    if (index > -1) {\n      listeners.splice(index, 1)\n    }\n\n    return []\n  }\n\n  private _wrapOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): Listener<Events[EventName]> {\n    const onceListener = (...data: Events[keyof Events]) => {\n      this.removeListener(eventName, onceListener)\n\n      /**\n       * @note Return the result of the original listener.\n       * This way this wrapped preserves listeners that are async.\n       */\n      return listener.apply(this, data)\n    }\n\n    // Inherit the name of the original listener.\n    Object.defineProperty(onceListener, 'name', { value: listener.name })\n\n    return onceListener\n  }\n\n  public setMaxListeners(maxListeners: number): this {\n    this.maxListeners = maxListeners\n    return this\n  }\n\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  public getMaxListeners(): number {\n    return this.maxListeners\n  }\n\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  public eventNames(): Array<keyof Events> {\n    return Array.from(this.events.keys())\n  }\n\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  public emit<EventName extends keyof Events>(\n    eventName: EventName,\n    ...data: Events[EventName]\n  ): boolean {\n    const listeners = this._getListeners(eventName)\n    listeners.forEach((listener) => {\n      listener.apply(this, data)\n    })\n\n    return listeners.length > 0\n  }\n\n  public addListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public addListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public addListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: InternalListener<Events> | Listener<Events[any]>\n  ): this {\n    // Emit the `newListener` event before adding the listener.\n    this._emitInternalEvent('newListener', eventName, listener)\n\n    const nextListeners = this._getListeners(eventName).concat(listener)\n    this.events.set(eventName, nextListeners)\n\n    if (\n      this.maxListeners > 0 &&\n      this.listenerCount(eventName) > this.maxListeners &&\n      !this.hasWarnedAboutPotentialMemoryLeak\n    ) {\n      this.hasWarnedAboutPotentialMemoryLeak = true\n\n      const memoryLeakWarning = new MemoryLeakError(\n        this,\n        eventName,\n        this.listenerCount(eventName)\n      )\n      console.warn(memoryLeakWarning)\n    }\n\n    return this\n  }\n\n  public on(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: 'removeListener' | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(eventName, listener)\n  }\n\n  public once(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: InternalEventNames | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public prependListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners)\n      this.events.set(eventName, nextListeners)\n    } else {\n      this.events.set(eventName, listeners.concat(listener))\n    }\n\n    return this\n  }\n\n  public prependOnceListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependOnceListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.prependListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public removeListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public removeListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public removeListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener)\n      this.events.set(eventName, listeners)\n\n      // Emit the `removeListener` event after removing the listener.\n      this._emitInternalEvent('removeListener', eventName, listener)\n    }\n\n    return this\n  }\n\n  public off(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public off<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  public off(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.removeListener(eventName, listener)\n  }\n\n  public removeAllListeners(eventName?: InternalEventNames): this\n  public removeAllListeners<EventName extends keyof Events>(\n    eventName?: EventName\n  ): this\n  public removeAllListeners(\n    eventName?: InternalEventNames | keyof Events\n  ): this {\n    if (eventName) {\n      this.events.delete(eventName)\n    } else {\n      this.events.clear()\n    }\n\n    return this\n  }\n\n  public listeners(eventName: InternalEventNames): Array<Listener<any>>\n  public listeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>>\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  public listeners(eventName: InternalEventNames | keyof Events) {\n    return Array.from(this._getListeners(eventName))\n  }\n\n  public listenerCount(eventName: InternalEventNames): number\n  public listenerCount<EventName extends keyof Events>(\n    eventName: EventName\n  ): number\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  public listenerCount(eventName: InternalEventNames | keyof Events): number {\n    return this._getListeners(eventName).length\n  }\n\n  public rawListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>> {\n    return this.listeners(eventName)\n  }\n}\n","import { Logger } from '@open-draft/logger'\nimport { Emitter, Listener } from 'strict-event-emitter'\n\nexport type InterceptorEventMap = Record<string, any>\nexport type InterceptorSubscription = () => void\n\n/**\n * Request header name to detect when a single request\n * is being handled by nested interceptors (XHR -> ClientRequest).\n * Obscure by design to prevent collisions with user-defined headers.\n * Ideally, come up with the Interceptor-level mechanism for this.\n * @see https://github.com/mswjs/interceptors/issues/378\n */\nexport const INTERNAL_REQUEST_ID_HEADER_NAME =\n  'x-interceptors-internal-request-id'\n\nexport function getGlobalSymbol<V>(symbol: Symbol): V | undefined {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  )\n}\n\nfunction setGlobalSymbol(symbol: Symbol, value: any): void {\n  // @ts-ignore\n  globalThis[symbol] = value\n}\n\nexport function deleteGlobalSymbol(symbol: Symbol): void {\n  // @ts-ignore\n  delete globalThis[symbol]\n}\n\nexport enum InterceptorReadyState {\n  INACTIVE = 'INACTIVE',\n  APPLYING = 'APPLYING',\n  APPLIED = 'APPLIED',\n  DISPOSING = 'DISPOSING',\n  DISPOSED = 'DISPOSED',\n}\n\nexport type ExtractEventNames<Events extends Record<string, any>> =\n  Events extends Record<infer EventName, any> ? EventName : never\n\nexport class Interceptor<Events extends InterceptorEventMap> {\n  protected emitter: Emitter<Events>\n  protected subscriptions: Array<InterceptorSubscription>\n  protected logger: Logger\n\n  public readyState: InterceptorReadyState\n\n  constructor(private readonly symbol: symbol) {\n    this.readyState = InterceptorReadyState.INACTIVE\n\n    this.emitter = new Emitter()\n    this.subscriptions = []\n    this.logger = new Logger(symbol.description!)\n\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0)\n\n    this.logger.info('constructing the interceptor...')\n  }\n\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  protected checkEnvironment(): boolean {\n    return true\n  }\n\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  public apply(): void {\n    const logger = this.logger.extend('apply')\n    logger.info('applying the interceptor...')\n\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      logger.info('intercepted already applied!')\n      return\n    }\n\n    const shouldApply = this.checkEnvironment()\n\n    if (!shouldApply) {\n      logger.info('the interceptor cannot be applied in this environment!')\n      return\n    }\n\n    this.readyState = InterceptorReadyState.APPLYING\n\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    const runningInstance = this.getInstance()\n\n    if (runningInstance) {\n      logger.info('found a running instance, reusing...')\n\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event)\n\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener)\n\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener)\n          logger.info('removed proxied \"%s\" listener!', event)\n        })\n\n        return this\n      }\n\n      this.readyState = InterceptorReadyState.APPLIED\n\n      return\n    }\n\n    logger.info('no running instance found, setting up a new instance...')\n\n    // Setup the interceptor.\n    this.setup()\n\n    // Store the newly applied interceptor instance globally.\n    this.setInstance()\n\n    this.readyState = InterceptorReadyState.APPLIED\n  }\n\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  protected setup(): void {}\n\n  /**\n   * Listen to the interceptor's public events.\n   */\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    const logger = this.logger.extend('on')\n\n    if (\n      this.readyState === InterceptorReadyState.DISPOSING ||\n      this.readyState === InterceptorReadyState.DISPOSED\n    ) {\n      logger.info('cannot listen to events, already disposed!')\n      return this\n    }\n\n    logger.info('adding \"%s\" event listener:', event, listener)\n\n    this.emitter.on(event, listener)\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.once(event, listener)\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.off(event, listener)\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName\n  ): this {\n    this.emitter.removeAllListeners(event)\n    return this\n  }\n\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  public dispose(): void {\n    const logger = this.logger.extend('dispose')\n\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      logger.info('cannot dispose, already disposed!')\n      return\n    }\n\n    logger.info('disposing the interceptor...')\n    this.readyState = InterceptorReadyState.DISPOSING\n\n    if (!this.getInstance()) {\n      logger.info('no interceptors running, skipping dispose...')\n      return\n    }\n\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance()\n\n    logger.info('global symbol deleted:', getGlobalSymbol(this.symbol))\n\n    if (this.subscriptions.length > 0) {\n      logger.info('disposing of %d subscriptions...', this.subscriptions.length)\n\n      for (const dispose of this.subscriptions) {\n        dispose()\n      }\n\n      this.subscriptions = []\n\n      logger.info('disposed of all subscriptions!', this.subscriptions.length)\n    }\n\n    this.emitter.removeAllListeners()\n    logger.info('destroyed the listener!')\n\n    this.readyState = InterceptorReadyState.DISPOSED\n  }\n\n  private getInstance(): this | undefined {\n    const instance = getGlobalSymbol<this>(this.symbol)\n    this.logger.info('retrieved global instance:', instance?.constructor?.name)\n    return instance\n  }\n\n  private setInstance(): void {\n    setGlobalSymbol(this.symbol, this)\n    this.logger.info('set global instance!', this.symbol.description)\n  }\n\n  private clearInstance(): void {\n    deleteGlobalSymbol(this.symbol)\n    this.logger.info('cleared global instance!', this.symbol.description)\n  }\n}\n","/**\n * Generate a random ID string to represent a request.\n * @example\n * createRequestId()\n * // \"f774b6c9c600f\"\n */\nexport function createRequestId(): string {\n  return Math.random().toString(16).slice(2)\n}\n","import { EventMap, Listener } from 'strict-event-emitter'\nimport { Interceptor, ExtractEventNames } from './Interceptor'\n\nexport interface BatchInterceptorOptions<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> {\n  name: string\n  interceptors: InterceptorList\n}\n\nexport type ExtractEventMapType<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> = InterceptorList extends ReadonlyArray<infer InterceptorType>\n  ? InterceptorType extends Interceptor<infer EventMap>\n    ? EventMap\n    : never\n  : never\n\n/**\n * A batch interceptor that exposes a single interface\n * to apply and operate with multiple interceptors at once.\n */\nexport class BatchInterceptor<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>,\n  Events extends EventMap = ExtractEventMapType<InterceptorList>\n> extends Interceptor<Events> {\n  static symbol: symbol\n\n  private interceptors: InterceptorList\n\n  constructor(options: BatchInterceptorOptions<InterceptorList>) {\n    BatchInterceptor.symbol = Symbol(options.name)\n    super(BatchInterceptor.symbol)\n    this.interceptors = options.interceptors\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('applying all %d interceptors...', this.interceptors.length)\n\n    for (const interceptor of this.interceptors) {\n      logger.info('applying \"%s\" interceptor...', interceptor.constructor.name)\n      interceptor.apply()\n\n      logger.info('adding interceptor dispose subscription')\n      this.subscriptions.push(() => interceptor.dispose())\n    }\n  }\n\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    // Instead of adding a listener to the batch interceptor,\n    // propagate the listener to each of the individual interceptors.\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener)\n    }\n\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener)\n    }\n\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener)\n    }\n\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName | undefined\n  ): this {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event)\n    }\n\n    return this\n  }\n}\n","/**\n * Removes query parameters and hashes from a given URL.\n */\nexport function getCleanUrl(url: URL, isAbsolute: boolean = true): string {\n  return [isAbsolute && url.origin, url.pathname].filter(Boolean).join('')\n}\n","import { FetchResponse } from '@mswjs/interceptors'\nimport type { Emitter } from 'rettime'\nimport type { SetupWorkerInternalContext } from '../glossary'\nimport { deserializeRequest } from '../../utils/deserializeRequest'\n\nexport function createResponseListener(\n  context: SetupWorkerInternalContext,\n): Emitter.ListenerType<typeof context.workerChannel, 'RESPONSE'> {\n  return (event) => {\n    const responseMessage = event.data\n    const request = deserializeRequest(responseMessage.request)\n\n    /**\n     * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\n     * That kind of responses cannot be manipulated in JavaScript due\n     * to the security considerations.\n     * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\n     * @see https://github.com/mswjs/msw/issues/529\n     */\n    if (responseMessage.response.type?.includes('opaque')) {\n      return\n    }\n\n    const response =\n      responseMessage.response.status === 0\n        ? Response.error()\n        : new FetchResponse(\n            /**\n             * Responses may be streams here, but when we create a response object\n             * with null-body status codes, like 204, 205, 304 Response will\n             * throw when passed a non-null body, so ensure it's null here\n             * for those codes\n             */\n            FetchResponse.isResponseWithBody(responseMessage.response.status)\n              ? responseMessage.response.body\n              : null,\n            {\n              ...responseMessage,\n              /**\n               * Set response URL if it's not set already.\n               * @see https://github.com/mswjs/msw/issues/2030\n               * @see https://developer.mozilla.org/en-US/docs/Web/API/Response/url\n               */\n              url: request.url,\n            },\n          )\n\n    context.emitter.emit(\n      responseMessage.isMockedResponse ? 'response:mocked' : 'response:bypass',\n      {\n        requestId: responseMessage.request.id,\n        request,\n        response,\n      },\n    )\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport { StartOptions } from '../../glossary'\n\nexport function validateWorkerScope(\n  registration: ServiceWorkerRegistration,\n  options?: StartOptions,\n): void {\n  if (!options?.quiet && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `\\\nCannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.\\\n`,\n    )\n  }\n}\n","import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport type {\n  SetupWorkerInternalContext,\n  StartReturnType,\n  StartOptions,\n  SetupWorker,\n} from './glossary'\nimport { RequestHandler } from '~/core/handlers/RequestHandler'\nimport { DEFAULT_START_OPTIONS } from './start/utils/prepareStartHandler'\nimport { createStartHandler } from './start/createStartHandler'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { SetupApi } from '~/core/SetupApi'\nimport { mergeRight } from '~/core/utils/internal/mergeRight'\nimport type { LifeCycleEventsMap } from '~/core/sharedOptions'\nimport type { WebSocketHandler } from '~/core/handlers/WebSocketHandler'\nimport { supportsReadableStreamTransfer } from '../utils/supportsReadableStreamTransfer'\nimport { webSocketInterceptor } from '~/core/ws/webSocketInterceptor'\nimport { handleWebSocketEvent } from '~/core/ws/handleWebSocketEvent'\nimport { attachWebSocketLogger } from '~/core/ws/utils/attachWebSocketLogger'\nimport { WorkerChannel } from '../utils/workerChannel'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { createFallbackRequestListener } from './start/createFallbackRequestListener'\nimport { printStartMessage } from './start/utils/printStartMessage'\nimport { printStopMessage } from './stop/utils/printStopMessage'\n\nexport class SetupWorkerApi\n  extends SetupApi<LifeCycleEventsMap>\n  implements SetupWorker\n{\n  private context: SetupWorkerInternalContext\n\n  constructor(...handlers: Array<RequestHandler | WebSocketHandler>) {\n    super(...handlers)\n\n    invariant(\n      !isNodeProcess(),\n      devUtils.formatMessage(\n        'Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.',\n      ),\n    )\n\n    this.context = this.createWorkerContext()\n  }\n\n  private createWorkerContext(): SetupWorkerInternalContext {\n    const workerPromise = new DeferredPromise<ServiceWorker>()\n\n    return {\n      // Mocking is not considered enabled until the worker\n      // signals back the successful activation event.\n      isMockingEnabled: false,\n      startOptions: null as any,\n      workerPromise,\n      registration: undefined,\n      getRequestHandlers: () => {\n        return this.handlersController.currentHandlers()\n      },\n      emitter: this.emitter,\n      workerChannel: new WorkerChannel({\n        worker: workerPromise,\n      }),\n      supports: {\n        serviceWorkerApi:\n          'serviceWorker' in navigator && location.protocol !== 'file:',\n        readableStreamTransfer: supportsReadableStreamTransfer(),\n      },\n    }\n  }\n\n  public async start(options: StartOptions = {}): StartReturnType {\n    if ('waitUntilReady' in options) {\n      devUtils.warn(\n        'The \"waitUntilReady\" option has been deprecated. Please remove it from this \"worker.start()\" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.',\n      )\n    }\n\n    // Warn the developer on multiple \"worker.start()\" calls.\n    // While this will not affect the worker in any way,\n    // it likely indicates an issue with the developer's code.\n    if (this.context.isMockingEnabled) {\n      devUtils.warn(\n        `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`,\n      )\n      return this.context.registration\n    }\n\n    this.context.workerStoppedAt = undefined\n\n    this.context.startOptions = mergeRight(\n      DEFAULT_START_OPTIONS,\n      options,\n    ) as SetupWorkerInternalContext['startOptions']\n\n    // Enable the WebSocket interception.\n    handleWebSocketEvent({\n      getUnhandledRequestStrategy: () => {\n        return this.context.startOptions.onUnhandledRequest\n      },\n      getHandlers: () => {\n        return this.handlersController.currentHandlers()\n      },\n      onMockedConnection: (connection) => {\n        if (!this.context.startOptions.quiet) {\n          // Attach the logger for mocked connections since\n          // those won't be visible in the browser's devtools.\n          attachWebSocketLogger(connection)\n        }\n      },\n      onPassthroughConnection() {},\n    })\n    webSocketInterceptor.apply()\n\n    this.subscriptions.push(() => {\n      webSocketInterceptor.dispose()\n    })\n\n    // Use a fallback interception algorithm in the environments\n    // where the Service Worker API isn't supported.\n    if (!this.context.supports.serviceWorkerApi) {\n      const fallbackInterceptor = createFallbackRequestListener(\n        this.context,\n        this.context.startOptions,\n      )\n\n      this.subscriptions.push(() => {\n        fallbackInterceptor.dispose()\n      })\n\n      this.context.isMockingEnabled = true\n\n      printStartMessage({\n        message: 'Mocking enabled (fallback mode).',\n        quiet: this.context.startOptions.quiet,\n      })\n\n      return undefined\n    }\n\n    const startHandler = createStartHandler(this.context)\n    const registration = await startHandler(this.context.startOptions, options)\n\n    this.context.isMockingEnabled = true\n\n    return registration\n  }\n\n  public stop(): void {\n    super.dispose()\n\n    if (!this.context.isMockingEnabled) {\n      devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Notice that stopping the worker after it has already been stopped has no effect. Consider removing this \"worker.stop()\" call.',\n      )\n      return\n    }\n\n    this.context.isMockingEnabled = false\n    this.context.workerStoppedAt = Date.now()\n    this.context.emitter.removeAllListeners()\n\n    if (this.context.supports.serviceWorkerApi) {\n      this.context.workerChannel.removeAllListeners('RESPONSE')\n      window.clearInterval(this.context.keepAliveInterval)\n    }\n\n    // Post the internal stop message on the window\n    // to let any logic know when the worker has stopped.\n    // E.g. the WebSocket client manager needs this to know\n    // when to clear its in-memory clients list.\n    window.postMessage({ type: 'msw/worker:stop' })\n\n    printStopMessage({\n      quiet: this.context.startOptions?.quiet,\n    })\n  }\n}\n\n/**\n * Sets up a requests interception in the browser with the given request handlers.\n * @param {RequestHandler[]} handlers List of request handlers.\n *\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker()` API reference}\n */\nexport function setupWorker(\n  ...handlers: Array<RequestHandler | WebSocketHandler>\n): SetupWorker {\n  return new SetupWorkerApi(...handlers)\n}\n","/**\n * Returns a boolean indicating whether the current browser\n * supports `ReadableStream` as a `Transferable` when posting\n * messages.\n */\nexport function supportsReadableStreamTransfer() {\n  try {\n    const stream = new ReadableStream({\n      start: (controller) => controller.close(),\n    })\n    const message = new MessageChannel()\n    message.port1.postMessage(stream, [stream])\n    return true\n  } catch {\n    return false\n  }\n}\n","export type DefaultEventMap = {\n  [eventType: string]: TypedEvent<any, any>\n}\n\nexport interface TypedEvent<\n  DataType = void,\n  ReturnType = any,\n  EventType extends string = string,\n> extends Omit<MessageEvent<DataType>, 'type'> {\n  type: EventType\n}\n\nconst kDefaultPrevented = Symbol('kDefaultPrevented')\nconst kPropagationStopped = Symbol('kPropagationStopped')\nconst kImmediatePropagationStopped = Symbol('kImmediatePropagationStopped')\n\nexport class TypedEvent<\n    DataType = void,\n    ReturnType = any,\n    EventType extends string = string,\n  >\n  extends MessageEvent<DataType>\n  implements TypedEvent<DataType, ReturnType, EventType>\n{\n  /**\n   * @note Keep a placeholder property with the return type\n   * because the type must be set somewhere in order to be\n   * correctly associated and inferred from the event.\n   */\n  #returnType: ReturnType;\n\n  [kDefaultPrevented]: boolean;\n  [kPropagationStopped]?: Emitter<any>;\n  [kImmediatePropagationStopped]?: boolean\n\n  constructor(\n    ...args: [DataType] extends [void]\n      ? [type: EventType]\n      : [type: EventType, init: { data: DataType }]\n  ) {\n    super(args[0], args[1])\n    this[kDefaultPrevented] = false\n  }\n\n  get defaultPrevented(): boolean {\n    return this[kDefaultPrevented]\n  }\n\n  public preventDefault(): void {\n    super.preventDefault()\n    this[kDefaultPrevented] = true\n  }\n\n  public stopImmediatePropagation(): void {\n    /**\n     * @note Despite `.stopPropagation()` and `.stopImmediatePropagation()` being defined\n     * in Node.js, they do nothing. It is safe to re-define them.\n     */\n    super.stopImmediatePropagation()\n    this[kImmediatePropagationStopped] = true\n  }\n}\n\n/**\n * Brands a TypedEvent or its subclass while preserving its (narrower) type.\n */\ntype Brand<Event extends TypedEvent, EventType extends string> = Event & {\n  type: EventType\n}\n\ntype InferEventMap<Target extends Emitter<any>> = Target extends Emitter<\n  infer EventMap\n>\n  ? EventMap\n  : never\n\ntype InternalListenersMap<\n  Target extends Emitter<any>,\n  EventMap extends DefaultEventMap = InferEventMap<Target>,\n  EventType extends string = keyof EventMap & string,\n> = Record<\n  keyof EventMap,\n  Array<Emitter.ListenerType<Target, EventType, EventMap>>\n>\n\nexport type TypedListenerOptions = {\n  once?: boolean\n  signal?: AbortSignal\n}\n\nconst kListenerOptions = Symbol('kListenerOptions')\n\nexport namespace Emitter {\n  /**\n   * Returns an appropriate `Event` type for the given event type.\n   *\n   * @example\n   * const emitter = new Emitter<{ greeting: TypedEvent<string> }>()\n   * type GreetingEvent = Emitter.InferEventType<typeof emitter, 'greeting'>\n   * // TypedEvent<string>\n   */\n  export type EventType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = Brand<EventMap[EventType], EventType>\n\n  export type EventDataType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = EventMap[EventType] extends TypedEvent<infer DataType> ? DataType : never\n\n  /**\n   * Returns the listener type for the given event type.\n   *\n   * @example\n   * const emitter = new Emitter<{ getTotalPrice: TypedEvent<Cart, number> }>()\n   * type Listener = Emitter.ListenerType<typeof emitter, 'getTotalPrice'>\n   * // (event: TypedEvent<Cart>) => number\n   */\n  export type ListenerType<\n    Target extends Emitter<any>,\n    Type extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = (\n    event: Emitter.EventType<Target, Type, EventMap>,\n  ) => Emitter.ListenerReturnType<Target, Type, EventMap> extends [void]\n    ? void\n    : Emitter.ListenerReturnType<Target, Type, EventMap>\n\n  /**\n   * Returns the return type of the listener for the given event type.\n   *\n   * @example\n   * const emitter = new Emitter<{ getTotalPrice: TypedEvent<Cart, number> }>()\n   * type ListenerReturnType = Emitter.InferListenerReturnType<typeof emitter, 'getTotalPrice'>\n   * // number\n   */\n  export type ListenerReturnType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = EventMap[EventType] extends TypedEvent<unknown, infer ReturnType>\n    ? ReturnType\n    : never\n}\n\nexport class Emitter<EventMap extends DefaultEventMap> {\n  #listeners: InternalListenersMap<typeof this, EventMap>\n\n  constructor() {\n    this.#listeners = {} as InternalListenersMap<typeof this, EventMap>\n  }\n\n  /**\n   * Adds a listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  public on<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: TypedListenerOptions,\n  ): typeof this {\n    return this.#addListener(type, listener, options)\n  }\n\n  /**\n   * Adds a one-time listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  public once<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: Omit<TypedListenerOptions, 'once'>,\n  ): typeof this {\n    return this.on(type, listener, { ...(options || {}), once: true })\n  }\n\n  /**\n   * Prepends a listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  public earlyOn<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: TypedListenerOptions,\n  ): typeof this {\n    return this.#addListener(type, listener, options, 'prepend')\n  }\n\n  /**\n   * Prepends a one-time listener for the given event type.\n   */\n  public earlyOnce<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: Omit<TypedListenerOptions, 'once'>,\n  ): typeof this {\n    return this.earlyOn(type, listener, { ...(options || {}), once: true })\n  }\n\n  /**\n   * Emits the given typed event.\n   *\n   * @returns {boolean} Returns `true` if the event had any listeners, `false` otherwise.\n   */\n  public emit<EventType extends keyof EventMap & string>(\n    event: Brand<EventMap[EventType], EventType>,\n  ): boolean {\n    if (this.listenerCount(event.type) === 0) {\n      return false\n    }\n\n    const proxiedEvent = this.#proxyEvent(event)\n\n    for (const listener of this.#listeners[event.type]) {\n      if (\n        proxiedEvent.event[kPropagationStopped] != null &&\n        proxiedEvent.event[kPropagationStopped] !== this\n      ) {\n        return false\n      }\n\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break\n      }\n\n      this.#callListener(proxiedEvent.event, listener)\n    }\n\n    proxiedEvent.revoke()\n\n    return true\n  }\n\n  /**\n   * Emits the given typed event and returns a promise that resolves\n   * when all the listeners for that event have settled.\n   *\n   * @returns {Promise<Array<Emitter.ListenerReturnType>>} A promise that resolves\n   * with the return values of all listeners.\n   */\n  public async emitAsPromise<EventType extends keyof EventMap & string>(\n    event: Brand<EventMap[EventType], EventType>,\n  ): Promise<\n    Array<Emitter.ListenerReturnType<typeof this, EventType, EventMap>>\n  > {\n    if (this.listenerCount(event.type) === 0) {\n      return []\n    }\n\n    const pendingListeners: Array<\n      Promise<Emitter.ListenerReturnType<typeof this, EventType, EventMap>>\n    > = []\n\n    const proxiedEvent = this.#proxyEvent(event)\n\n    for (const listener of this.#listeners[event.type]) {\n      if (\n        proxiedEvent.event[kPropagationStopped] != null &&\n        proxiedEvent.event[kPropagationStopped] !== this\n      ) {\n        return []\n      }\n\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break\n      }\n\n      pendingListeners.push(\n        // Awaiting individual listeners guarantees their call order.\n        await Promise.resolve(this.#callListener(proxiedEvent.event, listener)),\n      )\n    }\n\n    proxiedEvent.revoke()\n\n    return Promise.allSettled(pendingListeners).then((results) => {\n      return results.map((result) =>\n        result.status === 'fulfilled' ? result.value : result.reason,\n      )\n    })\n  }\n\n  /**\n   * Emits the given event and returns a generator that yields\n   * the result of each listener in the order of their registration.\n   * This way, you stop exhausting the listeners once you get the expected value.\n   */\n  public *emitAsGenerator<EventType extends keyof EventMap & string>(\n    event: Brand<EventMap[EventType], EventType>,\n  ): Generator<Emitter.ListenerReturnType<typeof this, EventType, EventMap>> {\n    if (this.listenerCount(event.type) === 0) {\n      return\n    }\n\n    const proxiedEvent = this.#proxyEvent(event)\n\n    for (const listener of this.#listeners[event.type]) {\n      if (\n        proxiedEvent.event[kPropagationStopped] != null &&\n        proxiedEvent.event[kPropagationStopped] !== this\n      ) {\n        return\n      }\n\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break\n      }\n\n      yield this.#callListener(proxiedEvent.event, listener)\n    }\n\n    proxiedEvent.revoke()\n  }\n\n  /**\n   * Removes a listener for the given event type.\n   */\n  public removeListener<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n  ): void {\n    if (this.listenerCount(type) === 0) {\n      return\n    }\n\n    const nextListeners: Array<\n      Emitter.ListenerType<typeof this, EventType, EventMap>\n    > = []\n\n    for (const existingListener of this.#listeners[type]) {\n      if (existingListener !== listener) {\n        nextListeners.push(existingListener)\n      }\n    }\n\n    this.#listeners[type] = nextListeners\n  }\n\n  /**\n   * Removes all listeners for the given event type.\n   * If no event type is provided, removes all existing listeners.\n   */\n  public removeAllListeners<EventType extends keyof EventMap & string>(\n    type?: EventType,\n  ): void {\n    if (type == null) {\n      this.#listeners = {} as InternalListenersMap<typeof this>\n      return\n    }\n\n    this.#listeners[type] = []\n  }\n\n  /**\n   * Returns the list of listeners for the given event type.\n   * If no even type is provided, returns all listeners.\n   */\n  public listeners<EventType extends keyof EventMap & string>(\n    type?: EventType,\n  ): Array<Emitter.ListenerType<typeof this, EventType, EventMap>> {\n    if (type == null) {\n      return Object.values(this.#listeners).flat()\n    }\n\n    return this.#listeners[type] || []\n  }\n\n  /**\n   * Returns the number of listeners for the given event type.\n   * If no even type is provided, returns the total number of listeners.\n   */\n  public listenerCount<EventType extends keyof EventMap & string>(\n    type?: EventType,\n  ): number {\n    return this.listeners(type).length\n  }\n\n  #addListener<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options: TypedListenerOptions | undefined,\n    insertMode: 'append' | 'prepend' = 'append',\n  ): typeof this {\n    this.#listeners[type] ??= []\n\n    if (insertMode === 'prepend') {\n      this.#listeners[type].unshift(listener)\n    } else {\n      this.#listeners[type].push(listener)\n    }\n\n    if (options) {\n      Object.defineProperty(listener, kListenerOptions, {\n        value: options,\n        enumerable: false,\n        writable: false,\n      })\n\n      if (options.signal) {\n        options.signal.addEventListener(\n          'abort',\n          () => {\n            this.removeListener(type, listener)\n          },\n          { once: true },\n        )\n      }\n    }\n\n    return this\n  }\n\n  #proxyEvent<Event extends TypedEvent>(\n    event: Event,\n  ): { event: Event; revoke: () => void } {\n    const { stopPropagation } = event\n\n    event.stopPropagation = new Proxy(event.stopPropagation, {\n      apply: (target, thisArg, argArray) => {\n        event[kPropagationStopped] = this\n        return Reflect.apply(target, thisArg, argArray)\n      },\n    })\n\n    return {\n      event,\n      revoke() {\n        event.stopPropagation = stopPropagation\n      },\n    }\n  }\n\n  #callListener<EventType extends keyof EventMap & string>(\n    event: Event,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap> & {\n      [kListenerOptions]?: TypedListenerOptions\n    },\n  ) {\n    const returnValue = listener.call(this, event)\n\n    if (listener[kListenerOptions]?.once) {\n      this.removeListener(event.type, listener)\n    }\n\n    return returnValue\n  }\n}\n","import { Emitter, TypedEvent } from 'rettime'\nimport { isObject } from '~/core/utils/internal/isObject'\nimport type { StringifiedResponse } from '../setupWorker/glossary'\n\nexport interface WorkerChannelOptions {\n  worker: Promise<ServiceWorker>\n}\n\nexport type WorkerChannelEventMap = {\n  REQUEST: WorkerEvent<IncomingWorkerRequest>\n  RESPONSE: WorkerEvent<IncomingWorkerResponse>\n  MOCKING_ENABLED: WorkerEvent<{\n    client: {\n      id: string\n      frameType: string\n    }\n  }>\n  INTEGRITY_CHECK_RESPONSE: WorkerEvent<{\n    packageVersion: string\n    checksum: string\n  }>\n  KEEPALIVE_RESPONSE: TypedEvent<never>\n}\n\n/**\n * Request representation received from the worker message event.\n */\nexport interface IncomingWorkerRequest\n  extends Omit<\n    Request,\n    | 'text'\n    | 'body'\n    | 'json'\n    | 'blob'\n    | 'arrayBuffer'\n    | 'formData'\n    | 'clone'\n    | 'signal'\n    | 'isHistoryNavigation'\n    | 'isReloadNavigation'\n  > {\n  /**\n   * Unique ID of the request generated once the request is\n   * intercepted by the \"fetch\" event in the Service Worker.\n   */\n  id: string\n  interceptedAt: number\n  body?: ArrayBuffer | null\n}\n\ntype IncomingWorkerResponse = {\n  isMockedResponse: boolean\n  request: IncomingWorkerRequest\n  response: Pick<\n    Response,\n    'type' | 'ok' | 'status' | 'statusText' | 'body' | 'headers' | 'redirected'\n  >\n}\n\nexport type WorkerEventResponse = {\n  MOCK_RESPONSE: [\n    data: StringifiedResponse,\n    transfer?: [ReadableStream<Uint8Array>],\n  ]\n  PASSTHROUGH: []\n}\n\nexport class WorkerEvent<\n  DataType,\n  ReturnType = any,\n  EventType extends string = string,\n> extends TypedEvent<DataType, ReturnType, EventType> {\n  #workerEvent: MessageEvent\n\n  constructor(workerEvent: MessageEvent) {\n    const type = workerEvent.data.type as EventType\n    const data = workerEvent.data.payload as DataType\n\n    /**\n     * @note This is the only place we're mapping { type, payload }\n     * message structure of the worker. The client references the\n     * payload via `event.data`.\n     */\n    super(\n      // @ts-expect-error Troublesome `TypedEvent` extension.\n      type,\n      { data },\n    )\n    this.#workerEvent = workerEvent\n  }\n\n  get ports() {\n    return this.#workerEvent.ports\n  }\n\n  /**\n   * Reply directly to this event using its `MessagePort`.\n   */\n  public postMessage<Type extends keyof WorkerEventResponse>(\n    type: Type,\n    ...rest: WorkerEventResponse[Type]\n  ): void {\n    this.#workerEvent.ports[0].postMessage(\n      { type, data: rest[0] },\n      { transfer: rest[1] },\n    )\n  }\n}\n\n/**\n * Map of the events that can be sent to the Service Worker\n * from any execution context.\n */\ntype OutgoingWorkerEvents =\n  | 'MOCK_ACTIVATE'\n  | 'INTEGRITY_CHECK_REQUEST'\n  | 'KEEPALIVE_REQUEST'\n  | 'CLIENT_CLOSED'\n\nexport class WorkerChannel extends Emitter<WorkerChannelEventMap> {\n  constructor(protected readonly options: WorkerChannelOptions) {\n    super()\n\n    navigator.serviceWorker.addEventListener('message', async (event) => {\n      const worker = await this.options.worker\n\n      if (event.source != null && event.source !== worker) {\n        return\n      }\n\n      if (event.data && isObject(event.data) && 'type' in event.data) {\n        this.emit(new WorkerEvent<any, any, any>(event))\n      }\n    })\n  }\n\n  /**\n   * Send data to the Service Worker controlling this client.\n   * This triggers the `message` event listener on ServiceWorkerGlobalScope.\n   */\n  public postMessage(type: OutgoingWorkerEvents): void {\n    this.options.worker.then((worker) => {\n      worker.postMessage(type)\n    })\n  }\n}\n","import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { InterceptorError } from './InterceptorError'\n\nconst kRequestHandled = Symbol('kRequestHandled')\nexport const kResponsePromise = Symbol('kResponsePromise')\n\nexport class RequestController {\n  /**\n   * Internal response promise.\n   * Available only for the library internals to grab the\n   * response instance provided by the developer.\n   * @note This promise cannot be rejected. It's either infinitely\n   * pending or resolved with whichever Response was passed to `respondWith()`.\n   */\n  [kResponsePromise]: DeferredPromise<\n    Response | Record<string, any> | undefined\n  >;\n\n  /**\n   * Internal flag indicating if this request has been handled.\n   * @note The response promise becomes \"fulfilled\" on the next tick.\n   */\n  [kRequestHandled]: boolean\n\n  constructor(private request: Request) {\n    this[kRequestHandled] = false\n    this[kResponsePromise] = new DeferredPromise()\n  }\n\n  /**\n   * Respond to this request with the given `Response` instance.\n   * @example\n   * controller.respondWith(new Response())\n   * controller.respondWith(Response.json({ id }))\n   * controller.respondWith(Response.error())\n   */\n  public respondWith(response: Response): void {\n    invariant.as(\n      InterceptorError,\n      !this[kRequestHandled],\n      'Failed to respond to the \"%s %s\" request: the \"request\" event has already been handled.',\n      this.request.method,\n      this.request.url\n    )\n\n    this[kRequestHandled] = true\n    this[kResponsePromise].resolve(response)\n\n    /**\n     * @note The request controller doesn't do anything\n     * apart from letting the interceptor await the response\n     * provided by the developer through the response promise.\n     * Each interceptor implements the actual respondWith/errorWith\n     * logic based on that interceptor's needs.\n     */\n  }\n\n  /**\n   * Error this request with the given reason.\n   *\n   * @example\n   * controller.errorWith()\n   * controller.errorWith(new Error('Oops!'))\n   * controller.errorWith({ message: 'Oops!'})\n   */\n  public errorWith(reason?: Error | Record<string, any>): void {\n    invariant.as(\n      InterceptorError,\n      !this[kRequestHandled],\n      'Failed to error the \"%s %s\" request: the \"request\" event has already been handled.',\n      this.request.method,\n      this.request.url\n    )\n\n    this[kRequestHandled] = true\n\n    /**\n     * @note Resolve the response promise, not reject.\n     * This helps us differentiate between unhandled exceptions\n     * and intended errors (\"errorWith\") while waiting for the response.\n     */\n    this[kResponsePromise].resolve(reason)\n  }\n}\n","export class InterceptorError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = 'InterceptorError'\n    Object.setPrototypeOf(this, InterceptorError.prototype)\n  }\n}\n","import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Emits an event on the given emitter but executes\n * the listeners sequentially. This accounts for asynchronous\n * listeners (e.g. those having \"sleep\" and handling the request).\n */\nexport async function emitAsync<\n  Events extends EventMap,\n  EventName extends keyof Events\n>(\n  emitter: Emitter<Events>,\n  eventName: EventName,\n  ...data: Events[EventName]\n): Promise<void> {\n  const listners = emitter.listeners(eventName)\n\n  if (listners.length === 0) {\n    return\n  }\n\n  for (const listener of listners) {\n    await listener.apply(emitter, data)\n  }\n}\n","import type { Emitter } from 'strict-event-emitter'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { until } from '@open-draft/until'\nimport type { HttpRequestEventMap } from '../glossary'\nimport { emitAsync } from './emitAsync'\nimport { kResponsePromise, RequestController } from '../RequestController'\nimport {\n  createServerErrorResponse,\n  isResponseError,\n  isResponseLike,\n  ResponseError,\n} from './responseUtils'\nimport { InterceptorError } from '../InterceptorError'\nimport { isNodeLikeError } from './isNodeLikeError'\nimport { isObject } from './isObject'\n\ninterface HandleRequestOptions {\n  requestId: string\n  request: Request\n  emitter: Emitter<HttpRequestEventMap>\n  controller: RequestController\n\n  /**\n   * Called when the request has been handled\n   * with the given `Response` instance.\n   */\n  onResponse: (response: Response) => void | Promise<void>\n\n  /**\n   * Called when the request has been handled\n   * with the given `Response.error()` instance.\n   */\n  onRequestError: (response: ResponseError) => void\n\n  /**\n   * Called when an unhandled error happens during the\n   * request handling. This is never a thrown error/response.\n   */\n  onError: (error: unknown) => void\n}\n\n/**\n * @returns {Promise<boolean>} Indicates whether the request has been handled.\n */\nexport async function handleRequest(\n  options: HandleRequestOptions\n): Promise<boolean> {\n  const handleResponse = async (\n    response: Response | Error | Record<string, any>\n  ) => {\n    if (response instanceof Error) {\n      options.onError(response)\n      return true\n    }\n\n    // Handle \"Response.error()\" instances.\n    if (isResponseError(response)) {\n      options.onRequestError(response)\n      return true\n    }\n\n    /**\n     * Handle normal responses or response-like objects.\n     * @note This must come before the arbitrary object check\n     * since Response instances are, in fact, objects.\n     */\n    if (isResponseLike(response)) {\n      await options.onResponse(response)\n      return true\n    }\n\n    // Handle arbitrary objects provided to `.errorWith(reason)`.\n    if (isObject(response)) {\n      options.onError(response)\n      return true\n    }\n\n    return false\n  }\n\n  const handleResponseError = async (error: unknown): Promise<boolean> => {\n    // Forward the special interceptor error instances\n    // to the developer. These must not be handled in any way.\n    if (error instanceof InterceptorError) {\n      throw result.error\n    }\n\n    // Support mocking Node.js-like errors.\n    if (isNodeLikeError(error)) {\n      options.onError(error)\n      return true\n    }\n\n    // Handle thrown responses.\n    if (error instanceof Response) {\n      return await handleResponse(error)\n    }\n\n    return false\n  }\n\n  // Add the last \"request\" listener to check if the request\n  // has been handled in any way. If it hasn't, resolve the\n  // response promise with undefined.\n  options.emitter.once('request', ({ requestId: pendingRequestId }) => {\n    if (pendingRequestId !== options.requestId) {\n      return\n    }\n\n    if (options.controller[kResponsePromise].state === 'pending') {\n      options.controller[kResponsePromise].resolve(undefined)\n    }\n  })\n\n  const requestAbortPromise = new DeferredPromise<void, unknown>()\n\n  /**\n   * @note `signal` is not always defined in React Native.\n   */\n  if (options.request.signal) {\n    if (options.request.signal.aborted) {\n      requestAbortPromise.reject(options.request.signal.reason)\n    } else {\n      options.request.signal.addEventListener(\n        'abort',\n        () => {\n          requestAbortPromise.reject(options.request.signal.reason)\n        },\n        { once: true }\n      )\n    }\n  }\n\n  const result = await until(async () => {\n    // Emit the \"request\" event and wait until all the listeners\n    // for that event are finished (e.g. async listeners awaited).\n    // By the end of this promise, the developer cannot affect the\n    // request anymore.\n    const requestListenersPromise = emitAsync(options.emitter, 'request', {\n      requestId: options.requestId,\n      request: options.request,\n      controller: options.controller,\n    })\n\n    await Promise.race([\n      // Short-circuit the request handling promise if the request gets aborted.\n      requestAbortPromise,\n      requestListenersPromise,\n      options.controller[kResponsePromise],\n    ])\n\n    // The response promise will settle immediately once\n    // the developer calls either \"respondWith\" or \"errorWith\".\n    return await options.controller[kResponsePromise]\n  })\n\n  // Handle the request being aborted while waiting for the request listeners.\n  if (requestAbortPromise.state === 'rejected') {\n    options.onError(requestAbortPromise.rejectionReason)\n    return true\n  }\n\n  if (result.error) {\n    // Handle the error during the request listener execution.\n    // These can be thrown responses or request errors.\n    if (await handleResponseError(result.error)) {\n      return true\n    }\n\n    // If the developer has added \"unhandledException\" listeners,\n    // allow them to handle the error. They can translate it to a\n    // mocked response, network error, or forward it as-is.\n    if (options.emitter.listenerCount('unhandledException') > 0) {\n      // Create a new request controller just for the unhandled exception case.\n      // This is needed because the original controller might have been already\n      // interacted with (e.g. \"respondWith\" or \"errorWith\" called on it).\n      const unhandledExceptionController = new RequestController(\n        options.request\n      )\n\n      await emitAsync(options.emitter, 'unhandledException', {\n        error: result.error,\n        request: options.request,\n        requestId: options.requestId,\n        controller: unhandledExceptionController,\n      }).then(() => {\n        // If all the \"unhandledException\" listeners have finished\n        // but have not handled the response in any way, preemptively\n        // resolve the pending response promise from the new controller.\n        // This prevents it from hanging forever.\n        if (\n          unhandledExceptionController[kResponsePromise].state === 'pending'\n        ) {\n          unhandledExceptionController[kResponsePromise].resolve(undefined)\n        }\n      })\n\n      const nextResult = await until(\n        () => unhandledExceptionController[kResponsePromise]\n      )\n\n      /**\n       * @note Handle the result of the unhandled controller\n       * in the same way as the original request controller.\n       * The exception here is that thrown errors within the\n       * \"unhandledException\" event do NOT result in another\n       * emit of the same event. They are forwarded as-is.\n       */\n      if (nextResult.error) {\n        return handleResponseError(nextResult.error)\n      }\n\n      if (nextResult.data) {\n        return handleResponse(nextResult.data)\n      }\n    }\n\n    // Otherwise, coerce unhandled exceptions to a 500 Internal Server Error response.\n    options.onResponse(createServerErrorResponse(result.error))\n    return true\n  }\n\n  /**\n   * Handle a mocked Response instance.\n   * @note That this can also be an Error in case\n   * the developer called \"errorWith\". This differentiates\n   * unhandled exceptions from intended errors.\n   */\n  if (result.data) {\n    return handleResponse(result.data)\n  }\n\n  // In all other cases, consider the request unhandled.\n  return false\n}\n","/**\n * Determines if a given value is an instance of object.\n */\nexport function isObject<T>(value: any, loose = false): value is T {\n  return loose\n    ? Object.prototype.toString.call(value).startsWith('[object ')\n    : Object.prototype.toString.call(value) === '[object Object]'\n}\n","/**\n * A function that validates if property access is possible on an object\n * without throwing. It returns `true` if the property access is possible\n * and `false` otherwise.\n *\n * Environments like miniflare will throw on property access on certain objects\n * like Request and Response, for unimplemented properties.\n */\nexport function isPropertyAccessible<Obj extends Record<string, any>>(\n  obj: Obj,\n  key: keyof Obj\n) {\n  try {\n    obj[key]\n    return true\n  } catch {\n    return false\n  }\n}\n","import { isObject } from './isObject'\nimport { isPropertyAccessible } from './isPropertyAccessible'\n\n/**\n * Creates a generic 500 Unhandled Exception response.\n */\nexport function createServerErrorResponse(body: unknown): Response {\n  return new Response(\n    JSON.stringify(\n      body instanceof Error\n        ? {\n            name: body.name,\n            message: body.message,\n            stack: body.stack,\n          }\n        : body\n    ),\n    {\n      status: 500,\n      statusText: 'Unhandled Exception',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    }\n  )\n}\n\nexport type ResponseError = Response & { type: 'error' }\n\n/**\n * Check if the given response is a `Response.error()`.\n *\n * @note Some environments, like Miniflare (Cloudflare) do not\n * implement the \"Response.type\" property and throw on its access.\n * Safely check if we can access \"type\" on \"Response\" before continuing.\n * @see https://github.com/mswjs/msw/issues/1834\n */\nexport function isResponseError(response: unknown): response is ResponseError {\n  return (\n    response != null &&\n    response instanceof Response &&\n    isPropertyAccessible(response, 'type') &&\n    response.type === 'error'\n  )\n}\n\n/**\n * Check if the given value is a `Response` or a Response-like object.\n * This is different from `value instanceof Response` because it supports\n * custom `Response` constructors, like the one when using Undici directly.\n */\nexport function isResponseLike(value: unknown): value is Response {\n  return (\n    isObject<Record<string, any>>(value, true) &&\n    isPropertyAccessible(value, 'status') &&\n    isPropertyAccessible(value, 'statusText') &&\n    isPropertyAccessible(value, 'bodyUsed')\n  )\n}\n","export function isNodeLikeError(\n  error: unknown\n): error is NodeJS.ErrnoException {\n  if (error == null) {\n    return false\n  }\n\n  if (!(error instanceof Error)) {\n    return false\n  }\n\n  return 'code' in error && 'errno' in error\n}\n","/**\n * Returns a boolean indicating whether the given global property\n * is defined and is configurable.\n */\nexport function hasConfigurableGlobal(propertyName: string): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(globalThis, propertyName)\n\n  // The property is not set at all.\n  if (typeof descriptor === 'undefined') {\n    return false\n  }\n\n  // The property is set to a getter that returns undefined.\n  if (\n    typeof descriptor.get === 'function' &&\n    typeof descriptor.get() === 'undefined'\n  ) {\n    return false\n  }\n\n  // The property is set to a value equal to undefined.\n  if (typeof descriptor.get === 'undefined' && descriptor.value == null) {\n    return false\n  }\n\n  if (typeof descriptor.set === 'undefined' && !descriptor.configurable) {\n    console.error(\n      `[MSW] Failed to apply interceptor: the global \\`${propertyName}\\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`\n    )\n    return false\n  }\n\n  return true\n}\n","import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { Interceptor } from '../../Interceptor'\nimport { RequestController } from '../../RequestController'\nimport { emitAsync } from '../../utils/emitAsync'\nimport { handleRequest } from '../../utils/handleRequest'\nimport { canParseUrl } from '../../utils/canParseUrl'\nimport { createRequestId } from '../../createRequestId'\nimport { createNetworkError } from './utils/createNetworkError'\nimport { followFetchRedirect } from './utils/followRedirect'\nimport { decompressResponse } from './utils/decompression'\nimport { hasConfigurableGlobal } from '../../utils/hasConfigurableGlobal'\nimport { FetchResponse } from '../../utils/fetchUtils'\nimport { setRawRequest } from '../../getRawRequest'\n\nexport class FetchInterceptor extends Interceptor<HttpRequestEventMap> {\n  static symbol = Symbol('fetch')\n\n  constructor() {\n    super(FetchInterceptor.symbol)\n  }\n\n  protected checkEnvironment() {\n    return hasConfigurableGlobal('fetch')\n  }\n\n  protected async setup() {\n    const pureFetch = globalThis.fetch\n\n    invariant(\n      !(pureFetch as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"fetch\" module: already patched.'\n    )\n\n    globalThis.fetch = async (input, init) => {\n      const requestId = createRequestId()\n\n      /**\n       * @note Resolve potentially relative request URL\n       * against the present `location`. This is mainly\n       * for native `fetch` in JSDOM.\n       * @see https://github.com/mswjs/msw/issues/1625\n       */\n      const resolvedInput =\n        typeof input === 'string' &&\n        typeof location !== 'undefined' &&\n        !canParseUrl(input)\n          ? new URL(input, location.href)\n          : input\n\n      const request = new Request(resolvedInput, init)\n\n      /**\n       * @note Set the raw request only if a Request instance was provided to fetch.\n       */\n      if (input instanceof Request) {\n        setRawRequest(request, input)\n      }\n\n      const responsePromise = new DeferredPromise<Response>()\n      const controller = new RequestController(request)\n\n      this.logger.info('[%s] %s', request.method, request.url)\n      this.logger.info('awaiting for the mocked response...')\n\n      this.logger.info(\n        'emitting the \"request\" event for %s listener(s)...',\n        this.emitter.listenerCount('request')\n      )\n\n      const isRequestHandled = await handleRequest({\n        request,\n        requestId,\n        emitter: this.emitter,\n        controller,\n        onResponse: async (rawResponse) => {\n          this.logger.info('received mocked response!', {\n            rawResponse,\n          })\n\n          // Decompress the mocked response body, if applicable.\n          const decompressedStream = decompressResponse(rawResponse)\n          const response =\n            decompressedStream === null\n              ? rawResponse\n              : new FetchResponse(decompressedStream, rawResponse)\n\n          FetchResponse.setUrl(request.url, response)\n\n          /**\n           * Undici's handling of following redirect responses.\n           * Treat the \"manual\" redirect mode as a regular mocked response.\n           * This way, the client can manually follow the redirect it receives.\n           * @see https://github.com/nodejs/undici/blob/a6dac3149c505b58d2e6d068b97f4dc993da55f0/lib/web/fetch/index.js#L1173\n           */\n          if (FetchResponse.isRedirectResponse(response.status)) {\n            // Reject the request promise if its `redirect` is set to `error`\n            // and it receives a mocked redirect response.\n            if (request.redirect === 'error') {\n              responsePromise.reject(createNetworkError('unexpected redirect'))\n              return\n            }\n\n            if (request.redirect === 'follow') {\n              followFetchRedirect(request, response).then(\n                (response) => {\n                  responsePromise.resolve(response)\n                },\n                (reason) => {\n                  responsePromise.reject(reason)\n                }\n              )\n              return\n            }\n          }\n\n          if (this.emitter.listenerCount('response') > 0) {\n            this.logger.info('emitting the \"response\" event...')\n\n            // Await the response listeners to finish before resolving\n            // the response promise. This ensures all your logic finishes\n            // before the interceptor resolves the pending response.\n            await emitAsync(this.emitter, 'response', {\n              // Clone the mocked response for the \"response\" event listener.\n              // This way, the listener can read the response and not lock its body\n              // for the actual fetch consumer.\n              response: response.clone(),\n              isMockedResponse: true,\n              request,\n              requestId,\n            })\n          }\n\n          responsePromise.resolve(response)\n        },\n        onRequestError: (response) => {\n          this.logger.info('request has errored!', { response })\n          responsePromise.reject(createNetworkError(response))\n        },\n        onError: (error) => {\n          this.logger.info('request has been aborted!', { error })\n          responsePromise.reject(error)\n        },\n      })\n\n      if (isRequestHandled) {\n        this.logger.info('request has been handled, returning mock promise...')\n        return responsePromise\n      }\n\n      this.logger.info(\n        'no mocked response received, performing request as-is...'\n      )\n\n      /**\n       * @note Clone the request instance right before performing it.\n       * This preserves any modifications made to the intercepted request\n       * in the \"request\" listener. This also allows the user to read the\n       * request body in the \"response\" listener (otherwise \"unusable\").\n       */\n      const requestCloneForResponseEvent = request.clone()\n\n      return pureFetch(request).then(async (response) => {\n        this.logger.info('original fetch performed', response)\n\n        if (this.emitter.listenerCount('response') > 0) {\n          this.logger.info('emitting the \"response\" event...')\n\n          const responseClone = response.clone()\n\n          await emitAsync(this.emitter, 'response', {\n            response: responseClone,\n            isMockedResponse: false,\n            request: requestCloneForResponseEvent,\n            requestId,\n          })\n        }\n\n        return response\n      })\n    }\n\n    Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.fetch = pureFetch\n\n      this.logger.info(\n        'restored native \"globalThis.fetch\"!',\n        globalThis.fetch.name\n      )\n    })\n  }\n}\n","export function createNetworkError(cause?: unknown) {\n  return Object.assign(new TypeError('Failed to fetch'), {\n    cause,\n  })\n}\n","import { createNetworkError } from './createNetworkError'\n\nconst REQUEST_BODY_HEADERS = [\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-type',\n  'content-length',\n]\n\nconst kRedirectCount = Symbol('kRedirectCount')\n\n/**\n * @see https://github.com/nodejs/undici/blob/a6dac3149c505b58d2e6d068b97f4dc993da55f0/lib/web/fetch/index.js#L1210\n */\nexport async function followFetchRedirect(\n  request: Request,\n  response: Response\n): Promise<Response> {\n  if (response.status !== 303 && request.body != null) {\n    return Promise.reject(createNetworkError())\n  }\n\n  const requestUrl = new URL(request.url)\n\n  let locationUrl: URL\n  try {\n    // If the location is a relative URL, use the request URL as the base URL.\n    locationUrl = new URL(response.headers.get('location')!, request.url) \n  } catch (error) {\n    return Promise.reject(createNetworkError(error))\n  }\n\n  if (\n    !(locationUrl.protocol === 'http:' || locationUrl.protocol === 'https:')\n  ) {\n    return Promise.reject(\n      createNetworkError('URL scheme must be a HTTP(S) scheme')\n    )\n  }\n\n  if (Reflect.get(request, kRedirectCount) > 20) {\n    return Promise.reject(createNetworkError('redirect count exceeded'))\n  }\n\n  Object.defineProperty(request, kRedirectCount, {\n    value: (Reflect.get(request, kRedirectCount) || 0) + 1,\n  })\n\n  if (\n    request.mode === 'cors' &&\n    (locationUrl.username || locationUrl.password) &&\n    !sameOrigin(requestUrl, locationUrl)\n  ) {\n    return Promise.reject(\n      createNetworkError('cross origin not allowed for request mode \"cors\"')\n    )\n  }\n\n  const requestInit: RequestInit = {}\n\n  if (\n    ([301, 302].includes(response.status) && request.method === 'POST') ||\n    (response.status === 303 && !['HEAD', 'GET'].includes(request.method))\n  ) {\n    requestInit.method = 'GET'\n    requestInit.body = null\n\n    REQUEST_BODY_HEADERS.forEach((headerName) => {\n      request.headers.delete(headerName)\n    })\n  }\n\n  if (!sameOrigin(requestUrl, locationUrl)) {\n    request.headers.delete('authorization')\n    request.headers.delete('proxy-authorization')\n    request.headers.delete('cookie')\n    request.headers.delete('host')\n  }\n\n  /**\n   * @note Undici \"safely\" extracts the request body.\n   * I suspect we cannot dispatch this request again\n   * since its body has been read and the stream is locked.\n   */\n\n  requestInit.headers = request.headers\n  return fetch(new Request(locationUrl, requestInit))\n}\n\n/**\n * @see https://github.com/nodejs/undici/blob/a6dac3149c505b58d2e6d068b97f4dc993da55f0/lib/web/fetch/util.js#L761\n */\nfunction sameOrigin(left: URL, right: URL): boolean {\n  if (left.origin === right.origin && left.origin === 'null') {\n    return true\n  }\n\n  if (\n    left.protocol === right.protocol &&\n    left.hostname === right.hostname &&\n    left.port === right.port\n  ) {\n    return true\n  }\n\n  return false\n}\n","export class BrotliDecompressionStream extends TransformStream {\n  constructor() {\n    console.warn(\n      '[Interceptors]: Brotli decompression of response streams is not supported in the browser'\n    )\n\n    super({\n      transform(chunk, controller) {\n        // Keep the stream as passthrough, it does nothing.\n        controller.enqueue(chunk)\n      },\n    })\n  }\n}\n","// Import from an internal alias that resolves to different modules\n// depending on the environment. This way, we can keep the fetch interceptor\n// intact while using different strategies for Brotli decompression.\nimport { BrotliDecompressionStream } from 'internal:brotli-decompress'\n\nclass PipelineStream extends TransformStream {\n  constructor(\n    transformStreams: Array<TransformStream>,\n    ...strategies: Array<QueuingStrategy>\n  ) {\n    super({}, ...strategies)\n\n    const readable = [super.readable as any, ...transformStreams].reduce(\n      (readable, transform) => readable.pipeThrough(transform)\n    )\n\n    Object.defineProperty(this, 'readable', {\n      get() {\n        return readable\n      },\n    })\n  }\n}\n\nexport function parseContentEncoding(contentEncoding: string): Array<string> {\n  return contentEncoding\n    .toLowerCase()\n    .split(',')\n    .map((coding) => coding.trim())\n}\n\nfunction createDecompressionStream(\n  contentEncoding: string\n): TransformStream | null {\n  if (contentEncoding === '') {\n    return null\n  }\n\n  const codings = parseContentEncoding(contentEncoding)\n\n  if (codings.length === 0) {\n    return null\n  }\n\n  const transformers = codings.reduceRight<Array<TransformStream>>(\n    (transformers, coding) => {\n      if (coding === 'gzip' || coding === 'x-gzip') {\n        return transformers.concat(new DecompressionStream('gzip'))\n      } else if (coding === 'deflate') {\n        return transformers.concat(new DecompressionStream('deflate'))\n      } else if (coding === 'br') {\n        return transformers.concat(new BrotliDecompressionStream())\n      } else {\n        transformers.length = 0\n      }\n\n      return transformers\n    },\n    []\n  )\n\n  return new PipelineStream(transformers)\n}\n\nexport function decompressResponse(\n  response: Response\n): ReadableStream<any> | null {\n  if (response.body === null) {\n    return null\n  }\n\n  const decompressionStream = createDecompressionStream(\n    response.headers.get('content-encoding') || ''\n  )\n\n  if (!decompressionStream) {\n    return null\n  }\n\n  // Use `pipeTo` and return the decompression stream's readable\n  // instead of `pipeThrough` because that will lock the original\n  // response stream, making it unusable as the input to Response.\n  response.body.pipeTo(decompressionStream.writable)\n  return decompressionStream.readable\n}\n","import { invariant } from 'outvariant'\nimport { Emitter } from 'strict-event-emitter'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { Interceptor } from '../../Interceptor'\nimport { createXMLHttpRequestProxy } from './XMLHttpRequestProxy'\nimport { hasConfigurableGlobal } from '../../utils/hasConfigurableGlobal'\n\nexport type XMLHttpRequestEmitter = Emitter<HttpRequestEventMap>\n\nexport class XMLHttpRequestInterceptor extends Interceptor<HttpRequestEventMap> {\n  static interceptorSymbol = Symbol('xhr')\n\n  constructor() {\n    super(XMLHttpRequestInterceptor.interceptorSymbol)\n  }\n\n  protected checkEnvironment() {\n    return hasConfigurableGlobal('XMLHttpRequest')\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('patching \"XMLHttpRequest\" module...')\n\n    const PureXMLHttpRequest = globalThis.XMLHttpRequest\n\n    invariant(\n      !(PureXMLHttpRequest as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"XMLHttpRequest\" module: already patched.'\n    )\n\n    globalThis.XMLHttpRequest = createXMLHttpRequestProxy({\n      emitter: this.emitter,\n      logger: this.logger,\n    })\n\n    logger.info(\n      'native \"XMLHttpRequest\" module patched!',\n      globalThis.XMLHttpRequest.name\n    )\n\n    Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.XMLHttpRequest = PureXMLHttpRequest\n      logger.info(\n        'native \"XMLHttpRequest\" module restored!',\n        globalThis.XMLHttpRequest.name\n      )\n    })\n  }\n}\n","import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport type { Logger } from '@open-draft/logger'\nimport { concatArrayBuffer } from './utils/concatArrayBuffer'\nimport { createEvent } from './utils/createEvent'\nimport {\n  decodeBuffer,\n  encodeBuffer,\n  toArrayBuffer,\n} from '../../utils/bufferUtils'\nimport { createProxy } from '../../utils/createProxy'\nimport { isDomParserSupportedType } from './utils/isDomParserSupportedType'\nimport { parseJson } from '../../utils/parseJson'\nimport { createResponse } from './utils/createResponse'\nimport { INTERNAL_REQUEST_ID_HEADER_NAME } from '../../Interceptor'\nimport { createRequestId } from '../../createRequestId'\nimport { getBodyByteLength } from './utils/getBodyByteLength'\nimport { setRawRequest } from '../../getRawRequest'\n\nconst kIsRequestHandled = Symbol('kIsRequestHandled')\nconst IS_NODE = isNodeProcess()\nconst kFetchRequest = Symbol('kFetchRequest')\n\n/**\n * An `XMLHttpRequest` instance controller that allows us\n * to handle any given request instance (e.g. responding to it).\n */\nexport class XMLHttpRequestController {\n  public request: XMLHttpRequest\n  public requestId: string\n  public onRequest?: (\n    this: XMLHttpRequestController,\n    args: {\n      request: Request\n      requestId: string\n    }\n  ) => Promise<void>\n  public onResponse?: (\n    this: XMLHttpRequestController,\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ) => void;\n\n  [kIsRequestHandled]: boolean;\n  [kFetchRequest]?: Request\n  private method: string = 'GET'\n  private url: URL = null as any\n  private requestHeaders: Headers\n  private responseBuffer: Uint8Array\n  private events: Map<keyof XMLHttpRequestEventTargetEventMap, Array<Function>>\n  private uploadEvents: Map<\n    keyof XMLHttpRequestEventTargetEventMap,\n    Array<Function>\n  >\n\n  constructor(readonly initialRequest: XMLHttpRequest, public logger: Logger) {\n    this[kIsRequestHandled] = false\n\n    this.events = new Map()\n    this.uploadEvents = new Map()\n    this.requestId = createRequestId()\n    this.requestHeaders = new Headers()\n    this.responseBuffer = new Uint8Array()\n\n    this.request = createProxy(initialRequest, {\n      setProperty: ([propertyName, nextValue], invoke) => {\n        switch (propertyName) {\n          case 'ontimeout': {\n            const eventName = propertyName.slice(\n              2\n            ) as keyof XMLHttpRequestEventTargetEventMap\n\n            /**\n             * @note Proxy callbacks to event listeners because JSDOM has trouble\n             * translating these properties to callbacks. It seemed to be operating\n             * on events exclusively.\n             */\n            this.request.addEventListener(eventName, nextValue as any)\n\n            return invoke()\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n      methodCall: ([methodName, args], invoke) => {\n        switch (methodName) {\n          case 'open': {\n            const [method, url] = args as [string, string | undefined]\n\n            if (typeof url === 'undefined') {\n              this.method = 'GET'\n              this.url = toAbsoluteUrl(method)\n            } else {\n              this.method = method\n              this.url = toAbsoluteUrl(url)\n            }\n\n            this.logger = this.logger.extend(`${this.method} ${this.url.href}`)\n            this.logger.info('open', this.method, this.url.href)\n\n            return invoke()\n          }\n\n          case 'addEventListener': {\n            const [eventName, listener] = args as [\n              keyof XMLHttpRequestEventTargetEventMap,\n              Function\n            ]\n\n            this.registerEvent(eventName, listener)\n            this.logger.info('addEventListener', eventName, listener)\n\n            return invoke()\n          }\n\n          case 'setRequestHeader': {\n            const [name, value] = args as [string, string]\n            this.requestHeaders.set(name, value)\n\n            this.logger.info('setRequestHeader', name, value)\n\n            return invoke()\n          }\n\n          case 'send': {\n            const [body] = args as [\n              body?: XMLHttpRequestBodyInit | Document | null\n            ]\n\n            this.request.addEventListener('load', () => {\n              if (typeof this.onResponse !== 'undefined') {\n                // Create a Fetch API Response representation of whichever\n                // response this XMLHttpRequest received. Note those may\n                // be either a mocked and the original response.\n                const fetchResponse = createResponse(\n                  this.request,\n                  /**\n                   * The `response` property is the right way to read\n                   * the ambiguous response body, as the request's \"responseType\" may differ.\n                   * @see https://xhr.spec.whatwg.org/#the-response-attribute\n                   */\n                  this.request.response\n                )\n\n                // Notify the consumer about the response.\n                this.onResponse.call(this, {\n                  response: fetchResponse,\n                  isMockedResponse: this[kIsRequestHandled],\n                  request: fetchRequest,\n                  requestId: this.requestId!,\n                })\n              }\n            })\n\n            const requestBody =\n              typeof body === 'string' ? encodeBuffer(body) : body\n\n            // Delegate request handling to the consumer.\n            const fetchRequest = this.toFetchApiRequest(requestBody)\n            this[kFetchRequest] = fetchRequest.clone()\n\n            const onceRequestSettled =\n              this.onRequest?.call(this, {\n                request: fetchRequest,\n                requestId: this.requestId!,\n              }) || Promise.resolve()\n\n            onceRequestSettled.finally(() => {\n              // If the consumer didn't handle the request (called `.respondWith()`) perform it as-is.\n              if (!this[kIsRequestHandled]) {\n                this.logger.info(\n                  'request callback settled but request has not been handled (readystate %d), performing as-is...',\n                  this.request.readyState\n                )\n\n                /**\n                 * @note Set the intercepted request ID on the original request in Node.js\n                 * so that if it triggers any other interceptors, they don't attempt\n                 * to process it once again.\n                 *\n                 * For instance, XMLHttpRequest is often implemented via \"http.ClientRequest\"\n                 * and we don't want for both XHR and ClientRequest interceptors to\n                 * handle the same request at the same time (e.g. emit the \"response\" event twice).\n                 */\n                if (IS_NODE) {\n                  this.request.setRequestHeader(\n                    INTERNAL_REQUEST_ID_HEADER_NAME,\n                    this.requestId!\n                  )\n                }\n\n                return invoke()\n              }\n            })\n\n            break\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n    })\n\n    /**\n     * Proxy the `.upload` property to gather the event listeners/callbacks.\n     */\n    define(\n      this.request,\n      'upload',\n      createProxy(this.request.upload, {\n        setProperty: ([propertyName, nextValue], invoke) => {\n          switch (propertyName) {\n            case 'onloadstart':\n            case 'onprogress':\n            case 'onaboart':\n            case 'onerror':\n            case 'onload':\n            case 'ontimeout':\n            case 'onloadend': {\n              const eventName = propertyName.slice(\n                2\n              ) as keyof XMLHttpRequestEventTargetEventMap\n\n              this.registerUploadEvent(eventName, nextValue as Function)\n            }\n          }\n\n          return invoke()\n        },\n        methodCall: ([methodName, args], invoke) => {\n          switch (methodName) {\n            case 'addEventListener': {\n              const [eventName, listener] = args as [\n                keyof XMLHttpRequestEventTargetEventMap,\n                Function\n              ]\n              this.registerUploadEvent(eventName, listener)\n              this.logger.info('upload.addEventListener', eventName, listener)\n\n              return invoke()\n            }\n          }\n        },\n      })\n    )\n  }\n\n  private registerEvent(\n    eventName: keyof XMLHttpRequestEventTargetEventMap,\n    listener: Function\n  ): void {\n    const prevEvents = this.events.get(eventName) || []\n    const nextEvents = prevEvents.concat(listener)\n    this.events.set(eventName, nextEvents)\n\n    this.logger.info('registered event \"%s\"', eventName, listener)\n  }\n\n  private registerUploadEvent(\n    eventName: keyof XMLHttpRequestEventTargetEventMap,\n    listener: Function\n  ): void {\n    const prevEvents = this.uploadEvents.get(eventName) || []\n    const nextEvents = prevEvents.concat(listener)\n    this.uploadEvents.set(eventName, nextEvents)\n\n    this.logger.info('registered upload event \"%s\"', eventName, listener)\n  }\n\n  /**\n   * Responds to the current request with the given\n   * Fetch API `Response` instance.\n   */\n  public async respondWith(response: Response): Promise<void> {\n    /**\n     * @note Since `XMLHttpRequestController` delegates the handling of the responses\n     * to the \"load\" event listener that doesn't distinguish between the mocked and original\n     * responses, mark the request that had a mocked response with a corresponding symbol.\n     *\n     * Mark this request as having a mocked response immediately since\n     * calculating request/response total body length is asynchronous.\n     */\n    this[kIsRequestHandled] = true\n\n    /**\n     * Dispatch request upload events for requests with a body.\n     * @see https://github.com/mswjs/interceptors/issues/573\n     */\n    if (this[kFetchRequest]) {\n      const totalRequestBodyLength = await getBodyByteLength(\n        this[kFetchRequest]\n      )\n\n      this.trigger('loadstart', this.request.upload, {\n        loaded: 0,\n        total: totalRequestBodyLength,\n      })\n      this.trigger('progress', this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength,\n      })\n      this.trigger('load', this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength,\n      })\n      this.trigger('loadend', this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength,\n      })\n    }\n\n    this.logger.info(\n      'responding with a mocked response: %d %s',\n      response.status,\n      response.statusText\n    )\n\n    define(this.request, 'status', response.status)\n    define(this.request, 'statusText', response.statusText)\n    define(this.request, 'responseURL', this.url.href)\n\n    this.request.getResponseHeader = new Proxy(this.request.getResponseHeader, {\n      apply: (_, __, args: [name: string]) => {\n        this.logger.info('getResponseHeader', args[0])\n\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info('headers not received yet, returning null')\n\n          // Headers not received yet, nothing to return.\n          return null\n        }\n\n        const headerValue = response.headers.get(args[0])\n        this.logger.info(\n          'resolved response header \"%s\" to',\n          args[0],\n          headerValue\n        )\n\n        return headerValue\n      },\n    })\n\n    this.request.getAllResponseHeaders = new Proxy(\n      this.request.getAllResponseHeaders,\n      {\n        apply: () => {\n          this.logger.info('getAllResponseHeaders')\n\n          if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n            this.logger.info('headers not received yet, returning empty string')\n\n            // Headers not received yet, nothing to return.\n            return ''\n          }\n\n          const headersList = Array.from(response.headers.entries())\n          const allHeaders = headersList\n            .map(([headerName, headerValue]) => {\n              return `${headerName}: ${headerValue}`\n            })\n            .join('\\r\\n')\n\n          this.logger.info('resolved all response headers to', allHeaders)\n\n          return allHeaders\n        },\n      }\n    )\n\n    // Update the response getters to resolve against the mocked response.\n    Object.defineProperties(this.request, {\n      response: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.response,\n      },\n      responseText: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseText,\n      },\n      responseXML: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseXML,\n      },\n    })\n\n    const totalResponseBodyLength = await getBodyByteLength(response.clone())\n\n    this.logger.info('calculated response body length', totalResponseBodyLength)\n\n    this.trigger('loadstart', this.request, {\n      loaded: 0,\n      total: totalResponseBodyLength,\n    })\n\n    this.setReadyState(this.request.HEADERS_RECEIVED)\n    this.setReadyState(this.request.LOADING)\n\n    const finalizeResponse = () => {\n      this.logger.info('finalizing the mocked response...')\n\n      this.setReadyState(this.request.DONE)\n\n      this.trigger('load', this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n\n      this.trigger('loadend', this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n    }\n\n    if (response.body) {\n      this.logger.info('mocked response has body, streaming...')\n\n      const reader = response.body.getReader()\n\n      const readNextResponseBodyChunk = async () => {\n        const { value, done } = await reader.read()\n\n        if (done) {\n          this.logger.info('response body stream done!')\n          finalizeResponse()\n          return\n        }\n\n        if (value) {\n          this.logger.info('read response body chunk:', value)\n          this.responseBuffer = concatArrayBuffer(this.responseBuffer, value)\n\n          this.trigger('progress', this.request, {\n            loaded: this.responseBuffer.byteLength,\n            total: totalResponseBodyLength,\n          })\n        }\n\n        readNextResponseBodyChunk()\n      }\n\n      readNextResponseBodyChunk()\n    } else {\n      finalizeResponse()\n    }\n  }\n\n  private responseBufferToText(): string {\n    return decodeBuffer(this.responseBuffer)\n  }\n\n  get response(): unknown {\n    this.logger.info(\n      'getResponse (responseType: %s)',\n      this.request.responseType\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    switch (this.request.responseType) {\n      case 'json': {\n        const responseJson = parseJson(this.responseBufferToText())\n        this.logger.info('resolved response JSON', responseJson)\n\n        return responseJson\n      }\n\n      case 'arraybuffer': {\n        const arrayBuffer = toArrayBuffer(this.responseBuffer)\n        this.logger.info('resolved response ArrayBuffer', arrayBuffer)\n\n        return arrayBuffer\n      }\n\n      case 'blob': {\n        const mimeType =\n          this.request.getResponseHeader('Content-Type') || 'text/plain'\n        const responseBlob = new Blob([this.responseBufferToText()], {\n          type: mimeType,\n        })\n\n        this.logger.info(\n          'resolved response Blob (mime type: %s)',\n          responseBlob,\n          mimeType\n        )\n\n        return responseBlob\n      }\n\n      default: {\n        const responseText = this.responseBufferToText()\n        this.logger.info(\n          'resolving \"%s\" response type as text',\n          this.request.responseType,\n          responseText\n        )\n\n        return responseText\n      }\n    }\n  }\n\n  get responseText(): string {\n    /**\n     * Throw when trying to read the response body as text when the\n     * \"responseType\" doesn't expect text. This just respects the spec better.\n     * @see https://xhr.spec.whatwg.org/#the-responsetext-attribute\n     */\n    invariant(\n      this.request.responseType === '' || this.request.responseType === 'text',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (\n      this.request.readyState !== this.request.LOADING &&\n      this.request.readyState !== this.request.DONE\n    ) {\n      return ''\n    }\n\n    const responseText = this.responseBufferToText()\n    this.logger.info('getResponseText: \"%s\"', responseText)\n\n    return responseText\n  }\n\n  get responseXML(): Document | null {\n    invariant(\n      this.request.responseType === '' ||\n        this.request.responseType === 'document',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    const contentType = this.request.getResponseHeader('Content-Type') || ''\n\n    if (typeof DOMParser === 'undefined') {\n      console.warn(\n        'Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly.'\n      )\n      return null\n    }\n\n    if (isDomParserSupportedType(contentType)) {\n      return new DOMParser().parseFromString(\n        this.responseBufferToText(),\n        contentType\n      )\n    }\n\n    return null\n  }\n\n  public errorWith(error?: Error): void {\n    /**\n     * @note Mark this request as handled even if it received a mock error.\n     * This prevents the controller from trying to perform this request as-is.\n     */\n    this[kIsRequestHandled] = true\n    this.logger.info('responding with an error')\n\n    this.setReadyState(this.request.DONE)\n    this.trigger('error', this.request)\n    this.trigger('loadend', this.request)\n  }\n\n  /**\n   * Transitions this request's `readyState` to the given one.\n   */\n  private setReadyState(nextReadyState: number): void {\n    this.logger.info(\n      'setReadyState: %d -> %d',\n      this.request.readyState,\n      nextReadyState\n    )\n\n    if (this.request.readyState === nextReadyState) {\n      this.logger.info('ready state identical, skipping transition...')\n      return\n    }\n\n    define(this.request, 'readyState', nextReadyState)\n\n    this.logger.info('set readyState to: %d', nextReadyState)\n\n    if (nextReadyState !== this.request.UNSENT) {\n      this.logger.info('triggerring \"readystatechange\" event...')\n\n      this.trigger('readystatechange', this.request)\n    }\n  }\n\n  /**\n   * Triggers given event on the `XMLHttpRequest` instance.\n   */\n  private trigger<\n    EventName extends keyof (XMLHttpRequestEventTargetEventMap & {\n      readystatechange: ProgressEvent<XMLHttpRequestEventTarget>\n    })\n  >(\n    eventName: EventName,\n    target: XMLHttpRequest | XMLHttpRequestUpload,\n    options?: ProgressEventInit\n  ): void {\n    const callback = (target as XMLHttpRequest)[`on${eventName}`]\n    const event = createEvent(target, eventName, options)\n\n    this.logger.info('trigger \"%s\"', eventName, options || '')\n\n    // Invoke direct callbacks.\n    if (typeof callback === 'function') {\n      this.logger.info('found a direct \"%s\" callback, calling...', eventName)\n      callback.call(target as XMLHttpRequest, event)\n    }\n\n    // Invoke event listeners.\n    const events =\n      target instanceof XMLHttpRequestUpload ? this.uploadEvents : this.events\n\n    for (const [registeredEventName, listeners] of events) {\n      if (registeredEventName === eventName) {\n        this.logger.info(\n          'found %d listener(s) for \"%s\" event, calling...',\n          listeners.length,\n          eventName\n        )\n\n        listeners.forEach((listener) => listener.call(target, event))\n      }\n    }\n  }\n\n  /**\n   * Converts this `XMLHttpRequest` instance into a Fetch API `Request` instance.\n   */\n  private toFetchApiRequest(\n    body: XMLHttpRequestBodyInit | Document | null | undefined\n  ): Request {\n    this.logger.info('converting request to a Fetch API Request...')\n\n    // If the `Document` is used as the body of this XMLHttpRequest,\n    // set its inner text as the Fetch API Request body.\n    const resolvedBody =\n      body instanceof Document ? body.documentElement.innerText : body\n\n    const fetchRequest = new Request(this.url.href, {\n      method: this.method,\n      headers: this.requestHeaders,\n      /**\n       * @see https://xhr.spec.whatwg.org/#cross-origin-credentials\n       */\n      credentials: this.request.withCredentials ? 'include' : 'same-origin',\n      body: ['GET', 'HEAD'].includes(this.method.toUpperCase())\n        ? null\n        : resolvedBody,\n    })\n\n    const proxyHeaders = createProxy(fetchRequest.headers, {\n      methodCall: ([methodName, args], invoke) => {\n        // Forward the latest state of the internal request headers\n        // because the interceptor might have modified them\n        // without responding to the request.\n        switch (methodName) {\n          case 'append':\n          case 'set': {\n            const [headerName, headerValue] = args as [string, string]\n            this.request.setRequestHeader(headerName, headerValue)\n            break\n          }\n\n          case 'delete': {\n            const [headerName] = args as [string]\n            console.warn(\n              `XMLHttpRequest: Cannot remove a \"${headerName}\" header from the Fetch API representation of the \"${fetchRequest.method} ${fetchRequest.url}\" request. XMLHttpRequest headers cannot be removed.`\n            )\n            break\n          }\n        }\n\n        return invoke()\n      },\n    })\n    define(fetchRequest, 'headers', proxyHeaders)\n    setRawRequest(fetchRequest, this.request)\n\n    this.logger.info('converted request to a Fetch API Request!', fetchRequest)\n\n    return fetchRequest\n  }\n}\n\nfunction toAbsoluteUrl(url: string | URL): URL {\n  /**\n   * @note XMLHttpRequest interceptor may run in environments\n   * that implement XMLHttpRequest but don't implement \"location\"\n   * (for example, React Native). If that's the case, return the\n   * input URL as-is (nothing to be relative to).\n   * @see https://github.com/mswjs/msw/issues/1777\n   */\n  if (typeof location === 'undefined') {\n    return new URL(url)\n  }\n\n  return new URL(url.toString(), location.href)\n}\n\nfunction define(\n  target: object,\n  property: string | symbol,\n  value: unknown\n): void {\n  Reflect.defineProperty(target, property, {\n    // Ensure writable properties to allow redefining readonly properties.\n    writable: true,\n    enumerable: true,\n    value,\n  })\n}\n","/**\n * Concatenate two `Uint8Array` buffers.\n */\nexport function concatArrayBuffer(\n  left: Uint8Array,\n  right: Uint8Array\n): Uint8Array {\n  const result = new Uint8Array(left.byteLength + right.byteLength)\n  result.set(left, 0)\n  result.set(right, left.byteLength)\n  return result\n}\n","export class EventPolyfill implements Event {\n  readonly NONE = 0\n  readonly CAPTURING_PHASE = 1\n  readonly AT_TARGET = 2\n  readonly BUBBLING_PHASE = 3\n\n  public type: string = ''\n  public srcElement: EventTarget | null = null\n  public target: EventTarget | null\n  public currentTarget: EventTarget | null = null\n  public eventPhase: number = 0\n  public timeStamp: number\n  public isTrusted: boolean = true\n  public composed: boolean = false\n  public cancelable: boolean = true\n  public defaultPrevented: boolean = false\n  public bubbles: boolean = true\n  public lengthComputable: boolean = true\n  public loaded: number = 0\n  public total: number = 0\n\n  cancelBubble: boolean = false\n  returnValue: boolean = true\n\n  constructor(\n    type: string,\n    options?: { target: EventTarget; currentTarget: EventTarget }\n  ) {\n    this.type = type\n    this.target = options?.target || null\n    this.currentTarget = options?.currentTarget || null\n    this.timeStamp = Date.now()\n  }\n\n  public composedPath(): EventTarget[] {\n    return []\n  }\n\n  public initEvent(type: string, bubbles?: boolean, cancelable?: boolean) {\n    this.type = type\n    this.bubbles = !!bubbles\n    this.cancelable = !!cancelable\n  }\n\n  public preventDefault() {\n    this.defaultPrevented = true\n  }\n\n  public stopPropagation() {}\n  public stopImmediatePropagation() {}\n}\n","import { EventPolyfill } from './EventPolyfill'\n\nexport class ProgressEventPolyfill extends EventPolyfill {\n  readonly lengthComputable: boolean\n  readonly composed: boolean\n  readonly loaded: number\n  readonly total: number\n\n  constructor(type: string, init?: ProgressEventInit) {\n    super(type)\n\n    this.lengthComputable = init?.lengthComputable || false\n    this.composed = init?.composed || false\n    this.loaded = init?.loaded || 0\n    this.total = init?.total || 0\n  }\n}\n","import { EventPolyfill } from '../polyfills/EventPolyfill'\nimport { ProgressEventPolyfill } from '../polyfills/ProgressEventPolyfill'\n\nconst SUPPORTS_PROGRESS_EVENT = typeof ProgressEvent !== 'undefined'\n\nexport function createEvent(\n  target: XMLHttpRequest | XMLHttpRequestUpload,\n  type: string,\n  init?: ProgressEventInit\n): EventPolyfill | ProgressEvent {\n  const progressEvents = [\n    'error',\n    'progress',\n    'loadstart',\n    'loadend',\n    'load',\n    'timeout',\n    'abort',\n  ]\n\n  /**\n   * `ProgressEvent` is not supported in React Native.\n   * @see https://github.com/mswjs/interceptors/issues/40\n   */\n  const ProgressEventClass = SUPPORTS_PROGRESS_EVENT\n    ? ProgressEvent\n    : ProgressEventPolyfill\n\n  const event = progressEvents.includes(type)\n    ? new ProgressEventClass(type, {\n        lengthComputable: true,\n        loaded: init?.loaded || 0,\n        total: init?.total || 0,\n      })\n    : new EventPolyfill(type, {\n        target,\n        currentTarget: target,\n      })\n\n  return event\n}\n","/**\n * Returns the source object of the given property on the target object\n * (the target itself, any parent in its prototype, or null).\n */\nexport function findPropertySource(\n  target: object,\n  propertyName: string | symbol\n): object | null {\n  if (!(propertyName in target)) {\n    return null\n  }\n\n  const hasProperty = Object.prototype.hasOwnProperty.call(target, propertyName)\n  if (hasProperty) {\n    return target\n  }\n\n  const prototype = Reflect.getPrototypeOf(target)\n  return prototype ? findPropertySource(prototype, propertyName) : null\n}\n","import { findPropertySource } from './findPropertySource'\n\nexport interface ProxyOptions<Target extends Record<string, any>> {\n  constructorCall?(args: Array<unknown>, next: NextFunction<Target>): Target\n\n  methodCall?<F extends keyof Target>(\n    this: Target,\n    data: [methodName: F, args: Array<unknown>],\n    next: NextFunction<void>\n  ): void\n\n  setProperty?(\n    data: [propertyName: string | symbol, nextValue: unknown],\n    next: NextFunction<boolean>\n  ): boolean\n\n  getProperty?(\n    data: [propertyName: string | symbol, receiver: Target],\n    next: NextFunction<void>\n  ): void\n}\n\nexport type NextFunction<ReturnType> = () => ReturnType\n\nexport function createProxy<Target extends object>(\n  target: Target,\n  options: ProxyOptions<Target>\n): Target {\n  const proxy = new Proxy(target, optionsToProxyHandler(options))\n\n  return proxy\n}\n\nfunction optionsToProxyHandler<T extends Record<string, any>>(\n  options: ProxyOptions<T>\n): ProxyHandler<T> {\n  const { constructorCall, methodCall, getProperty, setProperty } = options\n  const handler: ProxyHandler<T> = {}\n\n  if (typeof constructorCall !== 'undefined') {\n    handler.construct = function (target, args, newTarget) {\n      const next = Reflect.construct.bind(null, target as any, args, newTarget)\n      return constructorCall.call(newTarget, args, next)\n    }\n  }\n\n  handler.set = function (target, propertyName, nextValue) {\n    const next = () => {\n      const propertySource = findPropertySource(target, propertyName) || target\n      const ownDescriptors = Reflect.getOwnPropertyDescriptor(\n        propertySource,\n        propertyName\n      )\n\n      // Respect any custom setters present for this property.\n      if (typeof ownDescriptors?.set !== 'undefined') {\n        ownDescriptors.set.apply(target, [nextValue])\n        return true\n      }\n\n      // Otherwise, set the property on the source.\n      return Reflect.defineProperty(propertySource, propertyName, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: nextValue,\n      })\n    }\n\n    if (typeof setProperty !== 'undefined') {\n      return setProperty.call(target, [propertyName, nextValue], next)\n    }\n\n    return next()\n  }\n\n  handler.get = function (target, propertyName, receiver) {\n    /**\n     * @note Using `Reflect.get()` here causes \"TypeError: Illegal invocation\".\n     */\n    const next = () => target[propertyName as any]\n\n    const value =\n      typeof getProperty !== 'undefined'\n        ? getProperty.call(target, [propertyName, receiver], next)\n        : next()\n\n    if (typeof value === 'function') {\n      return (...args: Array<any>) => {\n        const next = value.bind(target, ...args)\n\n        if (typeof methodCall !== 'undefined') {\n          return methodCall.call(target, [propertyName as any, args], next)\n        }\n\n        return next()\n      }\n    }\n\n    return value\n  }\n\n  return handler\n}\n","export function isDomParserSupportedType(\n  type: string\n): type is DOMParserSupportedType {\n  const supportedTypes: Array<DOMParserSupportedType> = [\n    'application/xhtml+xml',\n    'application/xml',\n    'image/svg+xml',\n    'text/html',\n    'text/xml',\n  ]\n  return supportedTypes.some((supportedType) => {\n    return type.startsWith(supportedType)\n  })\n}\n","/**\n * Parses a given string into JSON.\n * Gracefully handles invalid JSON by returning `null`.\n */\nexport function parseJson(data: string): Record<string, unknown> | null {\n  try {\n    const json = JSON.parse(data)\n    return json\n  } catch (_) {\n    return null\n  }\n}\n","import { FetchResponse } from '../../../utils/fetchUtils'\n\n/**\n * Creates a Fetch API `Response` instance from the given\n * `XMLHttpRequest` instance and a response body.\n */\nexport function createResponse(\n  request: XMLHttpRequest,\n  body: BodyInit | null\n): Response {\n  /**\n   * Handle XMLHttpRequest responses that must have null as the\n   * response body when represented using Fetch API Response.\n   * XMLHttpRequest response will always have an empty string\n   * as the \"request.response\" in those cases, resulting in an error\n   * when constructing a Response instance.\n   * @see https://github.com/mswjs/interceptors/issues/379\n   */\n  const responseBodyOrNull = FetchResponse.isResponseWithBody(request.status)\n    ? body\n    : null\n\n  return new FetchResponse(responseBodyOrNull, {\n    url: request.responseURL,\n    status: request.status,\n    statusText: request.statusText,\n    headers: createHeadersFromXMLHttpReqestHeaders(\n      request.getAllResponseHeaders()\n    ),\n  })\n}\n\nfunction createHeadersFromXMLHttpReqestHeaders(headersString: string): Headers {\n  const headers = new Headers()\n\n  const lines = headersString.split(/[\\r\\n]+/)\n  for (const line of lines) {\n    if (line.trim() === '') {\n      continue\n    }\n\n    const [name, ...parts] = line.split(': ')\n    const value = parts.join(': ')\n\n    headers.append(name, value)\n  }\n\n  return headers\n}\n","/**\n * Return a total byte length of the given request/response body.\n * If the `Content-Length` header is present, it will be used as the byte length.\n */\nexport async function getBodyByteLength(\n  input: Request | Response\n): Promise<number> {\n  const explicitContentLength = input.headers.get('content-length')\n\n  if (explicitContentLength != null && explicitContentLength !== '') {\n    return Number(explicitContentLength)\n  }\n\n  const buffer = await input.arrayBuffer()\n  return buffer.byteLength\n}\n","import type { Logger } from '@open-draft/logger'\nimport { XMLHttpRequestEmitter } from '.'\nimport { RequestController } from '../../RequestController'\nimport { XMLHttpRequestController } from './XMLHttpRequestController'\nimport { handleRequest } from '../../utils/handleRequest'\n\nexport interface XMLHttpRequestProxyOptions {\n  emitter: XMLHttpRequestEmitter\n  logger: Logger\n}\n\n/**\n * Create a proxied `XMLHttpRequest` class.\n * The proxied class establishes spies on certain methods,\n * allowing us to intercept requests and respond to them.\n */\nexport function createXMLHttpRequestProxy({\n  emitter,\n  logger,\n}: XMLHttpRequestProxyOptions) {\n  const XMLHttpRequestProxy = new Proxy(globalThis.XMLHttpRequest, {\n    construct(target, args, newTarget) {\n      logger.info('constructed new XMLHttpRequest')\n\n      const originalRequest = Reflect.construct(\n        target,\n        args,\n        newTarget\n      ) as XMLHttpRequest\n\n      /**\n       * @note Forward prototype descriptors onto the proxied object.\n       * XMLHttpRequest is implemented in JSDOM in a way that assigns\n       * a bunch of descriptors, like \"set responseType()\" on the prototype.\n       * With this propagation, we make sure that those descriptors trigger\n       * when the user operates with the proxied request instance.\n       */\n      const prototypeDescriptors = Object.getOwnPropertyDescriptors(\n        target.prototype\n      )\n      for (const propertyName in prototypeDescriptors) {\n        Reflect.defineProperty(\n          originalRequest,\n          propertyName,\n          prototypeDescriptors[propertyName]\n        )\n      }\n\n      const xhrRequestController = new XMLHttpRequestController(\n        originalRequest,\n        logger\n      )\n\n      xhrRequestController.onRequest = async function ({ request, requestId }) {\n        const controller = new RequestController(request)\n\n        this.logger.info('awaiting mocked response...')\n\n        this.logger.info(\n          'emitting the \"request\" event for %s listener(s)...',\n          emitter.listenerCount('request')\n        )\n\n        const isRequestHandled = await handleRequest({\n          request,\n          requestId,\n          controller,\n          emitter,\n          onResponse: async (response) => {\n            await this.respondWith(response)\n          },\n          onRequestError: () => {\n            this.errorWith(new TypeError('Network error'))\n          },\n          onError: (error) => {\n            this.logger.info('request errored!', { error })\n\n            if (error instanceof Error) {\n              this.errorWith(error)\n            }\n          },\n        })\n\n        if (!isRequestHandled) {\n          this.logger.info(\n            'no mocked response received, performing request as-is...'\n          )\n        }\n      }\n\n      xhrRequestController.onResponse = async function ({\n        response,\n        isMockedResponse,\n        request,\n        requestId,\n      }) {\n        this.logger.info(\n          'emitting the \"response\" event for %s listener(s)...',\n          emitter.listenerCount('response')\n        )\n\n        emitter.emit('response', {\n          response,\n          isMockedResponse,\n          request,\n          requestId,\n        })\n      }\n\n      // Return the proxied request from the controller\n      // so that the controller can react to the consumer's interactions\n      // with this request (opening/sending/etc).\n      return xhrRequestController.request\n    },\n  })\n\n  return XMLHttpRequestProxy\n}\n","import {\n  Interceptor,\n  BatchInterceptor,\n  HttpRequestEventMap,\n} from '@mswjs/interceptors'\nimport { FetchInterceptor } from '@mswjs/interceptors/fetch'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/XMLHttpRequest'\nimport { SetupWorkerInternalContext, StartOptions } from '../glossary'\nimport type { RequiredDeep } from '~/core/typeUtils'\nimport { handleRequest } from '~/core/utils/handleRequest'\nimport { isHandlerKind } from '~/core/utils/internal/isHandlerKind'\n\nexport function createFallbackRequestListener(\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Interceptor<HttpRequestEventMap> {\n  const interceptor = new BatchInterceptor({\n    name: 'fallback',\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()],\n  })\n\n  interceptor.on('request', async ({ request, requestId, controller }) => {\n    const requestCloneForLogs = request.clone()\n\n    const response = await handleRequest(\n      request,\n      requestId,\n      context.getRequestHandlers().filter(isHandlerKind('RequestHandler')),\n      options,\n      context.emitter,\n      {\n        onMockedResponse(_, { handler, parsedResult }) {\n          if (!options.quiet) {\n            context.emitter.once('response:mocked', ({ response }) => {\n              handler.log({\n                request: requestCloneForLogs,\n                response,\n                parsedResult,\n              })\n            })\n          }\n        },\n      },\n    )\n\n    if (response) {\n      controller.respondWith(response)\n    }\n  })\n\n  interceptor.on(\n    'response',\n    ({ response, isMockedResponse, request, requestId }) => {\n      context.emitter.emit(\n        isMockedResponse ? 'response:mocked' : 'response:bypass',\n        {\n          response,\n          request,\n          requestId,\n        },\n      )\n    },\n  )\n\n  interceptor.apply()\n\n  return interceptor\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\n\nexport function printStopMessage(args: { quiet?: boolean } = {}): void {\n  if (args.quiet) {\n    return\n  }\n\n  // eslint-disable-next-line no-console\n  console.log(\n    `%c${devUtils.formatMessage('Mocking disabled.')}`,\n    'color:orangered;font-weight:bold;',\n  )\n}\n"],"names":["error","devUtils","error","worker","devUtils","devUtils","error","devUtils","devUtils","symbol","devUtils","devUtils","error","devUtils","mergeRight","Emitter","Emitter","isObject","error","handleRequest","DeferredPromise","error","readable","transformers","handleRequest","response","next","IS_NODE","error","handleRequest","error","invariant","handleRequest","isHandlerKind","response","devUtils","devUtils","mergeRight"],"mappings":"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"}},
    {"offset": {"line": 3983, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/internal/isStringEqual.ts"],"sourcesContent":["/**\n * Performs a case-insensitive comparison of two given strings.\n */\nexport function isStringEqual(actual: string, expected: string): boolean {\n  return actual.toLowerCase() === expected.toLowerCase()\n}\n"],"names":[],"mappings":";;;;AAGO,SAAS,cAAc,MAAA,EAAgB,QAAA,EAA2B;IACvE,OAAO,OAAO,WAAA,CAAY,MAAM,SAAS,WAAA,CAAY;AACvD"}},
    {"offset": {"line": 3996, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/logging/getStatusCodeColor.ts"],"sourcesContent":["export enum StatusCodeColor {\n  Success = '#69AB32',\n  Warning = '#F0BB4B',\n  Danger = '#E95F5D',\n}\n\n/**\n * Returns a HEX color for a given response status code number.\n */\nexport function getStatusCodeColor(status: number): StatusCodeColor {\n  if (status < 300) {\n    return StatusCodeColor.Success\n  }\n\n  if (status < 400) {\n    return StatusCodeColor.Warning\n  }\n\n  return StatusCodeColor.Danger\n}\n"],"names":["StatusCodeColor"],"mappings":";;;;;;AAAO,IAAK,kBAAL,aAAA,GAAA,CAAA,CAAKA,qBAAL;IACLA,gBAAAA,CAAA,UAAA,GAAU;IACVA,gBAAAA,CAAA,UAAA,GAAU;IACVA,gBAAAA,CAAA,SAAA,GAAS;IAHC,OAAAA;AAAA,CAAA,EAAA,mBAAA,CAAA;AASL,SAAS,mBAAmB,MAAA,EAAiC;IAClE,IAAI,SAAS,KAAK;QAChB,OAAO,UAAA,WAAA;IACT;IAEA,IAAI,SAAS,KAAK;QAChB,OAAO,UAAA,WAAA;IACT;IAEA,OAAO,UAAA,UAAA;AACT"}},
    {"offset": {"line": 4023, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/logging/serializeRequest.ts"],"sourcesContent":["export interface LoggedRequest {\n  url: URL\n  method: string\n  headers: Record<string, string>\n  body: string\n}\n\n/**\n * Formats a mocked request for introspection in browser's console.\n */\nexport async function serializeRequest(\n  request: Request,\n): Promise<LoggedRequest> {\n  const requestClone = request.clone()\n  const requestText = await requestClone.text()\n\n  return {\n    url: new URL(request.url),\n    method: request.method,\n    headers: Object.fromEntries(request.headers.entries()),\n    body: requestText,\n  }\n}\n"],"names":[],"mappings":";;;;AAUA,eAAsB,iBACpB,OAAA,EACwB;IACxB,MAAM,eAAe,QAAQ,KAAA,CAAM;IACnC,MAAM,cAAc,MAAM,aAAa,IAAA,CAAK;IAE5C,OAAO;QACL,KAAK,IAAI,IAAI,QAAQ,GAAG;QACxB,QAAQ,QAAQ,MAAA;QAChB,SAAS,OAAO,WAAA,CAAY,QAAQ,OAAA,CAAQ,OAAA,CAAQ,CAAC;QACrD,MAAM;IACR;AACF"}},
    {"offset": {"line": 4043, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/logging/serializeResponse.ts"],"sourcesContent":["import statuses from '@bundled-es-modules/statuses'\n\nconst { message } = statuses\n\nexport interface SerializedResponse {\n  status: number\n  statusText: string\n  headers: Record<string, any>\n  body: string\n}\n\nexport async function serializeResponse(\n  response: Response,\n): Promise<SerializedResponse> {\n  const responseClone = response.clone()\n  const responseText = await responseClone.text()\n\n  // Normalize the response status and status text when logging\n  // since the default Response instance doesn't infer status texts\n  // from status codes. This has no effect on the actual response instance.\n  const responseStatus = responseClone.status || 200\n  const responseStatusText =\n    responseClone.statusText || message[responseStatus] || 'OK'\n\n  return {\n    status: responseStatus,\n    statusText: responseStatusText,\n    headers: Object.fromEntries(responseClone.headers.entries()),\n    body: responseText,\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,cAAc;;AAErB,MAAM,EAAE,OAAA,CAAQ,CAAA,GAAI,6KAAA;AASpB,eAAsB,kBACpB,QAAA,EAC6B;IAC7B,MAAM,gBAAgB,SAAS,KAAA,CAAM;IACrC,MAAM,eAAe,MAAM,cAAc,IAAA,CAAK;IAK9C,MAAM,iBAAiB,cAAc,MAAA,IAAU;IAC/C,MAAM,qBACJ,cAAc,UAAA,IAAc,OAAA,CAAQ,cAAc,CAAA,IAAK;IAEzD,OAAO;QACL,QAAQ;QACR,YAAY;QACZ,SAAS,OAAO,WAAA,CAAY,cAAc,OAAA,CAAQ,OAAA,CAAQ,CAAC;QAC3D,MAAM;IACR;AACF"}},
    {"offset": {"line": 4068, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/url/cleanUrl.ts"],"sourcesContent":["const REDUNDANT_CHARACTERS_EXP = /[?|#].*$/g\n\nexport function getSearchParams(path: string) {\n  return new URL(`/${path}`, 'http://localhost').searchParams\n}\n\n/**\n * Removes search parameters and the fragment\n * from a given URL string.\n */\nexport function cleanUrl(path: string): string {\n  // If the path ends with an optional path parameter,\n  // return it as-is.\n  if (path.endsWith('?')) {\n    return path\n  }\n\n  // Otherwise, remove the search and fragment from it.\n  return path.replace(REDUNDANT_CHARACTERS_EXP, '')\n}\n"],"names":[],"mappings":";;;;;;AAAA,MAAM,2BAA2B;AAE1B,SAAS,gBAAgB,IAAA,EAAc;IAC5C,OAAO,IAAI,IAAI,CAAA,CAAA,EAAI,IAAI,EAAA,EAAI,kBAAkB,EAAE,YAAA;AACjD;AAMO,SAAS,SAAS,IAAA,EAAsB;IAG7C,IAAI,KAAK,QAAA,CAAS,GAAG,GAAG;QACtB,OAAO;IACT;IAGA,OAAO,KAAK,OAAA,CAAQ,0BAA0B,EAAE;AAClD"}},
    {"offset": {"line": 4090, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/url/isAbsoluteUrl.ts"],"sourcesContent":["/**\n * Determines if the given URL string is an absolute URL.\n */\nexport function isAbsoluteUrl(url: string): boolean {\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url)\n}\n"],"names":[],"mappings":";;;;AAGO,SAAS,cAAc,GAAA,EAAsB;IAClD,OAAO,8BAA8B,IAAA,CAAK,GAAG;AAC/C"}},
    {"offset": {"line": 4103, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/url/getAbsoluteUrl.ts"],"sourcesContent":["import { isAbsoluteUrl } from './isAbsoluteUrl'\n\n/**\n * Returns an absolute URL based on the given path.\n */\nexport function getAbsoluteUrl(path: string, baseUrl?: string): string {\n  // already absolute URL\n  if (isAbsoluteUrl(path)) {\n    return path\n  }\n\n  // Ignore path with pattern start with *\n  if (path.startsWith('*')) {\n    return path\n  }\n\n  // Resolve a relative request URL against a given custom \"baseUrl\"\n  // or the document baseURI (in the case of browser/browser-like environments).\n  const origin = baseUrl || (typeof location !== 'undefined' && location.href)\n\n  return origin\n    ? // Encode and decode the path to preserve escaped characters.\n      decodeURI(new URL(encodeURI(path), origin).href)\n    : path\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,qBAAqB;;AAKvB,SAAS,eAAe,IAAA,EAAc,OAAA,EAA0B;IAErE,QAAI,iLAAA,EAAc,IAAI,GAAG;QACvB,OAAO;IACT;IAGA,IAAI,KAAK,UAAA,CAAW,GAAG,GAAG;QACxB,OAAO;IACT;IAIA,MAAM,SAAS,WAAY,OAAO,aAAa,eAAe,SAAS,IAAA;IAEvE,OAAO,SAAA,6DAAA;IAEH,UAAU,IAAI,IAAI,UAAU,IAAI,GAAG,MAAM,EAAE,IAAI,IAC/C;AACN"}},
    {"offset": {"line": 4126, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/matching/normalizePath.ts"],"sourcesContent":["import type { Path } from './matchRequestUrl'\nimport { cleanUrl } from '../url/cleanUrl'\nimport { getAbsoluteUrl } from '../url/getAbsoluteUrl'\n\n/**\n * Normalizes a given request handler path:\n * - Preserves RegExp.\n * - Removes query parameters and hashes.\n * - Rebases relative URLs against the \"baseUrl\" or the current location.\n * - Preserves relative URLs in Node.js, unless specified otherwise.\n * - Preserves optional path parameters.\n */\nexport function normalizePath(path: Path, baseUrl?: string): Path {\n  // RegExp paths do not need normalization.\n  if (path instanceof RegExp) {\n    return path\n  }\n\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl)\n\n  return cleanUrl(maybeAbsoluteUrl)\n}\n"],"names":[],"mappings":";;;;AACA,SAAS,gBAAgB;AACzB,SAAS,sBAAsB;;;AAUxB,SAAS,cAAc,IAAA,EAAY,OAAA,EAAwB;IAEhE,IAAI,gBAAgB,QAAQ;QAC1B,OAAO;IACT;IAEA,MAAM,uBAAmB,mLAAA,EAAe,MAAM,OAAO;IAErD,WAAO,uKAAA,EAAS,gBAAgB;AAClC"}},
    {"offset": {"line": 4147, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/matching/matchRequestUrl.ts"],"sourcesContent":["import { match } from 'path-to-regexp'\nimport { getCleanUrl } from '@mswjs/interceptors'\nimport { normalizePath } from './normalizePath'\n\nexport type Path = string | RegExp\nexport type PathParams<KeyType extends keyof any = string> = {\n  [ParamName in KeyType]?: string | ReadonlyArray<string>\n}\n\nexport interface Match {\n  matches: boolean\n  params?: PathParams\n}\n\n/**\n * Coerce a path supported by MSW into a path\n * supported by \"path-to-regexp\".\n */\nexport function coercePath(path: string): string {\n  return (\n    path\n      /**\n       * Replace wildcards (\"*\") with unnamed capturing groups\n       * because \"path-to-regexp\" doesn't support wildcards.\n       * Ignore path parameter' modifiers (i.e. \":name*\").\n       */\n      .replace(\n        /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n        (_, parameterName: string | undefined, wildcard: string) => {\n          const expression = '(.*)'\n\n          if (!parameterName) {\n            return expression\n          }\n\n          return parameterName.startsWith(':')\n            ? `${parameterName}${wildcard}`\n            : `${parameterName}${expression}`\n        },\n      )\n      /**\n       * Escape the port so that \"path-to-regexp\" can match\n       * absolute URLs including port numbers.\n       */\n      .replace(/([^/])(:)(?=\\d+)/, '$1\\\\$2')\n      /**\n       * Escape the protocol so that \"path-to-regexp\" could match\n       * absolute URL.\n       * @see https://github.com/pillarjs/path-to-regexp/issues/259\n       */\n      .replace(/^([^/]+)(:)(?=\\/\\/)/, '$1\\\\$2')\n  )\n}\n\n/**\n * Returns the result of matching given request URL against a mask.\n */\nexport function matchRequestUrl(url: URL, path: Path, baseUrl?: string): Match {\n  const normalizedPath = normalizePath(path, baseUrl)\n  const cleanPath =\n    typeof normalizedPath === 'string'\n      ? coercePath(normalizedPath)\n      : normalizedPath\n\n  const cleanUrl = getCleanUrl(url)\n  const result = match(cleanPath, { decode: decodeURIComponent })(cleanUrl)\n  const params = (result && (result.params as PathParams)) || {}\n\n  return {\n    matches: result !== false,\n    params,\n  }\n}\n\nexport function isPath(value: unknown): value is Path {\n  return typeof value === 'string' || value instanceof RegExp\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,SAAS,aAAa;AACtB,SAAS,mBAAmB;AAC5B,SAAS,qBAAqB;;;;AAgBvB,SAAS,WAAW,IAAA,EAAsB;IAC/C,OACE,KAMG,OAAA,CACC,6BACA,CAAC,GAAG,eAAmC,aAAqB;QAC1D,MAAM,aAAa;QAEnB,IAAI,CAAC,eAAe;YAClB,OAAO;QACT;QAEA,OAAO,cAAc,UAAA,CAAW,GAAG,IAC/B,GAAG,aAAa,GAAG,QAAQ,EAAA,GAC3B,GAAG,aAAa,GAAG,UAAU,EAAA;IACnC,GAMD,OAAA,CAAQ,oBAAoB,QAAQ,EAMpC,OAAA,CAAQ,uBAAuB,QAAQ;AAE9C;AAKO,SAAS,gBAAgB,GAAA,EAAU,IAAA,EAAY,OAAA,EAAyB;IAC7E,MAAM,qBAAiB,sLAAA,EAAc,MAAM,OAAO;IAClD,MAAM,YACJ,OAAO,mBAAmB,WACtB,WAAW,cAAc,IACzB;IAEN,MAAM,eAAW,8LAAA,EAAY,GAAG;IAChC,MAAM,aAAS,oKAAA,EAAM,WAAW;QAAE,QAAQ;IAAmB,CAAC,EAAE,QAAQ;IACxE,MAAM,SAAU,UAAW,OAAO,MAAA,IAA0B,CAAC;IAE7D,OAAO;QACL,SAAS,WAAW;QACpB;IACF;AACF;AAEO,SAAS,OAAO,KAAA,EAA+B;IACpD,OAAO,OAAO,UAAU,YAAY,iBAAiB;AACvD"}},
    {"offset": {"line": 4192, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/utils/request/getRequestCookies.ts"],"sourcesContent":["import cookieUtils from '@bundled-es-modules/cookie'\nimport { cookieStore } from '../cookieStore'\n\nfunction parseCookies(input: string): Record<string, string> {\n  const parsedCookies = cookieUtils.parse(input)\n  const cookies: Record<string, string> = {}\n\n  for (const cookieName in parsedCookies) {\n    if (typeof parsedCookies[cookieName] !== 'undefined') {\n      cookies[cookieName] = parsedCookies[cookieName]\n    }\n  }\n\n  return cookies\n}\n\nfunction getAllDocumentCookies() {\n  return parseCookies(document.cookie)\n}\n\nfunction getDocumentCookies(request: Request): Record<string, string> {\n  if (typeof document === 'undefined' || typeof location === 'undefined') {\n    return {}\n  }\n\n  switch (request.credentials) {\n    case 'same-origin': {\n      const requestUrl = new URL(request.url)\n\n      // Return document cookies only when requested a resource\n      // from the same origin as the current document.\n      return location.origin === requestUrl.origin\n        ? getAllDocumentCookies()\n        : {}\n    }\n\n    case 'include': {\n      // Return all document cookies.\n      return getAllDocumentCookies()\n    }\n\n    default: {\n      return {}\n    }\n  }\n}\n\nexport function getAllRequestCookies(request: Request): Record<string, string> {\n  /**\n   * @note While the \"cookie\" header is a forbidden header field\n   * in the browser, you can read it in Node.js. We need to respect\n   * it for mocking in Node.js.\n   */\n  const requestCookieHeader = request.headers.get('cookie')\n  const cookiesFromHeaders = requestCookieHeader\n    ? parseCookies(requestCookieHeader)\n    : {}\n\n  const cookiesFromDocument = getDocumentCookies(request)\n\n  // Forward the document cookies to the request headers.\n  for (const name in cookiesFromDocument) {\n    request.headers.append(\n      'cookie',\n      cookieUtils.serialize(name, cookiesFromDocument[name]),\n    )\n  }\n\n  const cookiesFromStore = cookieStore.getCookies(request.url)\n  const storedCookiesObject = Object.fromEntries(\n    cookiesFromStore.map((cookie) => [cookie.key, cookie.value]),\n  )\n\n  // Forward the raw stored cookies to request headers\n  // so they contain metadata like \"expires\", \"secure\", etc.\n  for (const cookie of cookiesFromStore) {\n    request.headers.append('cookie', cookie.toString())\n  }\n\n  return {\n    ...cookiesFromDocument,\n    ...storedCookiesObject,\n    ...cookiesFromHeaders,\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,iBAAiB;AACxB,SAAS,mBAAmB;;;AAE5B,SAAS,aAAa,KAAA,EAAuC;IAC3D,MAAM,gBAAgB,2KAAA,CAAY,KAAA,CAAM,KAAK;IAC7C,MAAM,UAAkC,CAAC;IAEzC,IAAA,MAAW,cAAc,cAAe;QACtC,IAAI,OAAO,aAAA,CAAc,UAAU,CAAA,KAAM,aAAa;YACpD,OAAA,CAAQ,UAAU,CAAA,GAAI,aAAA,CAAc,UAAU,CAAA;QAChD;IACF;IAEA,OAAO;AACT;AAEA,SAAS,wBAAwB;IAC/B,OAAO,aAAa,SAAS,MAAM;AACrC;AAEA,SAAS,mBAAmB,OAAA,EAA0C;IACpE,IAAI,OAAO,aAAa,eAAe,OAAO,aAAa,aAAa;QACtE,OAAO,CAAC;IACV;IAEA,OAAQ,QAAQ,WAAA,EAAa;QAC3B,KAAK;YAAe;gBAClB,MAAM,aAAa,IAAI,IAAI,QAAQ,GAAG;gBAItC,OAAO,SAAS,MAAA,KAAW,WAAW,MAAA,GAClC,sBAAsB,IACtB,CAAC;YACP;QAEA,KAAK;YAAW;gBAEd,OAAO,sBAAsB;YAC/B;QAEA;YAAS;gBACP,OAAO,CAAC;YACV;IACF;AACF;AAEO,SAAS,qBAAqB,OAAA,EAA0C;IAM7E,MAAM,sBAAsB,QAAQ,OAAA,CAAQ,GAAA,CAAI,QAAQ;IACxD,MAAM,qBAAqB,sBACvB,aAAa,mBAAmB,IAChC,CAAC;IAEL,MAAM,sBAAsB,mBAAmB,OAAO;IAGtD,IAAA,MAAW,QAAQ,oBAAqB;QACtC,QAAQ,OAAA,CAAQ,MAAA,CACd,UACA,2KAAA,CAAY,SAAA,CAAU,MAAM,mBAAA,CAAoB,IAAI,CAAC;IAEzD;IAEA,MAAM,mBAAmB,sKAAA,CAAY,UAAA,CAAW,QAAQ,GAAG;IAC3D,MAAM,sBAAsB,OAAO,WAAA,CACjC,iBAAiB,GAAA,CAAI,CAAC,SAAW;YAAC,OAAO,GAAA;YAAK,OAAO,KAAK;SAAC;IAK7D,KAAA,MAAW,UAAU,iBAAkB;QACrC,QAAQ,OAAA,CAAQ,MAAA,CAAO,UAAU,OAAO,QAAA,CAAS,CAAC;IACpD;IAEA,OAAO;QACL,GAAG,mBAAA;QACH,GAAG,mBAAA;QACH,GAAG,kBAAA;IACL;AACF"}},
    {"offset": {"line": 4260, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/handlers/HttpHandler.ts"],"sourcesContent":["import { ResponseResolutionContext } from '../utils/executeHandlers'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { isStringEqual } from '../utils/internal/isStringEqual'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { serializeRequest } from '../utils/logging/serializeRequest'\nimport { serializeResponse } from '../utils/logging/serializeResponse'\nimport {\n  matchRequestUrl,\n  Match,\n  Path,\n  PathParams,\n} from '../utils/matching/matchRequestUrl'\nimport { toPublicUrl } from '../utils/request/toPublicUrl'\nimport { getAllRequestCookies } from '../utils/request/getRequestCookies'\nimport { cleanUrl, getSearchParams } from '../utils/url/cleanUrl'\nimport {\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  RequestHandlerOptions,\n  ResponseResolver,\n} from './RequestHandler'\n\ntype HttpHandlerMethod = string | RegExp\n\nexport interface HttpHandlerInfo extends RequestHandlerDefaultInfo {\n  method: HttpHandlerMethod\n  path: HttpRequestPredicate<PathParams>\n}\n\nexport enum HttpMethods {\n  HEAD = 'HEAD',\n  GET = 'GET',\n  POST = 'POST',\n  PUT = 'PUT',\n  PATCH = 'PATCH',\n  OPTIONS = 'OPTIONS',\n  DELETE = 'DELETE',\n}\n\nexport type RequestQuery = {\n  [queryName: string]: string\n}\n\nexport type HttpRequestParsedResult = {\n  match: Match\n  cookies: Record<string, string>\n}\n\nexport type HttpRequestResolverExtras<Params extends PathParams> = {\n  params: Params\n  cookies: Record<string, string>\n}\n\nexport type HttpCustomPredicate<Params extends PathParams> = (args: {\n  request: Request\n  cookies: Record<string, string>\n}) =>\n  | HttpCustomPredicateResult<Params>\n  | Promise<HttpCustomPredicateResult<Params>>\n\nexport type HttpCustomPredicateResult<Params extends PathParams> =\n  | boolean\n  | {\n      matches: boolean\n      params: Params\n    }\n\nexport type HttpRequestPredicate<Params extends PathParams> =\n  | Path\n  | HttpCustomPredicate<Params>\n\n/**\n * Request handler for HTTP requests.\n * Provides request matching based on method and URL.\n */\nexport class HttpHandler extends RequestHandler<\n  HttpHandlerInfo,\n  HttpRequestParsedResult,\n  HttpRequestResolverExtras<any>\n> {\n  constructor(\n    method: HttpHandlerMethod,\n    predicate: HttpRequestPredicate<PathParams>,\n    resolver: ResponseResolver<HttpRequestResolverExtras<any>, any, any>,\n    options?: RequestHandlerOptions,\n  ) {\n    const displayPath =\n      typeof predicate === 'function' ? '[custom predicate]' : predicate\n\n    super({\n      info: {\n        header: `${method}${displayPath ? ` ${displayPath}` : ''}`,\n        path: predicate,\n        method,\n      },\n      resolver,\n      options,\n    })\n\n    this.checkRedundantQueryParameters()\n  }\n\n  private checkRedundantQueryParameters() {\n    const { method, path } = this.info\n\n    if (!path || path instanceof RegExp || typeof path === 'function') {\n      return\n    }\n\n    const url = cleanUrl(path)\n\n    // Bypass request handler URLs that have no redundant characters.\n    if (url === path) {\n      return\n    }\n\n    const searchParams = getSearchParams(path)\n    const queryParams: Array<string> = []\n\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName)\n    })\n\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters using \"new URL(request.url).searchParams\" instead. Learn more: https://mswjs.io/docs/http/intercepting-requests#querysearch-parameters`,\n    )\n  }\n\n  async parse(args: {\n    request: Request\n    resolutionContext?: ResponseResolutionContext\n  }) {\n    const url = new URL(args.request.url)\n    const cookies = getAllRequestCookies(args.request)\n\n    /**\n     * Handle custom predicate functions.\n     * @note Invoke this during parsing so the user can parse the path parameters\n     * manually. Otherwise, `params` is always an empty object, which isn't nice.\n     */\n    if (typeof this.info.path === 'function') {\n      const customPredicateResult = await this.info.path({\n        request: args.request,\n        cookies,\n      })\n\n      const match =\n        typeof customPredicateResult === 'boolean'\n          ? {\n              matches: customPredicateResult,\n              params: {},\n            }\n          : customPredicateResult\n\n      return {\n        match,\n        cookies,\n      }\n    }\n\n    const match = this.info.path\n      ? matchRequestUrl(url, this.info.path, args.resolutionContext?.baseUrl)\n      : { matches: false, params: {} }\n\n    return {\n      match,\n      cookies,\n    }\n  }\n\n  async predicate(args: {\n    request: Request\n    parsedResult: HttpRequestParsedResult\n    resolutionContext?: ResponseResolutionContext\n  }) {\n    const hasMatchingMethod = this.matchMethod(args.request.method)\n    const hasMatchingUrl = args.parsedResult.match.matches\n    return hasMatchingMethod && hasMatchingUrl\n  }\n\n  private matchMethod(actualMethod: string): boolean {\n    return this.info.method instanceof RegExp\n      ? this.info.method.test(actualMethod)\n      : isStringEqual(this.info.method, actualMethod)\n  }\n\n  protected extendResolverArgs(args: {\n    request: Request\n    parsedResult: HttpRequestParsedResult\n  }) {\n    return {\n      params: args.parsedResult.match?.params || {},\n      cookies: args.parsedResult.cookies,\n    }\n  }\n\n  async log(args: { request: Request; response: Response }) {\n    const publicUrl = toPublicUrl(args.request.url)\n    const loggedRequest = await serializeRequest(args.request)\n    const loggedResponse = await serializeResponse(args.response)\n    const statusColor = getStatusCodeColor(loggedResponse.status)\n\n    console.groupCollapsed(\n      devUtils.formatMessage(\n        `${getTimestamp()} ${args.request.method} ${publicUrl} (%c${\n          loggedResponse.status\n        } ${loggedResponse.statusText}%c)`,\n      ),\n      `color:${statusColor}`,\n      'color:inherit',\n    )\n    // eslint-disable-next-line no-console\n    console.log('Request', loggedRequest)\n    // eslint-disable-next-line no-console\n    console.log('Handler:', this)\n    // eslint-disable-next-line no-console\n    console.log('Response', loggedResponse)\n    console.groupEnd()\n  }\n}\n"],"names":["HttpMethods","match"],"mappings":"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"}},
    {"offset": {"line": 4386, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/http.ts"],"sourcesContent":["import {\n  DefaultBodyType,\n  RequestHandlerOptions,\n  ResponseResolver,\n} from './handlers/RequestHandler'\nimport {\n  HttpMethods,\n  HttpHandler,\n  HttpRequestResolverExtras,\n  HttpRequestPredicate,\n} from './handlers/HttpHandler'\nimport type { PathParams } from './utils/matching/matchRequestUrl'\n\nexport type HttpRequestHandler = <\n  Params extends PathParams<keyof Params> = PathParams,\n  RequestBodyType extends DefaultBodyType = DefaultBodyType,\n  // Response body type MUST be undefined by default.\n  // This is how we can distinguish between a handler that\n  // returns plain \"Response\" and the one returning \"HttpResponse\"\n  // to enforce a stricter response body type.\n  ResponseBodyType extends DefaultBodyType = undefined,\n>(\n  predicate: HttpRequestPredicate<Params>,\n  resolver: HttpResponseResolver<Params, RequestBodyType, ResponseBodyType>,\n  options?: RequestHandlerOptions,\n) => HttpHandler\n\nexport type HttpResponseResolver<\n  Params extends PathParams<keyof Params> = PathParams,\n  RequestBodyType extends DefaultBodyType = DefaultBodyType,\n  ResponseBodyType extends DefaultBodyType = DefaultBodyType,\n> = ResponseResolver<\n  HttpRequestResolverExtras<Params>,\n  RequestBodyType,\n  ResponseBodyType\n>\n\nfunction createHttpHandler<Method extends HttpMethods | RegExp>(\n  method: Method,\n): HttpRequestHandler {\n  return (predicate, resolver, options = {}) => {\n    return new HttpHandler(method, predicate, resolver, options)\n  }\n}\n\n/**\n * A namespace to intercept and mock HTTP requests.\n *\n * @example\n * http.get('/user', resolver)\n * http.post('/post/:id', resolver)\n *\n * @see {@link https://mswjs.io/docs/api/http `http` API reference}\n */\nexport const http = {\n  all: createHttpHandler(/.+/),\n  head: createHttpHandler(HttpMethods.HEAD),\n  get: createHttpHandler(HttpMethods.GET),\n  post: createHttpHandler(HttpMethods.POST),\n  put: createHttpHandler(HttpMethods.PUT),\n  delete: createHttpHandler(HttpMethods.DELETE),\n  patch: createHttpHandler(HttpMethods.PATCH),\n  options: createHttpHandler(HttpMethods.OPTIONS),\n}\n"],"names":[],"mappings":";;;;AAKA;;AAgCA,SAAS,kBACP,MAAA,EACoB;IACpB,OAAO,CAAC,WAAW,UAAU,UAAU,CAAC,CAAA,KAAM;QAC5C,OAAO,IAAI,yKAAA,CAAY,QAAQ,WAAW,UAAU,OAAO;IAC7D;AACF;AAWO,MAAM,OAAO;IAClB,KAAK,kBAAkB,IAAI;IAC3B,MAAM,kBAAkB,yKAAA,CAAY,IAAI;IACxC,KAAK,kBAAkB,yKAAA,CAAY,GAAG;IACtC,MAAM,kBAAkB,yKAAA,CAAY,IAAI;IACxC,KAAK,kBAAkB,yKAAA,CAAY,GAAG;IACtC,QAAQ,kBAAkB,yKAAA,CAAY,MAAM;IAC5C,OAAO,kBAAkB,yKAAA,CAAY,KAAK;IAC1C,SAAS,kBAAkB,yKAAA,CAAY,OAAO;AAChD"}},
    {"offset": {"line": 4413, "column": 0}, "map": {"version":3,"sources":["file:///home/jerensl/Projects/www.jerenslensun.com/node_modules/msw/src/core/HttpResponse.ts"],"sourcesContent":["import { FetchResponse } from '@mswjs/interceptors'\nimport type { DefaultBodyType, JsonBodyType } from './handlers/RequestHandler'\nimport type { NoInfer } from './typeUtils'\nimport {\n  decorateResponse,\n  normalizeResponseInit,\n} from './utils/HttpResponse/decorators'\n\nexport interface HttpResponseInit extends ResponseInit {\n  type?: ResponseType\n}\n\nexport const bodyType: unique symbol = Symbol('bodyType')\nexport type DefaultUnsafeFetchResponse = Response & {\n  [bodyType]?: never\n}\n\nexport interface StrictRequest<BodyType extends JsonBodyType> extends Request {\n  json(): Promise<BodyType>\n}\n\n/**\n * Opaque `Response` type that supports strict body type.\n *\n * @deprecated Please use {@link HttpResponse} instead.\n */\nexport type StrictResponse<BodyType extends DefaultBodyType> =\n  HttpResponse<BodyType>\n\n/**\n * A drop-in replacement for the standard `Response` class\n * to allow additional features, like mocking the response `Set-Cookie` header.\n *\n * @example\n * new HttpResponse('Hello world', { status: 201 })\n * HttpResponse.json({ name: 'John' })\n * HttpResponse.formData(form)\n *\n * @see {@link https://mswjs.io/docs/api/http-response `HttpResponse` API reference}\n */\nexport class HttpResponse<\n  BodyType extends DefaultBodyType,\n> extends FetchResponse {\n  readonly [bodyType]: BodyType = null as any\n\n  constructor(body?: NoInfer<BodyType> | null, init?: HttpResponseInit) {\n    const responseInit = normalizeResponseInit(init)\n    super(body as BodyInit, responseInit)\n    decorateResponse(this, responseInit)\n  }\n\n  static error(): HttpResponse<any> {\n    return super.error() as HttpResponse<any>\n  }\n\n  /**\n   * Create a `Response` with a `Content-Type: \"text/plain\"` body.\n   * @example\n   * HttpResponse.text('hello world')\n   * HttpResponse.text('Error', { status: 500 })\n   */\n  static text<BodyType extends string>(\n    body?: NoInfer<BodyType> | null,\n    init?: HttpResponseInit,\n  ): HttpResponse<BodyType> {\n    const responseInit = normalizeResponseInit(init)\n\n    if (!responseInit.headers.has('Content-Type')) {\n      responseInit.headers.set('Content-Type', 'text/plain')\n    }\n\n    // Automatically set the \"Content-Length\" response header\n    // for non-empty text responses. This enforces consistency and\n    // brings mocked responses closer to production.\n    if (!responseInit.headers.has('Content-Length')) {\n      responseInit.headers.set(\n        'Content-Length',\n        body ? new Blob([body]).size.toString() : '0',\n      )\n    }\n\n    return new HttpResponse(body, responseInit)\n  }\n\n  /**\n   * Create a `Response` with a `Content-Type: \"application/json\"` body.\n   * @example\n   * HttpResponse.json({ firstName: 'John' })\n   * HttpResponse.json({ error: 'Not Authorized' }, { status: 401 })\n   */\n  static json<BodyType extends JsonBodyType>(\n    body?: NoInfer<BodyType> | null | undefined,\n    init?: HttpResponseInit,\n  ): HttpResponse<BodyType> {\n    const responseInit = normalizeResponseInit(init)\n\n    if (!responseInit.headers.has('Content-Type')) {\n      responseInit.headers.set('Content-Type', 'application/json')\n    }\n\n    /**\n     * @note TypeScript is incorrect here.\n     * Stringifying undefined will return undefined.\n     */\n    const responseText = JSON.stringify(body) as string | undefined\n\n    if (!responseInit.headers.has('Content-Length')) {\n      responseInit.headers.set(\n        'Content-Length',\n        responseText ? new Blob([responseText]).size.toString() : '0',\n      )\n    }\n\n    return new HttpResponse(responseText as BodyType, responseInit)\n  }\n\n  /**\n   * Create a `Response` with a `Content-Type: \"application/xml\"` body.\n   * @example\n   * HttpResponse.xml(`<user name=\"John\" />`)\n   * HttpResponse.xml(`<article id=\"abc-123\" />`, { status: 201 })\n   */\n  static xml<BodyType extends string>(\n    body?: BodyType | null,\n    init?: HttpResponseInit,\n  ): HttpResponse<BodyType> {\n    const responseInit = normalizeResponseInit(init)\n\n    if (!responseInit.headers.has('Content-Type')) {\n      responseInit.headers.set('Content-Type', 'text/xml')\n    }\n\n    return new HttpResponse(body, responseInit)\n  }\n\n  /**\n   * Create a `Response` with a `Content-Type: \"text/html\"` body.\n   * @example\n   * HttpResponse.html(`<p class=\"author\">Jane Doe</p>`)\n   * HttpResponse.html(`<main id=\"abc-123\">Main text</main>`, { status: 201 })\n   */\n  static html<BodyType extends string>(\n    body?: BodyType | null,\n    init?: HttpResponseInit,\n  ): HttpResponse<BodyType> {\n    const responseInit = normalizeResponseInit(init)\n\n    if (!responseInit.headers.has('Content-Type')) {\n      responseInit.headers.set('Content-Type', 'text/html')\n    }\n\n    return new HttpResponse(body, responseInit)\n  }\n\n  /**\n   * Create a `Response` with an `ArrayBuffer` body.\n   * @example\n   * const buffer = new ArrayBuffer(3)\n   * const view = new Uint8Array(buffer)\n   * view.set([1, 2, 3])\n   *\n   * HttpResponse.arrayBuffer(buffer)\n   */\n  static arrayBuffer<BodyType extends ArrayBuffer | SharedArrayBuffer>(\n    body?: BodyType,\n    init?: HttpResponseInit,\n  ): HttpResponse<BodyType> {\n    const responseInit = normalizeResponseInit(init)\n\n    if (!responseInit.headers.has('Content-Type')) {\n      responseInit.headers.set('Content-Type', 'application/octet-stream')\n    }\n\n    if (body && !responseInit.headers.has('Content-Length')) {\n      responseInit.headers.set('Content-Length', body.byteLength.toString())\n    }\n\n    return new HttpResponse(body, responseInit)\n  }\n\n  /**\n   * Create a `Response` with a `FormData` body.\n   * @example\n   * const data = new FormData()\n   * data.set('name', 'Alice')\n   *\n   * HttpResponse.formData(data)\n   */\n  static formData(\n    body?: FormData,\n    init?: HttpResponseInit,\n  ): HttpResponse<FormData> {\n    return new HttpResponse(body, normalizeResponseInit(init))\n  }\n}\n"],"names":[],"mappings":"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"}}]
}